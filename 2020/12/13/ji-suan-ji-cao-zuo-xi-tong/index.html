<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="计算机操作系统, HTML,CSS,JavaScript,JQuery,Java,Spring等">
    <meta name="description" content="专注web">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>计算机操作系统 | 博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">博客</div>
        <div class="logo-desc">
            
            专注web
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/xly-star" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/xly-star" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">计算机操作系统</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">计算机操作系统</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-12-13
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-12-19
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    34.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    118 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><a target="_blank" rel="noopener" href="https://www.icourse163.org/course/ZCIB-1002149003">慕课课程笔记</a></p>
<h1 id="操作系统的目标与作用"><a href="#操作系统的目标与作用" class="headerlink" title="操作系统的目标与作用"></a>操作系统的目标与作用</h1><h2 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h2><ul>
<li>操作系统(Operating System，OS)是**<em>管理计算机硬件和软件资源、合理调度作业运行、方便用户使用的程序集合**</em>。</li>
<li>操作系统既是程序集合，也是唯一跟硬件通信的系统软件。</li>
<li>管理硬件资源<ul>
<li>如:配置0S后，可以方便地保存文件，不必了解内存和磁盘的结构</li>
<li>如:可以方便地打印文件，不必了解打印机的工作原理</li>
</ul>
</li>
<li>管理软件资源<br>可以方便地操作文件、查看目录，而不必了解文件的存储结构、以及存取方式。</li>
<li>合理调度作业<br>当多道作业同时运行时，OS可以通过合理地分配CPU、内存、外部设备，调度多个作业在同一时间段内，同时运行。</li>
<li>方便用户<br>可以通过命令、程序、图形等方式，调用0S提供的服务。</li>
</ul>
<h2 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h2><ol>
<li><p>有效性</p>
<p>管理软硬件资源，合理地组织计算机的工作流程</p>
</li>
<li><p>方便性</p>
<p>提供良好的、一致的用户接口，屏蔽硬件系统的类型和数量差别</p>
<p>如:不管磁盘型号是什么，用户读写文件的read、write操作是一致的。</p>
</li>
<li><p>开放性</p>
<p>0S遵循统一的标准进行规范的软件开发，彼此兼容，方便互联</p>
</li>
<li><p>可扩充性</p>
<p>因为符合标准，所以在规范的结构下，易于实现多个系统之间的资源共享和互操作，易于功能扩充、和系统升级</p>
</li>
</ol>
<h2 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h2><p>(1) 用户观点。</p>
<p>操作系统是用户与硬件系统的接口。</p>
<p>(2) 系统观点。</p>
<p>操作系统是资源管理者(CPU管理，存储器管理，设备管理，文件管理)</p>
<p>(3) 功能扩充的观点。</p>
<p>操作系统用作扩充机。<br>如:多道程序设计技术<br>如:虚拟存储器技术</p>
<p>如: SPLOOLING技术通常把覆盖了软件的机器，称为扩充器，或虚拟机。OS将诸多功能覆盖到机器上，扩充成了功能强大的计算机</p>
<h2 id="操作系统发展的主要动力"><a href="#操作系统发展的主要动力" class="headerlink" title="操作系统发展的主要动力"></a>操作系统发展的主要动力</h2><ol>
<li>不断提高计算机资源利用率的需求</li>
<li>方便用户</li>
<li>硬件的不断更新换代。从8位机，到16位-32位-64位， 摩尔定律不断地发挥作用，促使0S不断升级</li>
<li>计算机体系结构的不断发展。从单处理器，到多处理机、网络0S、云服务平台，促使0S功能越来越强大</li>
</ol>
<h1 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h1><h2 id="无操作系统的计算机系统"><a href="#无操作系统的计算机系统" class="headerlink" title="无操作系统的计算机系统"></a>无操作系统的计算机系统</h2><ol>
<li><p>人工操作方式 </p>
<p>从第一台计算机诞生(1945年)到50年代中期的计算机，是利用成千上 万个真空管做成的，属于第一代计算机, 体积大，运行速度慢。  用户采用人工方式操作计算机硬件系统。 </p>
<p>程序员将事先已穿孔的纸带装入卡片输入机，再启动它们，将程序和数据输入计算机； </p>
<p>当计算机运行到程序结束，用户卸下纸带、取走运行结果后，才允许下一个用户上机。</p>
<p>具有以下两方面的缺点： (1) 用户独占全机。 (2) CPU等待人工操作。</p>
<p>随着CPU与I/O设备速度不匹配的矛盾日益突出，在 20世纪50年代末期又引入了**<em>脱机输入输出技术**</em>。 </p>
</li>
<li><p><strong><em>脱机输入输出技术</em></strong></p>
<p>事先将装有用户程序和数据的纸带装入纸带输入机，在一台**<em>处围机**</em>的控制下，将纸带上的程序和数据输入到磁盘上；当计算机需要读取这些程序和数据时，可以从磁盘将其高速地调 入内存。</p>
<p>与人工操作相比，脱机I/O (1)减少了CPU的空闲时间。 (2) 提高I/O速度。</p>
</li>
</ol>
<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><ol>
<li><p>20世纪50年代末到60年代初期，用晶体管制作计算机， 称为第二代计算机，体积减小，功耗降低。 </p>
<p>为提高计算机的利用率，利用磁盘（或者磁带）把若干个作业分类，编成一批作业序列，每个批作业由一个专门的监督程序自动依次处理，形成单道批处理系统。</p>
</li>
<li><p>系统处理流程</p>
<p>将一批作业以脱机方式输入到磁盘上。首先，监督程序将磁盘上的第一个作业装入内存，并将运行控制权交给该作业，当作业处理完 成后，将控制权还给监督程序； 接下来，监督程序将磁盘上的第二个作业装入内存，这样，控制 一批作业一个接一个的连续处理， 直到磁盘上的作业全部完成。</p>
</li>
<li><p>特征： </p>
<p>自动性 顺序性 单道性</p>
</li>
</ol>
<h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><ol>
<li><p>多道批处理系统的产生</p>
<p>用户所提交的作业先存放在外存上，排成一个 “后备队列”；由调度程序按一定的算法，从后备队列中选择<font color='red'>若干个作业</font>调入内存，共享系统各种资源，形成多道批处理系统。</p>
</li>
<li><p>多道程序设计技术</p>
<p>单道批系统中，内存只放一道作业，按照先进先出的原则顺序执行。 在多道批处理系统中，内存中存放若干道程序，可交替执行。如果正在运行的程序，因I/O而暂停执行时，系统可调度另一个程序，使得CPU与设备同时处于忙碌状态，从而提高了系统资源利用率。</p>
</li>
<li><p>多道批处理系统的特征</p>
<p>（1）多道性：内存中同时存放几个作业，并发执行； </p>
<p>（2）调度性：当前运行的作业需作I/O处理时，CPU转而执行另一个作业。 </p>
<p>（3）无序性：由于作业调度，各作业可交替使用CPU，造成程序走走停停，没有确定的执行顺序。</p>
</li>
<li><p>周转时间： 指作业从提交到完成所用的时间 </p>
</li>
<li><p>多道批处理系统的优缺点</p>
<p>(1) 资源利用率高</p>
<p>(2) 系统吞吐量大 </p>
<p>(3) 平均周转时间长 </p>
<p>(4) 无交互能力</p>
</li>
<li><p>多道批处理系统需要解决的问题</p>
<p>一个系统的优点，一定伴随着代价。 多道批处理系统拥有好的性能，但软件的复杂度较高，需要解决以下问题：</p>
<p>(1) 处理机并发问题。 (2) 内存分配问题。 (3) I/O设备管理问题。 (4) 文件管理问题。 (5) 作业管理问题。</p>
</li>
</ol>
<h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><ol>
<li><p>分时系统的产生</p>
<p>多道批处理系统提高了资源利用率和系统吞吐量， 但无交互能力； 分时系统产生的主要动力：用户的需求。</p>
</li>
<li><p>分时系统：指在一台主机上连接了多个带有显示器和键盘的终端，同时，允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p>
</li>
<li><p>关键问题</p>
<p>（1）及时接受</p>
<p>（2）及时处理</p>
</li>
<li><p>关键技术</p>
<p>（1）多路卡</p>
<p>（2）时间片轮转技术</p>
</li>
<li><p>配置多路卡</p>
<p>当用户在自己的终端上键入命令时，系统利 用多路卡（可连接多个用户），能够及时接收各用户从终端输入的数据。</p>
</li>
<li><p>分时系统的特征</p>
<p>(1)多路性。 (2)独立性。 (3)及时性。 (4)交互性。</p>
</li>
<li><p>分时系统的技术指标</p>
<p>响应时间：从用户向系统发出请求，到系统响应为止的时间</p>
</li>
</ol>
<h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><ol>
<li><p>实时系统是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该 事件的处理，并控制所有实时任务协调一致地运行。</p>
</li>
<li><p>应用需求</p>
<p>(1) 实时控制，如：卫星发射，称为硬实时任务。 </p>
<p>(2) 实时信息处理，如：售票系统，称为软实时任务。</p>
</li>
<li><p>按任务执行时是否呈现周期性来划分</p>
<p>(1) 周期性实时任务，指任务在固定的周期内执行。 (2) 非周期性实时任务，指任务在截止时间内执行。 </p>
</li>
<li><p>实时系统的技术指标</p>
<p>为保证系统可靠性，其技术指标为：截止时间。 ① 开始截止时间：任务在某时间以前必须开始执行； ② 完成截止时间：任务在某时间以前必须完成。</p>
</li>
<li><p>实时系统与分时系统的比较</p>
<p>(1) 多路性 (2) 独立性 (3) 及时性 (4) 交互性 (5) <strong><em>可靠性</em></strong></p>
</li>
</ol>
<h2 id="微机操作系统的发展"><a href="#微机操作系统的发展" class="headerlink" title="微机操作系统的发展"></a>微机操作系统的发展</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>多道批处理系统：系统内可同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。 工作原理：用户所提交的作业先存放在外存上，排成一个“后备队列”，有调度程序按一定的算法，从后备队列选择若干个作业调入内存，共享系统各种资源。 技术指标：周转时间（指作业从提交到完成所用的时间）优缺点：（1）资源利用率高；（2）系统吞吐量大；（3）平均周转时间长；（4）无交互能力。 </li>
<li>分时系统：分时系统与多道批处理系统之间有着截然不同的性能差别，它能很好地将一台计算机提供给多个用户同时使用，提高计算机的利用率。分时系统是指，在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。 特征： （1）多路性：允许在一台主机上同时联接多台联机终端，系统按分时原则为每个用户服务。 （2）独立性：每个用户各占一个终端，彼此独立操作，互不干扰。 （3）及时性：用户的请求能在很短的时间获得响应。 （4）交互性：用户可通过终端与系统进行广泛的人机对话。 </li>
<li>实时系统：所谓“实时”，是表示“及时”，而实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。其应用需求主要在实时控制和实时信息处理。 优缺点：（1）同时性独立性；（2）及时性；（3）交互性；（4）可靠性。</li>
</ul>
<h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><ul>
<li>并发</li>
<li>共享</li>
<li>虚拟性</li>
<li>异步性</li>
</ul>
<ol>
<li><p>并发：指在单处理机系统中，两个或多个事件在<font color='red'>同一时间间隔内</font>发生。 （宏观上有多个程序在同时运行，微观上每一时刻仅能有一 道程序执行，这些程序只能是交替执行。）</p>
</li>
<li><p> 并行：在多处理器环境下，两个或多个事件在在<font color='red'>同一时刻发生</font>。</p>
</li>
<li><p>共享：是指系统中的资源可供多个并发执行的进程共同 使用。 由于资源属性的不同，进程对资源共享的方式也不同，目前主要有以下两种资源共享方式：</p>
<p>互斥共享方式：如打印机、缓冲区； 同时访问方式：如内存、磁盘等。</p>
</li>
<li><p>虚拟性</p>
<ul>
<li><p>虚拟，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。 </p>
<p>（1）如虚拟打印机。采用时分复用技术，将物理实体变成若干逻辑对应物 ； </p>
<p>（2）如虚拟存储器。采用空分复用技术实现将小的内存变成大的虚拟内存。</p>
</li>
</ul>
</li>
<li><p>异步性</p>
<p>也称不确定性。因为进程的并发执行，在调度过程中，进程的执行顺序、完成时间都不确定，进程走走停停，按不可预知的速度向前推进，称为异步性。</p>
</li>
</ol>
<h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><h3 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h3><p>完成处理机资源的分配调度等。</p>
<ul>
<li> 进程控制：创建、撤销、挂起、改变运行优先级等；</li>
<li> 进程同步：协调并发进程之间的推进步骤，以协调资源共享；</li>
<li> 进程通信：进程之间传送数据，以协调进程间的协作； </li>
<li> 进程调度：作业和进程的运行切换，以充分利用处理机资源和提高系统性能。</li>
</ul>
<h3 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h3><p>管理目标：提高内存利用率、提供足够的存储空间、方便进程并发运行。 </p>
<ul>
<li>存储分配与回收； </li>
<li> 存储保护：保证进程间互不干扰、相互保密； </li>
<li> 地址变换：进程逻辑地址到内存物理地址的映射； </li>
<li> 虚拟存储器：提高内存利用率、扩大进程的内存空间。</li>
</ul>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>设备管理的目标是：方便的设备使用、提高CPU与I/O设备利用率； </p>
<ul>
<li>设备操作：利用设备驱动程序完成对设备的操作；</li>
<li>缓冲区管理：匹配CPU和外设的速度，提高两者的利用率； </li>
<li>设备独立性：提供统一的I/O设备接口，使应用程序独立于物理设备；</li>
<li>虚拟设备：通过<code>SPLOOLING</code>技术使1个独占设备变成多个共享设备。</li>
</ul>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul>
<li>解决软件资源的存储、共享、保密和保护。</li>
<li>文件存储空间管理：解决如何存放信息，以提高空间利用率和读写性能；</li>
<li>目录管理：解决信息检索问题； </li>
<li>文件的读写管理和存取控制。</li>
</ul>
<h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><p>目标：提供一个友好的、用户访问操作系统的接口。 </p>
<ul>
<li> 命令接口：利用命令等，供用户控制自己的作业运行。 </li>
<li> 程序接口：提供库函数、系统调用，供用户调用操作系统功能。</li>
</ul>
<h1 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h1><h2 id="整体或无结构"><a href="#整体或无结构" class="headerlink" title="整体或无结构"></a>整体或无结构</h2><p>在最早期开发操作系统时，规模很小，只有几十K字节，较容易实现。设计者的精力主要放在功能的高效实现上，这种结构思想来源于服务功能观点，忽略了软件工程的设计思想。那 时的操作系统是一组过程的集合，过程之间相互调用，是无结构的，也叫整体结构。</p>
<p>缺点： 因为缺乏清晰的程序结构，所以错误多，调试难，阅读理解难，增加了维护的难度。</p>
<h2 id="模块化结构"><a href="#模块化结构" class="headerlink" title="模块化结构"></a>模块化结构</h2><ul>
<li><p>随着新技术的不断发展，OS的功能越来越强，现代OS的代码量已超过几十万行，需要数百人参与，分工合作，共同 设计。 为克服结构不清晰的缺点，提出模块化结构。</p>
</li>
<li><p>操作系统不再由众多的过程直接组成，而是分成若干个具有一定独立性和大小的模块，如：进程管理模块、内存管理模块、设备管理模块、 文件管理模块等。</p>
</li>
<li><p>优点： </p>
<p>（1）模块的开发齐头并进，提高了开发效率，加速了OS的开发过程。 </p>
<p>（2）提高了OS的可理解性,可维护性。</p>
</li>
<li><p>缺点： 当模块数目增加时，每个模块的规模将减小，开发单个模块需要的成本减少了；但是，随着模块数目增加，设计模块间接口所需要的工作量也将增加。 </p>
<p>（1）系统设计时，模块划分和接口定义不够精确，很难满足实际需求。 </p>
<p>（2）各模块设计齐头并进，很难做到“每一步都建立在可靠的基础上”， 造成模块间依赖关系复杂。</p>
</li>
</ul>
<h2 id="分层式结构"><a href="#分层式结构" class="headerlink" title="分层式结构"></a>分层式结构</h2><ul>
<li>所谓有序分层，是指每一步设计都是建立在可靠的基础上。可以从物理机器A1开始，添加一层具有一 定功能的软件A2，在精心设计及测试后，可以 认为A2是正确的；以此类推，如此，一层一层自底向上增添软件层，每一层实现若干功能， 最后，构成一个能够满足要求的操作系统。</li>
</ul>
<h2 id="操作系统设计的分层原则"><a href="#操作系统设计的分层原则" class="headerlink" title="操作系统设计的分层原则"></a>操作系统设计的分层原则</h2><p>​    被调用功能在低层。 </p>
<p>​    与机器特点紧密相关的软件放在最低层。如：如缓冲区队列、堆栈操作、 时钟管理等 </p>
<p>​    存储器管理放在次低层。如：利用虚拟存储功能。 </p>
<p>​    资源分配策略放在最外层，如信息管理等，便于修改或适应不同环境。</p>
<p>优点： 功能明确，调用关系清晰（高层对低层单向依赖）， 有利于保证设计和实现的正确性。 低层和高层可分别实现（便于扩充）；高层错误不会 影响到低层；避免递归调用。</p>
<p> 缺点：在每执行一个功能，通常要自上而下地穿越多个层次， 降低了运行效率。</p>
<h2 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h2><ul>
<li>微内核OS结构是建立在模块化、分层式的基础上， 采用了客户/服务器技术、面向对象技术的现代操作系统结构。 </li>
<li>在单处理器下，微内核OS结构通常分为两大部分: </li>
<li>微内核 + 多个服务器</li>
<li>最基本的核心功能放在内核， 微内核是指精心设计的、能实现现代OS核心功能的小型内核，如线程通信、中断处理等；它运行于核心态，常驻内存。 绝大部分功能放在微内核外面的一组服务器中实现，如进程服务器、存储服务器、设备服务器等。服务器工作在用户态。</li>
<li>微内核OS结构采用了面向对象技术。利用抽象、 封装、继承、多态等技术，将计算机中的实体作为对 象来处理，将数据和操作封装在稳定的对象中，具有可修改性，可扩充性的特点。</li>
<li>优点：  可扩充性：只需添加支持新功能的服务进程即可； 可靠性好：调用关系明确，执行转移不易混乱； 可移植性：操作系统的服务器均与硬件无关；  便于网络服务，实现分布式处理。 </li>
<li>缺点：  消息传递比直接调用效率要低一些。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>模块化结构： 优点：（1）模块的开发齐头并进，提高了开发效率，加速了OS的开发过程。（2）提高了OS的可理解性,可维护性。 缺点：当模块数目增加时，每个模块的规模将减小，需要的成本减少了，但是随着模块数目增加，设计模块间接口所需要的工作量也将增加。 分层式结构： 优点：（1）功能明确，调试关系清晰 （高对低单向依赖），有利于保证设计和实现的正确性。（2）便于扩充，高层错误不会影响低层，避免递归调用。 缺点：降低了运行效率。 微内核结构： 优点：可扩充性，可靠性好，可移植性，便于网络服务，实现分布或处理。 缺点：<font color='red'>消息传递比直接调用效率要低一些</font>。</p>
<h1 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h1><h3 id="程序的顺序执行及其特征"><a href="#程序的顺序执行及其特征" class="headerlink" title="程序的顺序执行及其特征"></a>程序的顺序执行及其特征</h3><ol>
<li>在未配置OS的系统中，程序是顺序执行的。 通常把应用程序分成若干程序段，在各程序段之间，按照某种先后顺序执行。</li>
<li>程序顺序执行时的特征<ul>
<li>程序执行的顺序性。</li>
<li>程序环境的封闭性。 </li>
<li>程序结果的可再现性。</li>
</ul>
</li>
</ol>
<h3 id="程序的并发执行及其特征"><a href="#程序的并发执行及其特征" class="headerlink" title="程序的并发执行及其特征"></a>程序的并发执行及其特征</h3><ol>
<li><p>程序的并发执行</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218191446043.png" alt="image-20201218191446043"></p>
</li>
<li><p>程序并发执行的例子</p>
<p>例如，有两个循环程序A和B，它们共享一个变量N。 </p>
<ul>
<li>程序A每执行一次时，都要做N∶=N+1操作；</li>
<li>程序B每执行一次时，都要执行Print(N)操作，然后再将N 置成“0”。 </li>
<li>程序A和B以不同的速度运行。</li>
</ul>
</li>
<li><p>程序的并发执行结果</p>
<p>在第1讲中多个买票线程的并发执行实验，出现异步性的执行结果。 如果语句的执行顺序不同，可能出现不同的执行结果。</p>
<p> (1) N∶=N+1在Print(N)和N∶=0之前，N的值分别为n+1, n+1, 0。</p>
<p> (2) N∶=N+1在Print(N)和N∶=0之后，N的值分别为n, 0, 1。</p>
<p> (3) N∶=N+1在Print(N)和N∶=0之间，N的值分别为n, n+1, 0。</p>
</li>
<li><p>程序并发执行时的特征</p>
<p>（1）间断性。多个程序的相互制约，在并发执行时，具有“执行—暂停—执行” 的间断性 。</p>
<p>（2）失去封闭性。多个程序共享系统资源，其它程序可以改变一个程序环境中资源的状态，失去了封闭性 。</p>
<p>（3）不可再现性。由于失去封闭性，导致并发执行的程序出现不可再现性。</p>
</li>
</ol>
<h3 id="进程的特征与状态"><a href="#进程的特征与状态" class="headerlink" title="进程的特征与状态"></a>进程的特征与状态</h3><ol>
<li><p>为什么引入进程</p>
<p>在多道程序系统中，<font color='red'>程序的并发执行失去封闭性，具有不可再现性的特征</font>，这样，程序的并发执行已失去了意义。 </p>
<p>并发性是OS的基本特征，是提高系统呑吐量、资源利用率的条件，故引入进程的概念。</p>
</li>
<li><p>进程的特征</p>
<p>（1）结构特征 </p>
<p>​    进程=程序段+数据段+进程控制块PCB ， PCB相当于列车时刻表，是一个大的记录型数据结构，以保留进程现场和进程控制信息。</p>
<p>（2）动态性 </p>
<p>​    进程是程序的一次执行过程，由创建而产生，因调度而执行， 因阻塞而暂停，因撤消而消亡。</p>
<p>（3）并发性 </p>
<p>​    由于PCB记录着进程所有的信息，OS可以根据PCB对并发执行的进程进行控制和调度，故多个进程可以在一段时间内同时运行。</p>
<p>（4）独立性 </p>
<p>​    <font color='red'>进程是独立的调度单位，资源分配单位</font>。</p>
<p>（5）异步性</p>
<p>​    进程按各自独立的，不可预知的速度向前推进。</p>
</li>
<li><p>进程的定义</p>
<p>(1) 进程是程序的一次执行。</p>
<p>(2) 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p>
<p>(3) 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>
</li>
<li><p>进程的三种基本状态</p>
<p>（1）就绪状态 （2）执行状态 （3）阻塞状态</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218192515883.png" alt="image-20201218192515883"></p>
</li>
</ol>
<h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><ol>
<li><p>进程控制块中的作用</p>
<p>PCB是重要的数据结构，位于系统区，存放OS所需的，用于描述进程标识、控制信息、调度信息等所需的全部信息。</p>
<p>PCB是进程存在的唯一标志，系统根据<font color='red'>PCB而感知相应进程的存在</font>，OS是根据PCB来对并发执行的进程进行控制和管理的。</p>
</li>
<li><p>进程控制块中的信息</p>
<ol>
<li><p>进程标识符 ：①内部标识符。 ②外部标识符。</p>
</li>
<li><p>处理机状态 ： ① 通用寄存器，② 指令计数器，③ 程序状态字PSW，④ 用户栈指针 </p>
</li>
<li><p>进程调度信息包括： ① 进程状态，② 进程优先级，③ 进程调度所需的其它信息，④ 事件。 </p>
</li>
<li><p>进程控制信息包括：① 程序和数据的地址， ② 进程同步和通信机制，③ 资源清单，④ 链接指针。</p>
</li>
</ol>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218192856989.png" alt="image-20201218192856989"></p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218192912836.png" alt="image-20201218192912836"></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>1.程序是静态的，进程是动态的，进程是程序的一次执行。 2.进程是短暂的，当进程完成它的使命后，就会被撤销掉，而程序是一直都存在的。 3.进程是可并发的。 一个进程可以执行一个或多个程序，一个程序也可能由一个或多个进程组成</p>
</li>
</ol>
<h1 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a>进程图</h1><p>进程之间的关系有三种含义：</p>
<ol>
<li>子进程可继承父进程所拥有的资源</li>
<li>子进程撤销时应将其从父进程获得的资源归还给父进程</li>
<li>父进程撤销时必须同时撤下其所有子进程</li>
</ol>
<h1 id="引起进程创建的事件"><a href="#引起进程创建的事件" class="headerlink" title="引起进程创建的事件"></a>引起进程创建的事件</h1><ol>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ol>
<h1 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h1><p>（Create原语按照下列步骤创建一个新进程）</p>
<ol>
<li>申请空白PCB。</li>
<li>为新进程分配资源。</li>
<li>初始化PCB。</li>
<li>将新进程插入就绪队列。</li>
</ol>
<p>调用者（或者父进程）提供一组参数，在新建PCB中，会存放进程的调度信息等。</p>
<h1 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a>引起进程终止的事件</h1><ol>
<li><p>正常结束</p>
</li>
<li><p>异常结束</p>
<p>在进程运行期间，由于出现某些错误和故障而迫使进程终止。</p>
<p>如：越界错误，非法指令等。</p>
</li>
<li><p>外界干预</p>
<p>外界干预使进程应外界请求而终止进程运行。</p>
<p>如：操作系统干预，父进程请求。</p>
</li>
</ol>
<h1 id="进程终止过程（进程终止原语）"><a href="#进程终止过程（进程终止原语）" class="headerlink" title="进程终止过程（进程终止原语）"></a>进程终止过程（进程终止原语）</h1><ol>
<li>根据被终止的进程标识符，从PCB集合中检索出该进程的PCB，从中读取该进程的状态。</li>
<li>若其终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志位真，用于指示该进程被终止后，应重新进行调度。</li>
<li>若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防成为不可控进程。</li>
<li>将被终止的进程所拥有的全部资源，或者归还其父进程，或者归还给系统。</li>
<li>将被终止进程的PCB，从所在队列（或者链表）中移出。</li>
</ol>
<h1 id="引起进程阻塞和唤醒的事件"><a href="#引起进程阻塞和唤醒的事件" class="headerlink" title="引起进程阻塞和唤醒的事件"></a>引起进程阻塞和唤醒的事件</h1><ol>
<li>请求系统服务</li>
<li>启动某种IO操作</li>
<li>新数据尚未到达</li>
<li>无新工作可做</li>
</ol>
<h1 id="进程阻塞的过程（block的原语）"><a href="#进程阻塞的过程（block的原语）" class="headerlink" title="进程阻塞的过程（block的原语）"></a>进程阻塞的过程（block的原语）</h1><p>​    进程阻塞是进程自身的一种主动行为</p>
<ol>
<li>进入block过程后，将现行状态由‘执行’改为阻塞，并将PCB插入阻塞队列</li>
<li>调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换。</li>
<li>保留被阻塞进程的处理机状态，在按照新进程的PCB中的处理机状态设置CPU的环境</li>
</ol>
<h1 id="进程唤醒过程（wakeup的原语）"><a href="#进程唤醒过程（wakeup的原语）" class="headerlink" title="进程唤醒过程（wakeup的原语）"></a>进程唤醒过程（wakeup的原语）</h1><p>​    调用唤醒原语wakeup（）的过程是：</p>
<pre><code> 1. 首先把被阻塞的进程从等待该事件的阻塞队列移出。
 2. 将其PCB中的现行状态由阻塞改为就绪。
 3. 然后再将该PCB插入到就绪队列中。</code></pre>
<h1 id="进程挂起原因"><a href="#进程挂起原因" class="headerlink" title="进程挂起原因"></a>进程挂起原因</h1><ol>
<li>终端用户的请求。</li>
<li>父进程的请求。</li>
<li>负荷调节的需要。</li>
<li>操作系统的需要。</li>
</ol>
<h1 id="挂起原语的执行过程"><a href="#挂起原语的执行过程" class="headerlink" title="挂起原语的执行过程"></a>挂起原语的执行过程</h1><p>首先检查被挂起进程的状态，</p>
<p>​         若处于活动就绪状态，便改为静止就绪态</p>
<p>​         若处于活动阻塞状态，便改为静止阻塞态</p>
<h1 id="进程的激活过程（激活原语active）"><a href="#进程的激活过程（激活原语active）" class="headerlink" title="进程的激活过程（激活原语active）"></a>进程的激活过程（激活原语active）</h1><p>​    激活原语先将进程从外存调入内存，检查该进程的现行状态：</p>
<p>​                 若处于静止就绪态，便改为活动就绪状态</p>
<p>​                 若处于静止阻塞态，便改为活动阻塞状态</p>
<ol>
<li>就绪→执行：处于就绪状态的进程，当进程调度程序为之**<em>分配了处理机**</em>后就转变成执行状态。 </li>
<li>执行→就绪：处于执行状态的进程因分配给它的时间片用完而不得不让处理机就会转变成就绪状态。 </li>
<li>执行→阻塞：正在执行的进程因等待某种事件发生而无法继续执行时便从执行状态变成阻塞状态。 </li>
<li>阻塞→就绪：处于阻塞状态的进程，若**<em>其等待的事件已经发生**</em>，于是进程由阻塞状态转变为就绪状态。 </li>
<li>活动就绪→静止就绪：活动就绪执行挂起静止就绪 。 </li>
<li>活动阻塞→静止阻塞： 活动阻塞挂起静止阻塞，静止阻塞激活活动就绪 。 </li>
<li>静止就绪→活动就绪： 静止就绪激活活动就绪。 </li>
<li>静止阻塞→活动阻塞：静止阻塞释放静止就绪，静止就绪激活活动就绪，活动就绪执行挂起静止就绪，并且执行请求I/O活动阻塞。</li>
</ol>
<h2 id="进-程-同-步"><a href="#进-程-同-步" class="headerlink" title="进 程 同 步"></a>进 程 同 步</h2><h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3><ol>
<li><p>两种形式的制约关系多道程序环境中,并发进程之间存在资源共享，进程间存在制约关系 </p>
<p>（1）间接相互制约关系，称为进程互斥。 例如：A、B两个进程同时申请一台打印机</p>
<p>（2）直接相互制约关系，称为进程同步。 例如：<strong>输入进程与计算进程之间</strong></p>
</li>
<li><p>临界资源 临界资源是指在一段时间内，只允许一个进程访问的资源。</p>
</li>
<li><p>同步机制应遵循的规则</p>
<p>空闲则入：其他进程均不处于临界区；</p>
<p>忙则等待：已有进程处于其临界区；</p>
<p>有限等待：等待进入临界区的进程不能”死等” ； </p>
<p>让权等待：不能进入临界区的进程，应释放CPU。</p>
</li>
</ol>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ol>
<li><p>整型信号量 </p>
<p>最初由Dijkstra把整型信号量定义为一个整型量，除初始化外，仅 能通过两个标准的原子操作wait(S)和signal(S)来访问。这两个操作一 直被分别称为P、V操作。</p>
<p>利用整形信号量机制，解决进程互斥的传统设计步骤：</p>
<p>（1）找到临界资源，画出临界区。 </p>
<p>（2）为每个临界资源设置一个信号量mutex，初值为1。 </p>
<p>（3）在临界区前加上wait（mutex），作为进入区； </p>
<p>（4）在临界区后加上signal（mutex），作为退出区； </p>
<p> Wait和signal成对出现在同一个进程中。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218193708459.png" alt="image-20201218193708459"></p>
</li>
<li><p>记录型信号量 </p>
<p>记录型信号量定义为一个记录型结构，它所包含的上述两个数据项可描述为：</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218193737786.png" alt="image-20201218193737786"></p>
<p>当S.value＜0时，表示该类资源已分配完毕，此时S.value的绝对值表示在该信号量链表中已阻塞进程的数目。 如果S.value的初值为1，表示只允许一个进程访问临界资源， 此时的信号量转化为互斥信号量。</p>
</li>
<li><p>AND型信号量 </p>
<p>AND同步机制的基本思想是： </p>
<p>(1)将进程在整个运行过程中需要的所有资源， 一次性全部地分配给进程，待进程使用完后再一起释放。 </p>
<p>(2)要么全部分配到进程，要么一个也不分配。</p>
<p>swait原语的实现</p>
<p>只有进程所需的资源， 全都满足时，执行 Si∶=Si-1操作； 只要发现有第Si个资源不满足，将进程阻塞在第Si的队列中。</p>
<p>ssignal原语的实现</p>
<p>针对所有的资源，执行 Si∶=Si+1操作； 将Si队列中的阻塞进程移出，进入就绪队列。</p>
</li>
<li><p>信号量集</p>
<ul>
<li><p>基本思想：</p>
<p>（1）前面讲的信号量操作，每次施以加1、减1操作，当进程一次需 要N个某类资源时，便要执行N次wait（S）操作，显然是低效的。 </p>
<p>（2）有些情况下，当资源低于某个下限值时，便不予以分配。 基于以上两点，信号量集机制对AND信号量加以扩充，在每次分配前，都必须测试资源的数量，看其是否大于其下限值，并可按要求 一次性分配多个资源。</p>
</li>
<li><p>信号量机制的描述</p>
<p>一般化的信号量集机制描述： S为信号量，d为需求值，t为下限值。 </p>
<p>（1）如果Si &gt;= ti，可分配；反之，表示资源数量低于ti时，便不予分配。 </p>
<p>（2）每次分配值为di，用于信号量的增减， 即Si = Si - di和Si = Si + di</p>
</li>
<li><p>swait原语的实现</p>
<p>只有进程所需的资源，全都满足Si≥ti时， 执行Si∶=Si-di操作； 只要发现有第Si个资源不满足，将进程阻塞在第Si的队列中。</p>
</li>
<li><p>ssignal原语的实现</p>
<p>针对所有的资源，执行 Si∶=Si+di操作； 将Si队列中的阻塞进程移 出，进入就绪队列。</p>
</li>
<li><p>一般信号量集的几种特殊情况</p>
<p>(1) Swait(S, d, d)。 此时在信号量集中只有 一个信号量S， 但允许它每次申请d个资源，当现 有资源数少于d时，不予分配。</p>
<p>(2) Swait(S, 1, 1)。 此时的信号量集已蜕 化为一般的记录型信号量(S＞1时)或互斥信号量 (S=1时)。</p>
<p>(3) Swait(S, 1, 0)。这是一种很特殊且很用的 信号量操作。当S≥1时，允许多个进程进入某特定 区；当S变为0后，将阻止任何进程进入特定区。 换言之，它相当于一个可控开关。</p>
</li>
</ul>
</li>
</ol>
<h1 id="进程的前趋关系及同步机制"><a href="#进程的前趋关系及同步机制" class="headerlink" title="进程的前趋关系及同步机制"></a>进程的前趋关系及同步机制</h1><h2 id="进程之间的前趋关系"><a href="#进程之间的前趋关系" class="headerlink" title="进程之间的前趋关系"></a>进程之间的前趋关系</h2><p>在多道程序环境下，进程之间存在两种制约关系： （1）间接相互制约关系，称为进程互斥。 （2）直接相互制约关系，称为进程同步。例如：输入进程与计算进程之间， 计算进程与输出进程之间，存在着前趋关系。 进程之间的直接相互制约关系，通常用前趋图表示。</p>
<h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><h1 id="多线程OS中的进程有以下属性"><a href="#多线程OS中的进程有以下属性" class="headerlink" title="多线程OS中的进程有以下属性"></a>多线程OS中的进程有以下属性</h1><ol>
<li><p>作为系统资源分配的单位。</p>
</li>
<li><p>可包括多个线程。</p>
</li>
<li><p>进程不是一个可执行的实体。</p>
<p>在多线程OS中，进程是作为**<em>拥有操作系统资源**</em>的基本单位，通常的进程都包括多个线程并为他们提供资源，此时的进程就<font color='red'>不再作为一个执行的实体</font>。</p>
<p>所谓进程处于执行状态，实际上是该进程中的线程正在执行。</p>
</li>
</ol>
<h1 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h1><p>系统在内核空间还为每一个内核支持线程设置了一个线程控制块，内核是根据**<em>该控制块而感知某线程的存在的**</em>，对其加以控制。    </p>
<ol>
<li><p>内核维护线程的切换；</p>
</li>
<li><p>一个线程发起系统调用而阻塞，不会影响其他线程的运行，CPU会调度其他线程运行。内核线程只拥有很少的资源，相对于进程，<font color='red'>其切换开销小。但相对于用户级线程，系统开销大。</font></p>
</li>
</ol>
<h1 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h1><p>用户级线程仅存在于用户空间中。对于这种线程的创建，撤销，线程之间的同步与通信等功能，都无需利用系统调用来实现。</p>
<ol>
<li>内核不了解用户线程的存在；</li>
<li>用户线程的维护由应用进程完成；</li>
<li>用户线程切换不需要内核特权。</li>
</ol>
<p>如： 进程A包括1个用户级线程，进程B包括100个用户级线程，由于内核不了解用户级线程的存在，为进程A和进程B分配相同的资源，A中线程的运行速度将是B的100倍。</p>
<ol>
<li>线程是*<strong>调度和分派**<em>的基本单位，进程是</em></strong>拥有资源***的基本单位。 </li>
<li>不同进程可并发，一个进程中的线程之间也可以并发执行。 </li>
<li>线程仅拥有少量资源，还可以访问其隶属进程的资源。 </li>
<li>在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。 </li>
<li>进程创建、撤消、切换的开销远远大于线程切换的开销。 </li>
<li>单线程进程，只能运行在一个处理机上。多线程进程，就可以将一个进程中的多个线程分配到多个处理机上。</li>
<li>联系： <ol>
<li>线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源； </li>
<li>线程是进程中执行运算的最小单位； </li>
<li>进程和线程都是由操作系统所体会的程序运行的基本单元。</li>
</ol>
</li>
</ol>
<p>简单来说，*<strong>处理机指的是硬件**<em>，它包含在内，而</em></strong>内核是操作系统中的概念*<strong>，是操作系统的核心，是属于**<em>软件部分。</em></strong></p>
<ol>
<li>处理机包括中央处理器，主存储器，输入-输出接口，加接外围设备就构成完整的计算机系统。处理机是处理计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。程序是描述处理机完成某项任务的指令序列。指令则是处理机能直接解释、执行的信息单位。</li>
<li>中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。</li>
<li>内核是操作系统最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并且内核决定一个程序在什么时候对某部分硬件操作多长时间。内核，是一个操作系统的核心。是基于硬件的第一层软件扩充，提供操作系统的最基本的功能，是操作系统工作的基础，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。</li>
</ol>
<h1 id="处理机调度的基本概念"><a href="#处理机调度的基本概念" class="headerlink" title="处理机调度的基本概念"></a>处理机调度的基本概念</h1><h2 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h2><h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><ul>
<li>调度对象：作业</li>
<li>主要功能：决定将外存上的那些作业调入内存。<ul>
<li>在每次执行作业调度时，都必须做以下决定：<ul>
<li>接纳多少条作业</li>
<li>接纳那些作业</li>
</ul>
</li>
</ul>
</li>
<li><strong><em>只用于批处理系统</em></strong>。</li>
<li>作业调度运行频率低，几分钟一次。</li>
</ul>
<h3 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h3><ul>
<li>调度对象：进程。</li>
<li>主要功能：决定就绪队列中的那个进程获得处理机。</li>
<li>是最基本的调度。</li>
<li>进程调度运行频率高，几十毫秒一次，算法不能太复杂。</li>
</ul>
<h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><ul>
<li>内外存信息对换<ul>
<li>内存–&gt;外存（挂起状态）</li>
<li>外存–&gt;内存（内存有空间，进程又具备运行条件）</li>
</ul>
</li>
<li>目的：便于内存管理扩充；提高内存利用率和系统吞吐量。</li>
<li>中级调度的运行频率介于高级、低级调度之间。</li>
</ul>
<h2 id="调度队列模型"><a href="#调度队列模型" class="headerlink" title="调度队列模型"></a>调度队列模型</h2><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B.png" alt="调度队列模型" title="调度队列模型"></p>
<p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B2.png" alt="调度队列模型" title="调度队列模型"></p>
<p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%973.png" alt="调度队列模型" title="调度队列模型"></p>
<h2 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h2><ol>
<li><p>处理机调度算法的共同目标</p>
<ol>
<li><p>资源利用率。</p>
<p>CPU资源利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)</p>
</li>
<li><p>公平性。</p>
</li>
<li><p>平衡性。</p>
</li>
<li><p>策略强制执行。</p>
</li>
</ol>
</li>
<li><p>批处理系统的目标</p>
<ol>
<li>平均周转时间短。<ul>
<li> 周转时间是指从作业被提交系统（外存）开始，到作业完成为止的这段时间间隔。</li>
</ul>
</li>
<li>系统吞吐量高。<ol>
<li>吞吐量是指在单位时间内系统完成的作业数。</li>
</ol>
</li>
<li>处理机利用率高。</li>
</ol>
</li>
<li><p>周转时间包括四个部分：</p>
<ol>
<li><p>等待作业调度时间</p>
</li>
<li><p>等待进程调度时间</p>
</li>
<li><p>进程在CPU上执行的时间</p>
</li>
<li><p>进程等待IO操作完成的时间（有阻塞）</p>
<p>平均周转时间：从作业被提交系统（外存）开始，到作业完成为止的这段时间间隔除以作业个数。</p>
<p>带权周转时间：周转时间除以服务时间。</p>
<p>平均带权周转时间：带权周转时间除以作业个数。</p>
</li>
</ol>
</li>
<li><p>分时系统的目标</p>
<ol>
<li>响应时间快。<ul>
<li><font color='red'>响应时间</font>是从用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间。</li>
</ul>
</li>
<li>均衡性。<ul>
<li><font color='red'>均衡性</font>是指系统响应时间的快慢应与用户所请求服务的复杂性相适应。</li>
</ul>
</li>
</ol>
</li>
<li><p>实时系统的目标。</p>
<ol>
<li>截止时间的保证。<ul>
<li>截止时间是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。</li>
</ul>
</li>
<li>可预测性。</li>
</ol>
</li>
</ol>
<h1 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h1><h2 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h2><p>适用于作业调度</p>
<ul>
<li>从后备作业队列中选中**<em>一个或者多个最先进入**</em>的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。</li>
</ul>
<p>适用于进程调度</p>
<ul>
<li>从就绪进程队列中选中**<em>一个最先进入**</em>的进程，为之分配处理机，使之投入运行；直到运行完成或者阻塞，才会让出处理机。</li>
</ul>
<h2 id="短作业-进程优先算法"><a href="#短作业-进程优先算法" class="headerlink" title="短作业/进程优先算法"></a>短作业/进程优先算法</h2><p>短作业优先（SJF）</p>
<ul>
<li>从后备队列中选择一个或者多个**<em>估计**</em>运行时间最短的作业调入内存。（运行时间的估计不一定准确）</li>
</ul>
<p>短进程优先（SPF）</p>
<ul>
<li>从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行。</li>
</ul>
<h2 id="优先级调度算法（数字越小优先权越大）"><a href="#优先级调度算法（数字越小优先权越大）" class="headerlink" title="优先级调度算法（数字越小优先权越大）"></a>优先级调度算法（数字越小优先权越大）</h2><p>适用于作业调度</p>
<ul>
<li>从后备队列中选择若干个优先权最高的作业装入内存。</li>
</ul>
<p>适用于进程调度</p>
<ul>
<li>根据进程的紧迫程度赋予每个进程一个优先权，选择就绪队列中一个优先权最高的进程投入执行。</li>
</ul>
<ol>
<li>优先级调度算法的类型<ol>
<li>非抢占式优先权调度算法<ul>
<li>把CPU分配给优先权最高的进程后，运行直至完成或发生某事件而阻塞时，才将CPU分配给其他进程。</li>
</ul>
</li>
<li>抢占式优先权调度算法<ul>
<li>在执行期间出现了优先权更高的进程，系统将暂停当前进程，并将CPU分配给新出现的优先权最高的进程。</li>
<li>抢占的原则有：<ul>
<li>优先权原则</li>
<li>短作业（进程优先原则）</li>
<li>时间片原则</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>优先权的类型<ol>
<li>静态优先权<ul>
<li>是在创建进程时确定的，且在进程的整个运行期间保持不变。</li>
</ul>
</li>
<li>动态优先权<ul>
<li>优先权可以随进程的推进或等待时间的增加而改变。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h2><p>思想:优先级随着等待时间的增加而提高。<br>优先级的变化规律为:<br>响应比=（等待时间+服务时间）/服务时间<br>优点:照顾短作业(进程) ;考虑到达次序;兼顾长作业(进程)</p>
<h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><p>基本原理.</p>
<ul>
<li>所有就绪进程按<code>FCFS</code>原则进行调度，每次执行一个时间片。当时间片用完而进程未完，则插入就绪队列末尾。</li>
</ul>
<p>特点:简单易行、平均响应时间短，不利于处理紧急任务。</p>
<h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><ol>
<li>调度机制</li>
</ol>
<ul>
<li>设置多个就绪队列，赋予不同的优先级和不同长度的时间片(优先级越高时间片越短)。</li>
<li>每个队列都采用<code>FCFS</code>算法。</li>
<li>按队列优先级调度。</li>
</ul>
<ol start="2">
<li>性能<br>该算法能较好地满足各种类型用户(进程)的需要。</li>
</ol>
<ul>
<li>终端(交互)型作业用户。</li>
<li>短批处理作业用户。</li>
<li>长批处理作业用户。</li>
</ul>
<h1 id="实时调度算法"><a href="#实时调度算法" class="headerlink" title="实时调度算法"></a>实时调度算法</h1><h2 id="实现实时调度算法的基本条件"><a href="#实现实时调度算法的基本条件" class="headerlink" title="实现实时调度算法的基本条件"></a>实现实时调度算法的基本条件</h2><ul>
<li>提供详细的调度信息</li>
<li>系统处理能力强</li>
<li>具有快速切换机制</li>
<li> 采用抢占式调度机制</li>
</ul>
<h2 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h2><ul>
<li>非抢占式轮转调度算法</li>
<li>非抢占式优先调度算法</li>
<li> 基于时钟中断抢占式优先级调度算法</li>
<li>立即抢占的优先级调度算法</li>
</ul>
<h2 id="最早截止时间优先算法"><a href="#最早截止时间优先算法" class="headerlink" title="最早截止时间优先算法"></a>最早截止时间优先算法</h2><ul>
<li>思想:根据任务的开始截止时间来确定任务的优先级，即任务的开始截止时间越早，其优先级越高。</li>
<li>可采用非抢占调度方式，也可采用抢占调度方式。</li>
</ul>
<h2 id="最低松弛度优先算法"><a href="#最低松弛度优先算法" class="headerlink" title="最低松弛度优先算法"></a>最低松弛度优先算法</h2><ul>
<li>思想:根据实时任务的<font color='red'>松弛度来确定任务的优先级</font>。松弛度越低，其优先权越高。<ul>
<li>松弛度=任务必须完成的时间-任务本身的运行时间-当前时间</li>
</ul>
</li>
<li>实现时按松弛度排序的实时任务就绪队列(<strong><em>松弛度为0时立即抢占资源</em></strong>)。</li>
<li>当一任务的最低松弛度为0时，立即抢占CPU。</li>
</ul>
<ol>
<li>多道批处理系统的调度算法：短作业优先、优先权、高响应比优先、多级反馈队列调度算法。</li>
<li>分时系统的调度算法：时间片轮转法。</li>
<li>实时系统调度算法：最早截至时间优先即EDF、最低松弛度优先即LLF算法。</li>
</ol>
<h1 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><p>死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，若无外力作用，它们都将无法再向前推进。</p>
<h2 id="产生死锁的原因和必要条件"><a href="#产生死锁的原因和必要条件" class="headerlink" title="产生死锁的原因和必要条件"></a>产生死锁的原因和必要条件</h2><p>1.产生死锁的原因<br>    (1)竞争资源</p>
<ul>
<li>消耗性资源(如:消息)</li>
<li>不可抢占性资源(如:打印机)</li>
</ul>
<p>​    (2)进程推进顺序不当</p>
<p>2.产生死锁的必要条件</p>
<ul>
<li>互斥条件</li>
<li>请求与保护条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ul>
<h2 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h2><ul>
<li>预防死锁</li>
<li>避免死锁</li>
<li>检测死锁</li>
<li>解除死锁</li>
</ul>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><ul>
<li>通过设置某些限制条件，破坏导致死锁的四个必要条件之一。</li>
<li>“互斥条件”一由资源的性质决定，不可破坏且要保证。</li>
</ul>
<ol>
<li><p>破坏“请求和保持”条件<br>目标:防止“保持时请求、请求时保持”<br>(1)第一种协议</p>
<ul>
<li>方法:在进程开始运行前，一次性分配给它所需的“全部”资源。</li>
<li>优点:简单易实现，安全性高。</li>
<li>缺点:资源浪费;经常发生饥饿现象。</li>
</ul>
<p>(2)第二种协议</p>
<ul>
<li>方法:允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。</li>
<li>优点:资源利用率高，减少了饥饿现象。</li>
</ul>
</li>
<li><p>破坏“不可抢占”条件</p>
<ul>
<li>目标:变不可剥夺为可剥夺</li>
<li>方法:在进程运行中，若新的资源请求得不到满足，必须释放已占有的所有资源，待以后重新申请。</li>
<li>缺点:实现起来比较复杂，代价高。</li>
</ul>
</li>
<li><p>破坏“循环等待”条件</p>
<ul>
<li>目标:避免出现请求环</li>
<li>方法:资源按类型排序，进程按照资源序号递增的次序提出资源申请。(有序资源分配法)</li>
<li>优点:资源利用率高和系统吞吐量大。</li>
<li>缺点:必须按顺序申请，限制新设备的增加和程序员的自主编程。</li>
</ul>
</li>
</ol>
<h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><h2 id="安全状态与不安全状态"><a href="#安全状态与不安全状态" class="headerlink" title="安全状态与不安全状态"></a>安全状态与不安全状态</h2><ul>
<li>安全状态:系统能按某种进程推进顺序，如&lt;P, P….. P.&gt;为每个进程分配所需资源，直到最大需求，使每个进程都可顺利完成。这样的序列&lt;P, P….. P。&gt;称为安全序列。</li>
<li>不安全状态:不存在安全序列。</li>
</ul>
<h2 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h2><ol>
<li><p>Work[0…m]=Available[0.. .m];<br>Finish[0…n]=false;</p>
</li>
<li><p>从进程集合中寻找满足下列条件的进程Pi:<br>①Finish[i]=false;<br>②Need[i,j]≤Work[i,j];<br>若找到，转(3)；否则，转(4)</p>
</li>
<li><p>进程Pi可获取资源，然后执行完毕，并释放资源:<br>Work[j]=Work[i]+Allocation[i,j];<br>Finish[i] =true.<br>转(2)</p>
</li>
<li><p>判断:若对所有Pi， Finish[i]=true</p>
<p>则系统处于安全状态，否则处于不安全状态</p>
</li>
</ol>
<h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><ul>
<li>避免死锁的方法:允许进程动态地提出资源请求，在系统进行资源分配之前，先判断此次资源分配的安全性。</li>
<li>①若资源分配后，系统处于安全状态，则表明此次资源分配可行，实施资源分配;</li>
<li>②若资源分配后，系统处于不安全状态，则表明此次资源分配不可行，进程需等待。</li>
</ul>
<p>2.银行家算法</p>
<ul>
<li>当进程P;做出资源请求时，如Request;[j]= k表示进程P;所需要的资源类型R，的请求数量为k。系统按下述步骤进行检查:</li>
<li>(1) 如果Request i[j]≤Need[i,j] 转到(2);否则，认为出错，因为它所请求的资源数量已超过它所宣布的最大值。</li>
<li>(2)如果Request i[j]≤Available[j]，则转到(3); 否则，表示尚无足够资源，进程须等待。</li>
<li>(3) 系统试探着把资源分配给进程Pi，并按下面公式修改数据结构中的值:<ul>
<li>Available[j] = Available[j] - Request i[j] ;</li>
<li>Allocation[i,j] = Allocation[i,j] + Request i[j];</li>
<li>Need[i,j] = Need[i,j]- Request i[j];</li>
</ul>
</li>
<li>(4) 系统执行安全性算法。检查此次分配后系统是否处于安全状态。<ul>
<li>若安全，正式将资源分配给进程P;</li>
<li>若不安全，将本次试探分配作废，恢复到原先资源分配状态，让进程Pi等待。</li>
</ul>
</li>
</ul>
<h2 id="银行家算法和安全性算法的关系"><a href="#银行家算法和安全性算法的关系" class="headerlink" title="银行家算法和安全性算法的关系"></a>银行家算法和安全性算法的关系</h2><p>银行家算法的基本思想是允许进程动态地申请资源，在资源分配之前，通过相应的算法确定本次资源分配后系统是否安全（不会产生死锁），若是，则进行分配，否则，让进程处于等待状态。银行家算法在避免死锁的方法中，所施加的限制条件较弱，有可能获得令人满意的系统性能。在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可以避免发生死锁。</p>
<h1 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h1><ol>
<li><p>主存储器（简称内存）</p>
<p>作用：保证进程运行时的程序和数据。</p>
</li>
<li><p>寄存器和高速缓存</p>
<p>作用：缓和内存访问速度和CPU指令执行速度不匹配的矛盾。</p>
</li>
<li><p>磁盘缓存</p>
<p>作用：缓和磁盘IO速度和内存的访问速度不匹配的矛盾。</p>
</li>
</ol>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><ul>
<li>几个重要概念:<br>(1)物理地址(绝对地址):计算机内存单元的真实地址。<br>(2)内存空间:物理内存是各程序共享的物质基础，由0~(m-1)个物理地址组成<br>(3)逻辑地址(相对地址):用户的程序地址。<br>(4)逻辑空间:程序地址均从“0”开始。</li>
</ul>
<h2 id="程序的装入方式"><a href="#程序的装入方式" class="headerlink" title="程序的装入方式"></a>程序的装入方式</h2><h3 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h3><p>装入模块被装入内存后，程序中的逻辑地址与实际物理地址完全相同。</p>
<ul>
<li><p>缺点:</p>
<p>只适用于单道系统;要求程序员熟悉内存的使用情况等。</p>
</li>
<li><p>问题:<br>多道程序环境下，逻辑空间中的逻辑地址和内存空间中的物理地址不一致，如何解决?</p>
</li>
<li><p>解决方案:<br>借助于地址映射功能进行转换。对地址部分的调整过程，称为重定位。</p>
</li>
</ul>
<h3 id="可重定位装入方式和动态运行时装入方式"><a href="#可重定位装入方式和动态运行时装入方式" class="headerlink" title="可重定位装入方式和动态运行时装入方式"></a>可重定位装入方式和动态运行时装入方式</h3><ul>
<li><p>重定位的类型</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="left">映射时间</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">静态重定位</td>
<td align="left">装入内存时，地址映射一次完成</td>
<td align="left">(1)运行过程中不可移动位置<br/>(2)内存利用率低</td>
</tr>
<tr>
<td align="center">动态重定位</td>
<td align="left">执行期间，地址映射由“硬件地址变位置换机构”动态完成</td>
<td align="left">(1)运行过程中可移动<br/>(2)需附加硬件支持</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="程序的连接"><a href="#程序的连接" class="headerlink" title="程序的连接"></a>程序的连接</h2><h3 id="静态连接方式"><a href="#静态连接方式" class="headerlink" title="静态连接方式"></a>静态连接方式</h3><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5.png" alt="静态连接" title="静态连接"></p>
<h3 id="装入时动态连接"><a href="#装入时动态连接" class="headerlink" title="装入时动态连接"></a>装入时动态连接</h3><ul>
<li>将几个目标模块装入内存时边装入边链接。</li>
<li>优点:<br>(1)便于修改和更新。<br>(2) 便于实现对目标模块的共享。</li>
</ul>
<h3 id="运行时动态连接"><a href="#运行时动态连接" class="headerlink" title="运行时动态连接"></a>运行时动态连接</h3><ul>
<li>将某些目标模块的链接，推迟到执行时才进行。</li>
<li>优点:<br>(1) 加快程序的装入过程。<br>(2)节省内存空间。</li>
</ul>
<h2 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><ul>
<li>基本思想:<ul>
<li>内存划分为:系统区和用户区</li>
<li>只能用于单用户、单任务的操作系统中</li>
</ul>
</li>
<li>特点:<ul>
<li>方法简单，易于实现</li>
<li>单道程序:内存和CPU利用率低，难于实现共享</li>
</ul>
</li>
</ul>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><ul>
<li><p>基本思想:</p>
<ul>
<li><p>把内存用户空间划分为若干个固定大小的分区;</p>
</li>
<li><p>每个分区中只装入一道作业。</p>
</li>
</ul>
</li>
<li><p>划分分区的方法:</p>
<ul>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ul>
</li>
<li><p>具体实现:</p>
<ul>
<li>将分区按大小排队</li>
<li>建立分区使用表<br>表项包括:  ①分区号        ②分区起始地址<pre><code>               ③分区大小    ④分区状态</code></pre>
</li>
<li>当程序装入时，由内存分配程序检索分区使用表</li>
<li>若找到符合要求的分区，则完成内存分配，并进行标记;</li>
<li>若未找到，则拒绝内存分配。</li>
</ul>
</li>
<li><p>缺点：内碎片问题；限制了并发执行的程序数目。</p>
</li>
</ul>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ul>
<li><p>基本思想:</p>
<p>作业装入时，根据实际需要和内存空间的使用情况进行动态分配。</p>
</li>
<li><p>特点:</p>
<p>分区个数、分区大小不固定。</p>
</li>
<li><p>分区分配中的数据结构:</p>
<ul>
<li>空闲分区表、已分配分区表、空闲分区链</li>
</ul>
</li>
</ul>
<h4 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法:"></a>分区分配算法:</h4><h5 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h5><p>算法思想:空闲分区表或空闲分区链按照分区起址递增的次序排序。顺序查找，若找到第一个大小满足要求的空闲分区，则从中划出一块内存空间分配给作业;若未能找到，则此次内存分配失败。</p>
<h5 id="循环首次适应算法"><a href="#循环首次适应算法" class="headerlink" title="循环首次适应算法"></a>循环首次适应算法</h5><p>算法思想:从上次分配的空闲区位置之后开始查找。若找到一个满足要求的空闲分区，则从中划出一块内存空间分配给作业。若最后一-个<br>空闲分区大小仍不能满足要求，则返回到第一个空闲分区继续查找。</p>
<h5 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h5><p>算法思想:从满足要求的、最小的空闲分区中划出一块空间分配给作业。要求空闲分区表或空闲分区链按照分区容量递增的次序排序，顺<br>序查找第一个满足要求的空闲分区。</p>
<h5 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h5><p>算法思想:从满足要求的、最大的空闲分区中划出一块空间分配给作业。要求空闲分区表或空闲分区链按照分区容量递减的次序排序。<br>优点:查找速度快，分配后剩下的可用空间较大。<br>缺点:一段时间后会缺乏较大空闲区。</p>
<h5 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h5><p>算法思想:将空闲分区按照进程常用的空间大小进行分类。分配时,根据进程长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配。<br>优点:查找效率高<br>缺点:分区归还主存时算法复杂</p>
<h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><ul>
<li><p>分配内存</p>
<p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5.png"></p>
</li>
<li><p>回收内存</p>
<p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%8C%BA%E5%9B%9E%E6%94%B6%E6%83%85%E5%86%B5.png"></p>
</li>
</ul>
<h3 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h3><p>由于经过紧凑后的用户程序在内存中的位置发生了变化，所以必须对发生移动的程序和数据进行重定位。</p>
<p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h3 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h3><ul>
<li>目的:解决内存不足的问题</li>
<li>对换:是指把内存中暂时不能运行的进程或暂时不用的程序和数据调出到外存,以腾出空间把已具备运行条件的进程或程序数据调入内存。</li>
</ul>
<ol>
<li><p>对换(Swapping) 的引入:</p>
<ul>
<li>两种形式:<br>(1)整体对换:以进程为单位的对换，用于分时系统。<br>(2)部分对换:以“页”或“段”为单位的对换，支持虚拟存储系统。</li>
</ul>
</li>
<li><p>对换空间的管理:</p>
<ul>
<li>外存划分:<br>(1) 文件区:存放文件，采用<strong>离散</strong>分配方式，管理目标是*<strong>提高文件存储空间的利用率*<strong>。<br>(2) 对换区:存放从内存换出的进程，采用</strong>连续*<em>分配方式，目标是</em></strong>提高进程换入和换出的速度***。</li>
</ul>
</li>
<li><p>进程的换出与换入:</p>
<ul>
<li>进程的换出:<br>选择处于阻塞状态且优先级最低的进程;启动磁盘，将该进程的程序和数据传送到磁盘的对换区;回收进程内存空间，修改PCB。</li>
<li>进程的换入:<br>系统定时查看所有进程的状态;找出“就绪”状态但已换出的进程;将其中换出时间最久的进程换入内存。</li>
</ul>
</li>
</ol>
<h2 id="离散分配方式概述"><a href="#离散分配方式概述" class="headerlink" title="离散分配方式概述"></a>离散分配方式概述</h2><ul>
<li>基本思想:一个用户程序(进程)直接分散地装入到很多不相邻接的分区中。</li>
<li>两种形式:<br>分页存储管理方式(离散基本单位:页)<br>分段存储管理方式(离散基本单位:段)</li>
</ul>
<h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><h3 id="页面与页表"><a href="#页面与页表" class="headerlink" title="页面与页表"></a>页面与页表</h3><p>1.页面:</p>
<ul>
<li><strong><em>等分</em></strong>内存空间:每等份称为物理块，编号: 0 1 2 3 4 ……</li>
<li><strong><em>等分</em></strong>逻辑空间:划分为与物理块大小相同的页，面，编号为0 1 2 3 4 …..</li>
<li>页面大小: 2n Bytes，大小适中、通常为512B~8KB地址变换机构</li>
</ul>
<p>2.页表:</p>
<ul>
<li>系统为**<em>每个进程**</em>建立一张页表。</li>
<li>作用:实现从页号到物理块号的地址映射。</li>
<li>在页表中，每页均对应一页表项，记录页号、块号的对应关系，及存取控制字段。</li>
</ul>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><ul>
<li>基本任务:<br>实现从逻辑地址到物理地址的映射。</li>
<li>两种形式:<br>1.基本的地址变换机构<br>2.具有快表的地址变换机构</li>
</ul>
<p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%9C%BA%E6%9E%84.png"></p>
<ul>
<li><p>问题:<br>由于页表存放在内存中，CPU每取得一个数据，均需要两次访问内存。<br>第一次:访问页表，形成物理地址;<br>第二次:从物理地址中获得数据</p>
</li>
<li><p>具有快表的地址变换机构:<br>增设一个具有并行查询能力的高速缓冲寄存器<br>快表(联想寄存器)<br>空间大小:几K到几百K， 只含有部分页表项(16^ 512个)</p>
</li>
</ul>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><ul>
<li>问题:<br>每个进程仅页表项就占1MB的连续内存空间</li>
<li>解决思路:<br>将大页表进行分页，每个页面离散的存放在不同物理块中。</li>
<li>为内存中离散分配的页表在建立一张外层页表，每个页表项记录页表分页的物理块号。</li>
</ul>
<h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><ul>
<li>为满足用户和程序员的下述需求：<ul>
<li>方便编程</li>
<li>信息共享</li>
<li>信息保护</li>
<li>动态增长</li>
<li>动态链接</li>
</ul>
</li>
</ul>
<h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3><ol>
<li><p>分段：</p>
<ul>
<li>逻辑地址空间分段，各段长度不等。</li>
<li>每个段均有段名和段号，且从0开始编址。</li>
</ul>
</li>
<li><p>分配原则：为每个段分配一个连续的分区，各分区不必相邻接。</p>
</li>
<li><p>段表：</p>
<ul>
<li>系统为**<em>每个进程建立一张段表**</em>。</li>
<li>作用：实现从逻辑段到物理内存区的映射。</li>
<li>在段表中，每段对应一个段表项，记录段号，段长、段基址等。</li>
</ul>
</li>
<li><p>分页和分段的对比:</p>
<ul>
<li><p>相似之处:<br>都采用离散分配方式</p>
<p>地址变换都要通过地址映射机构来实现</p>
</li>
<li><p>主要区别:</p>
<p>存储单位划分原则不同</p>
<p>存储单位特征不同</p>
<p>逻辑地址性质不同</p>
</li>
</ul>
</li>
</ol>
<h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><p>段式存储共享信息比页式存储实现起来高效，因为段式的数据大小不一致不需要那么多个段表项。</p>
<h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><ol>
<li>基本原理:<br>将用户程序分成若干个段，每段一个段名;<br>再将每个段分成若干个页。</li>
<li>优点:<br>分散存储，内存利用率较高;<br>易于实现信息共享，支持动态链接。</li>
<li>缺点:<br>为获取一条指令或数据必须三次访问内存(段表、页表、取指令)，导致访问效率下降。</li>
</ol>
<h2 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h2><h3 id="虚拟存储器的引入"><a href="#虚拟存储器的引入" class="headerlink" title="虚拟存储器的引入"></a>虚拟存储器的引入</h3><ol>
<li>常规存储器管理方式的特征:<ul>
<li>一次性、驻留性</li>
<li>情况一:内存空间装不下的大作业无法运行</li>
<li>情况二:作业量大时，无法允许更多的作业并发</li>
<li>扩充内存容量的方法:物理上、逻辑上</li>
</ul>
</li>
<li>局部性原理:<ul>
<li>程序在执行时常呈现局部性规律，并表现在两个方面:<br>(1)时间局限性<br>(2)空间局限性</li>
</ul>
</li>
<li>虚拟存储器的概念:<ul>
<li>逻辑上扩充内存容量的方案:<br>(1)允许作业部分装入，其他页(段)在运行中需要访问时再调入—增加请求调入功能<br>(2) 若内存已满，将某些暂时不用的页(段)调出内存—增加置换功能</li>
<li>定义:虚拟存储器是指具有请求调入功能和置换功能,能从逻辑_上对内存容量加以扩充的一种存储器系统。<br>实质:物理上不存在，利用海量外存进行内存“空间”的扩展。<br>逻辑容量:取决于内存容量和外存容量之和。<font color='red'>虚存容量 = min (2^计算机位数[CPU位数]， 内存＋外存);</font></li>
</ul>
</li>
</ol>
<h3 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h3><p>必须基于“离散分配的内存管理技术’</p>
<ol>
<li>请求分页系统(页式虚拟存储系统)<ul>
<li>=基本分页系统+请求调页功能+页面置换功能</li>
<li>硬件支持:请求分页的页表机制、缺页中断机构、地址变换机构。</li>
<li>软件支持:请求分页、页面置换</li>
</ul>
</li>
<li>请求分段系统(段式虚拟存储系统)<ul>
<li>=基本分段系统+请求调段功能+分段置换功能</li>
<li>硬件支持:请求分段的段表机制、缺段中断机构、地址变换机构。</li>
<li>软件支持:请求分段、段的置换</li>
</ul>
</li>
</ol>
<h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><ol>
<li>离散性:在内存分配时采用离散分配方式;</li>
<li>多次性:一个作业被分成多次调入内存运行;</li>
<li>对换性:允许在作业的运行过程中进行换进、换出;</li>
<li>虚拟性:能从逻辑上扩充内存容量，使用户看到”的内存容量远大于实际大小。</li>
</ol>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3><ol>
<li><p>页表机制:</p>
<ul>
<li><p>基本作用:地址转换</p>
</li>
<li><p>增加页表字段,供程序在换入换出时参考</p>
<table>
<thead>
<tr>
<th>页号</th>
<th>物理块号</th>
<th>状态位P</th>
<th>访问字段A</th>
<th>修改位M</th>
<th>外存地址</th>
</tr>
</thead>
<tbody><tr>
<td>页面号</td>
<td>指示该页在内存上的地址</td>
<td>用于指示该页是否已调入内存</td>
<td>记录本页在一段时间内被访问的次数</td>
<td>该页在调入内存后是否被修改过</td>
<td>指示该页在外存上的地址(物理块号)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h3 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h3><ol>
<li>最小物理块数的确定:<ul>
<li>保证进程正常运行所需的最小物理块数;</li>
<li>与硬件结构有关，取决于指令的格式、功能和寻址方式。</li>
</ul>
</li>
<li>物理块的分配策略:<ul>
<li>两种内存分配策略:<br>固定分配:为进程分配的物理块数固定不变。<br>可变分配:先为每个进程分配一定数目的物理块，若发生缺页中断，再增加物理块数。</li>
<li>两种置换策略:<br>局部置换:只能将自己的某个内存页换出。<br>全局置换:可将系统中任一进程的内存页换出。</li>
<li>组合出以下三种适用策略:<br>(1) 固定分配局部置换<br>(2) 可变分配全局置换<br>(3) 可变分配局部置换</li>
</ul>
</li>
<li>物理块分配算法:<ul>
<li>(1)平均分配算法</li>
<li>(2)按比例分配算法:根据进程大小按比例分配(si/s)*m(m:物理块总数，S:各进程页面总数)</li>
<li>(3)考虑优先权的分配算法:一部分按比例分配;另一部分为优先权高的进程增加分配份额</li>
</ul>
</li>
</ol>
<h3 id="调页策略"><a href="#调页策略" class="headerlink" title="调页策略"></a>调页策略</h3><ol>
<li><p>调入页面的时机:<br>预调页策略:进程首次调入内存时，由程序员指出应该先调入哪些页。<br>请求调页策略:进程运行中发生缺页时，提出请求，由OS将其所需页面调入内存。</p>
</li>
<li><p>确定从何处调入页面:</p>
<ul>
<li>请求分页系统将外存分为两部分:<br>文件区(离散分配)、对换区(连续分配)</li>
<li>发生缺页请求时，有以下三种情况:<br>系统拥有足够的对换区空间<br>系统缺少足够的对换区空间<br>UNIX方式</li>
</ul>
</li>
<li><p>页面调入过程:<br>①若发生缺页，便向CPU发出缺页中断<br>②中断处理程序保存CPU环境，转中断处理程序<br>③该程序查找页表,得到该页在外存中的块号<br>④若内存未满，启动磁盘I/O调入页面;若内存已满，先置换再调入<br>⑤修改页表项内容，并写入快表。</p>
</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h3><ol>
<li>基本思想:<br>淘汰以后永不使用的或未来最长时间内不再被访问的页面。</li>
<li>特点:<br>理论上:缺页率低、性能最佳;<br>实际上:无法预知，实现困难;通常用于评价其他算法的优劣。</li>
</ol>
<h3 id="先进先出-FIFO-算法"><a href="#先进先出-FIFO-算法" class="headerlink" title="先进先出(FIFO)算法"></a>先进先出(FIFO)算法</h3><ol>
<li><p>基本思想:<br>淘汰最先进入内存的页面，即驻留内存时间最长的页面。</p>
</li>
<li><p>特点:<br>实现简单</p>
<p>与进程实际运行的规律不相适应:有些页面经常被访问，如:含有全局变量、常用函数的页面。</p>
</li>
</ol>
<h3 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h3><h3 id="最近最久未使用置换-LRU-算法"><a href="#最近最久未使用置换-LRU-算法" class="headerlink" title="最近最久未使用置换(LRU)算法"></a>最近最久未使用置换(LRU)算法</h3><ol>
<li>基本思想:<br>淘汰在最近一段时间最久未被使用(访问)的页面。</li>
<li>特点:<br>性能较好<br>实现较为复杂:设置访问字段;需要硬件支持(<strong><em>配置寄存器或栈</em></strong>)</li>
<li>LRU置换算法的硬件支持:<br>(1)寄存器<br>为每个在内存中的页面配置一个移位寄存器，表示为:R=Rn-1Rn-2…R1R0。<br>当进程访问某物理块时，将R-1位置1。定时信号每隔一定时间将寄存器右移一位，并将最高位补0。具有最小数值的寄存器所对应的页面就是最近最久未使用的页面。<br>(2)栈<br>利用栈保存当前使用的各个页面的页面号。栈顶是最新被访问页面的页面号，栈底是最近最久未使用页面的页面号。</li>
</ol>
<h3 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h3><ul>
<li>算法思想:<br>为每页设置一位访问位;将内存中所有页面链接成一个循环队列，并增设替换指针;<br>由页面管理软件周期性地将所有访问位置0。当某页被访问时，将其访问位置“1“。</li>
</ul>
<h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><h3 id="请求分段中的硬件支持"><a href="#请求分段中的硬件支持" class="headerlink" title="请求分段中的硬件支持"></a>请求分段中的硬件支持</h3><ol>
<li><p>段表机制:<br>基本作用:地址转换</p>
<p>增加段表字段，供程序在换入换出时参考</p>
<table>
<thead>
<tr>
<th>段名(号)</th>
<th>段长</th>
<th>段的基址</th>
<th>访问字段A</th>
<th>修改位M</th>
<th>存在位P</th>
<th>存取方式</th>
<th>增补位</th>
<th>外存始址</th>
</tr>
</thead>
<tbody><tr>
<td>段名</td>
<td>段长度</td>
<td>段的物理地址</td>
<td>记录该段被访问的频繁程度</td>
<td>该段在进入内存后是否被修改过</td>
<td>指示本段是否已调入内存</td>
<td>标识存取属性只执行、只读或允许读/写</td>
<td>表示本段在运行过程中是否做过动态增长</td>
<td>本段在外存中的起始地址，即起始盘块号</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><ol>
<li><p>共享段的分配与回收:<br>(1) 共享段的分配<br>对第一个请求使用该共享段的进程:由系统为该共享段分配一物理区，并将共享段调入;将该区始址填入请求进程的段表的相应项中;在共享段表中增加一表项，填写有关数据，并置count值为1。</p>
<p> 对其他调用该共享段的进程:在调用进程的段表中增加一表项，填入该共享段的物理地址;在共享段表的对应表项中填入调用进程的相关信息，并执行count=count+1。</p>
<p>(2)共享段的回收<br>当进程不再需要共享段时:撤消共享段的表项;执行count=count-1。仅当count=0时，由系统回收共享段的物理内存。</p>
</li>
<li><p>分段保护:<br>(1) 越界检查<br>比较:段号与段表长度、段内地址与段长;若越界，则发出越界中断信号。<br>(2)存取控制检查<br>存取控制字段只读、只执行、读/写</p>
<p>(3)环保护机构：低编号的环具有高优先权</p>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>虚拟存储器，是在逻辑上扩充内存容量，使得应用程序认为它有一个连续完整的地址空间，被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。 特点主要有：<ol>
<li>离散性：在内存分配时采用离散分配方式。</li>
<li>多次性：一个作业被分成多次调入内存运行。</li>
<li>兑换性：允许在作业运行过程中进行换进、换出。</li>
<li>虚拟性：能从逻辑上扩充内存容量，使用户“看到”的内存容量远大于实际大小。</li>
</ol>
</li>
</ul>
<h1 id="设备管理-1"><a href="#设备管理-1" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="I-O控制系统"><a href="#I-O控制系统" class="headerlink" title="I/O控制系统"></a>I/O控制系统</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><ul>
<li><p>I/0设备分类的重要指标:<br>(1)设备使用特性<br>(2)数据传输速率<br>(3)数据传输单位<br>(4)设备共享属性</p>
</li>
<li><p>设备与控制器间的接口<br>由于设备与CPU的速度不匹配，设备并不直接与CPU通信，而是与设备控制器通信，因此，I/0设备中应含有与设备控制器间的接口，在接口中，有三种类型的信号，各对应一个信号线：数据信号线，控制信号线，状态信号线。</p>
<ul>
<li><p>数据信号线:用于在设备和设备控制器之间传送数据信号。</p>
<p>对于输入设备，由外界输入的信号经转换器转换后所形成的数据，先送入缓冲器中，当数据量达到一定的字符数后，再从缓冲器通过一组数据信号线传送给设备控制器。<br>对于输出设备，将从设备控制器，经过数据信号线传送来的一批数据，先暂存于缓冲器中，经转换器适当转换后，再逐个字符地<br>输出。</p>
</li>
<li><p>控制信号线:作为由设备控制器向I/0设备发送控制信号时的通路。<br>规定了设备将要执行的操作，如:读操作:指由设备向控制器传送数据;写操作:从控制器接收数据。</p>
</li>
<li><p>状态信号线：用于传送指示设备当前状态信号。如：正在读、读完成等等。</p>
</li>
</ul>
</li>
</ul>
<h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><ul>
<li>设备控制器是**<em>CPU与I/0设备之间的接口**</em>，接收从CPU发来的命令，去控制I/0设备工作，使CPU从繁杂的设备控制事务中解脱出来。<br>设备控制器是一个可编址的设备，可连接多个设备，使每个设备地址对应一个设备。<br>设备控制器通常做成电路卡形式，称为接口卡。如打印卡、显卡等。</li>
<li>设备控制器与处理机的接口<br>共有3类信号线:数据线、地址线、控制线。<br>数据线通常与两类寄存器相连，<br>(1)数据寄存器:用于存放从设备送来的数据(输入)、或者从CPU送来的数据(输出)。<br>(2)控制/状态寄存器用于存放从CPU送来的控制信息，或者设备状态信息。</li>
<li>设备控制器的基本功能.<br>1)接收和识别命令<br>2)数据交换<br>3)标识和报告设备的状态<br>4)地址识别<ol start="5">
<li>数据缓冲</li>
<li>差错控制</li>
</ol>
</li>
</ul>
<h3 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I/O通道"></a>I/O通道</h3><ol>
<li><p>I/0通道的引入<br>I/0通道是一种特殊的处理机。它具有执行I/O指令的能力，并通过执行通道(I/O)程序来控制I/0操作。</p>
</li>
<li><p>I/0通道又与一般的处理机不同:<br> (1)其指令类型单一，这是由于通道硬件比较简单，所能执行的命令，主要局限于与I/0操作有关的指令;<br> (2)通道没有自己的内存，通道所执行的通道程序是放在主机的内存中的，通道与CPU共享内存。</p>
</li>
<li><p>I/0通道类型</p>
<ul>
<li><p>字节多路通道</p>
<p>字节多路通道是一种按字节交叉方式工作的通道。它包含许多非分配型子通道，每个通道连接并控制一台I/0设备，这些子通道按照时间片轮转方式，共享主通道。</p>
</li>
<li><p>数组选择通道</p>
<p>数组选择通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序，控制一台设备进行数据传送，致使当某台设备占用了该通道后，便一直由它独占，即使它无数据传送，通道被闲置，也不允许其它设备使用该通道，直至该设备传送完毕释放该通道。</p>
</li>
<li><p>数组多路通道</p>
<p>数组多路通道是将数组选择通道传输速率高和字节多路通道能使各子通道(设备)分时并行操作的优点相结合而形成的一种新通道。被广泛地用于连接多台高、中速的外围设备。</p>
</li>
</ul>
</li>
</ol>
<h3 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h3><p>计算机系统中的各部件，如CPU、 主存、I/0设备之间的联系，都是通过总线实现的。总线性能是用总线的时钟频率、带宽、传输速率等指标来衡量的。</p>
<p>局部总线，是指将多媒体卡、高速LAN网卡、高性能图形板等，从ISA总线 上卸下来，再通过局部总线控制器，直接连接到CPU总线上，使之与高速CPU总线相匹配，而打印机、传真机、CDROM等仍挂在ISA总线_上。</p>
<h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><h3 id="程序I-O方式"><a href="#程序I-O方式" class="headerlink" title="程序I/O方式"></a>程序I/O方式</h3><p>在处理机向控制器发出一条I/O指令启动输入设备输入数据时,读出状态寄存器的设备状态,将busy标志位置为1 ;然后,需要不停测试busy标志位，如果busy标志位=1，表示输入未完成,处理机继续测试，直到busy标志位=0 ,表明输入数据已进入控制器的数据寄存器中;处理机将数据寄存器中的数据取出，送入指定内存单元中。</p>
<p>在程序I/0方式中，从终端输入一个字符的时间约为100 ms，而将字符送入终端缓冲区的时间小于0. 1 ms。若采用程序I/0方式，CPU约有99. 9ms的时间处于忙一等待中。<br>由于CPU的高速性和I/0设备的低速性，致使CPU的绝大部分时间都处于等待I/0设备完成数据I/O的循环测试中，造成对CPU的极大浪费。</p>
<h3 id="中断驱动I-O控制方式"><a href="#中断驱动I-O控制方式" class="headerlink" title="中断驱动I/O控制方式"></a>中断驱动I/O控制方式</h3><p>在输入数据时，当设备控制器收到CPU发来的读命令后，便去控制输入设备读数据。当输入数据已进入控制器的数据寄存器时，控制器便通过控制线向CPU发送一个中断信号，CPU检查输入过程中是否出错，若无错，便向控制器发送取走数据的信号，再通过控制器与数据线将数据写入指定内存单元中。</p>
<p>例如，从终端输入一个字符的时间约为100 ms，而将字符送入终端缓冲区的时间小于0. 1 ms。若采用中断驱动方式后，CPU可利用这99.9ms的时间去做其它事情，而仅用0.1ms的时间来处理由控制器发来的中断请求。<br>在I/0设备输入每个数据的过程中，由于无须CPU干预，因而可使CPU与I/0设备并行工作，提高了整个系统的资源利用率及吞吐量。</p>
<h3 id="直接存储器访问DMA控制方式"><a href="#直接存储器访问DMA控制方式" class="headerlink" title="直接存储器访问DMA控制方式"></a>直接存储器访问DMA控制方式</h3><p>①数据传输的基本单位是数据块，即在CPU与I/0设备之间，每次传送至少一个数据块;</p>
<p>②所传送的数据是从设备直接送入内存的，或者相反;<br>③仅在传送一个或多个数据块的开始和结束时,才需CPU干预，整块数据的传送是在控制器的控制下完成的。</p>
<p>为了实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中设置如下四类寄存器:<br>(1) 命令/状态寄存器CR。用于接收从CPU发来的I/0命令或有关控制信息，或设备的状态。<br>(2) 内存地址寄存器MAR。在输入时，它存放把数据从设备传送到内存的起始目标地址;在输出时，它存放由内存到设备的内存源地址。<br>(3) 数据寄存器DR。 用于暂存从设备到内存，或从内存到设备的数据。<br>(4) 数据计数器DC。存放本次CPU要读或写的字(节)数。</p>
<ul>
<li>DMA工作过程<br>当CPU从磁盘读入一数据块时，向磁盘控制器发送一条读命令。该命令被送到其中的命令寄存器(CR)中;同时，发送本次要将数据读入的内存起始目标地址，该地址被送入内存地址寄存器中(MAR) ;本次要读的字节数送入数据计数器中(DC);将磁盘的源地址直接送DMA控制器的I0控制逻辑上。然后，启动DMA控制器进行数据传送，CPU可处理其它任务。</li>
<li>整个数据传送过程由DMA控制器进行控制。当从磁盘读入一个字节的数据，并送入数据寄存器后，再挪用一个存储周期，将字节送到内存地址寄存器中(MAR) 所指示的内存单元中;接着，对内存地址寄存器MAR内容加1;将数据计数器DC内容减1。若减1后，数据计数器内容不为0，表示传送未完，便继续传送下一个字节;否则，由DMA控制器发出中断请求。由CPU完成一个完整数据块的数据读入。</li>
</ul>
<h3 id="I-O通道控制方式"><a href="#I-O通道控制方式" class="headerlink" title="I/O通道控制方式"></a>I/O通道控制方式</h3><p>I/0通道方式是DMA方式的发展，它可进一步减少CPU的干预，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预。</p>
<p>例如，当CPU要完成一组相关的读(或写)操作及有关控制时，只需向I/0通道发送一条I/0指令，以给出其所要执行的通道程序的首址和要访问的I/0设备，通道接到该指令后，通过执行通道程序便可完成CPU指定的I/0任务。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ol>
<li>程序I/O控制方式:适用于结构简单，只需少量硬件的电路。 </li>
<li>中断驱动I/O控制方式：适用于高效场合。 </li>
<li>直接存储访问DMA I/O控制方式：适用于无须CPU介入的控制器来控制内存与外设之间的数据交流的场合。 </li>
<li>I/O通道控制方式：适用于以字节为单位的干预，同时实现CPU，通道和I/O设备三者并行操作的场合。</li>
</ol>
<h2 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h2><h3 id="缓存的引入"><a href="#缓存的引入" class="headerlink" title="缓存的引入"></a>缓存的引入</h3><p>(1)缓和CPU与I/0设备间速度不匹配的矛盾。<br>(2)减少对CPU的中断频率，放宽对CPU中断响应时间的限制。<br>(3)提高CPU和I/0设备之间的并行性。</p>
<h3 id="单缓存和双缓存"><a href="#单缓存和双缓存" class="headerlink" title="单缓存和双缓存"></a>单缓存和双缓存</h3><p>在单缓冲情况下，每当用户进程发出一个I/0请求时，OS便在主存中为之分配一个缓冲区。<br>例如:在块设备输入时，假定从磁盘把块数据输入到缓冲区的时间为T;将该缓冲区的数据传送到用户区的时间为M;CPU对这块数据的处理时间为C;由于T与C是可以并行的，可以把系统对每一块数据的处理时间表示为<code>max(C, T)+M</code>.</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218084540968.png" alt="image-20201218084540968"></p>
<p>引入双缓冲后，在设备输入时，先将数据送入第一个缓冲区，装满后便转向第2个缓冲区;这时，OS可从第一个缓冲区中移出数据，送入用户进程;由CPU对数据进行计算。<br>例如:采用行输入方式时，双缓冲能消除用户的等待时间，即用户在输入完成第1行之后，在CPU执行第1行的命令时，用户可继续输入第2行的数据。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218084719309.png" alt="image-20201218084719309"></p>
<h3 id="循环缓存"><a href="#循环缓存" class="headerlink" title="循环缓存"></a>循环缓存</h3><p>(1)缓冲区。缓冲区大小相同，分为三种类型:</p>
<p>用于装入输入数据的空缓冲区R、</p>
<p>已装满数据的缓冲区G、</p>
<p>现行工作区C .<br>(2)指针。用于指示计算进程下一个可用缓冲区G的指针<code>nextg</code>、指示输入进程下次可用的空缓冲区<code>nexti</code>、指示计算进程正在使用的缓冲区C的指针<code>current</code></p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218084858088.png" alt="image-20201218084858088"></p>
<ul>
<li>循环缓冲区的使用<br>(1) Getbuf过程 。<br>计算进程要使用缓冲区数据时，将由指针nextg所指示的缓冲区，提供给进程;将其改为现行工作区，令current 指针指向该缓冲区的第一个单元，同时，将nextg移向下一个G缓冲区。<br>(2) Releasebuf过程。<br>当计算进程把C缓冲区中的数据提取完毕时，调用Releasebuf过程，释放C;将该缓冲区C改为空缓冲区R。类似的，输入进程使用空缓冲区装入数据时，应调用Getbuf过程。当输入进程把缓冲区填满时，应调用Releasebuf过程。</li>
<li>进程同步<br>(1) Nexti指针追 赶上Nextg指针。<br>说明输入进程的速度大于计算进程的速度，全部空缓冲区装满数据。此时，输入进程阻塞，称为系统受计算所限。<br>(2) Nextg指针追赶上Next i指针。<br>说明计算进程的速度大于输入进程的速度，全部数据缓冲区取空。此时，计算进程阻塞，称为系统受IO所限。</li>
</ul>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><ol>
<li><p>缓冲池的组成<br>公用缓冲池，含有以下三种类型的缓冲区:<br>(1)空(闲)缓冲区;<br>(2)装满输入数据的缓冲区;<br>(3)装满输出数据的缓冲区。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218085322372.png" alt="image-20201218085322372"></p>
<p>除了上述3个队列外，还具有4种工作缓冲区:<br>(1)用于收容输入数据的工作缓冲区hin;<br>(2) 用于提取输入数据的工作缓冲区sin;<br>(3)用于收容输出数据的工作缓冲区hout;<br>(4)用于提取输出数据的工作缓冲区sout。</p>
</li>
<li><p>缓冲区工作方式</p>
<p>(1)收容输入。当输入进程需要输入数据时，调用Getbuf (emq) 过程，从空缓冲队列emq的队首，摘下一个空缓冲区，作为收容输入工作缓冲区hin。把数据输入其中，装满后再调用putbuf (inq,hin) 过程，将该缓冲区挂在输入队列inq上。</p>
<p>(2)提取输入。当计算进程需要数据时，调用Getbuf (inq)过程，从输入数据队列inq的队首，取得一个缓冲区，作为提取输入工作缓冲区sin,计算进程从中取数据。计算进程用完数据后，再调用putbuf (emq, sin)过程，将该缓冲区挂在空队列emq上。</p>
<p>(3)收容输出。当计算进程需要输出数据时，调用Getbuf(emp)过程，从空缓冲队列emp的队首，摘下一个空缓冲区，作为收容输出工作缓冲区hout。把输出数据装满后，再调用putbuf (outq, hout) 过程，将该缓冲区挂在输出队列outq末尾。</p>
<p>(4)提取输出。输出进程Getbuf (outq) 过程，从输出队列outq的队首，取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区sout。在数据提取完成后，再调用putbuf (emq， sout) 过程，将该缓冲区挂在空队列emq末尾。</p>
</li>
</ol>
<h2 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I/O软件"></a>I/O软件</h2><h3 id="I-O软件的设计目标和原则"><a href="#I-O软件的设计目标和原则" class="headerlink" title="I/O软件的设计目标和原则"></a>I/O软件的设计目标和原则</h3><p>(1)与具体设备无关<br>(2)统一命名<br>(3)错误处理<br>(4)缓冲技术<br>(5)设备的分配和释放<br>(6)I/O控制方式</p>
<ul>
<li><p>I/O软件的分层设计结构</p>
<ol>
<li><p>用户层软件。是用户交互的接口，可以直接调用与/O操作相关的库函数。</p>
</li>
<li><p>设备独立性软件。实现与设备驱动器的统一接口、 设备保护、设备分配。</p>
<p>设备独立性的基本含义是:应用程序独立于具体使用的物理设备。<br>为了实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中，使用逻辑设备名称来请求使用某类设备;而系统在实际执行时，还必须使用物理设备名称。因此，系统须具有将**<em>逻辑设备名称转换为某物理设备名称**</em>的功能。</p>
<ol>
<li><p>执行所有设备的公有操作</p>
<pre><code>①对独立设备的分配与回收;
   ②将逻辑设备名映射为物理设备名;
   ③对设备进行保护，禁止用户直接访问设备
   ④缓冲管理;
   ⑤差错控制;
   ⑥提供独立于设备的逻辑块。</code></pre>
</li>
<li><p>向用户层软件提供统一接口</p>
<p>无论何种设备，它们向用户所提供的接口应该是相同的。例如，对各种设备的读操作，在应用程序中都使用read;而对各种设备的写操作，也都使用write。</p>
</li>
</ol>
</li>
<li><p>设备驱动程序。与硬件直接相关，负责实现系统对设备发出的操作指令，驱动I/O设备工作。</p>
<ol>
<li><p>驱动程序主要是指在请求I/0的进程与设备控制器之间的一个通信和转换程序。</p>
</li>
<li><p>驱动程序与设备控制器和I/0设备的硬件特性紧密相关，因而对不同类型的设备应配置不同的驱动程序。</p>
</li>
<li><p>驱动程序与I/0设备所采用的I/0控制方式紧密相关。</p>
</li>
<li><p>由于驱动程序与硬件紧密相关。</p>
</li>
<li><p>设备驱动程序的处理过程</p>
<ol>
<li><p>将抽象要求转换为具体要求。如:将抽象要求中的盘块号转换为磁盘的盘面、磁道、扇区，在0S中，只有设备驱动程序同时了解抽象要求、和设备控制器中的寄存器情况，知道命令、数据、参数分别送到哪个寄存器。</p>
</li>
<li><p>检查I/0请求的合法性。</p>
</li>
<li><p>读出和检查设备的状态。</p>
</li>
<li><p>传送必要的参数。如:在启动磁盘读写前，应将本次要传送的字节数、数据的主存始址，送到控制器的相应寄存器中。</p>
</li>
<li><p>工作方式的设置。</p>
</li>
<li><p>启动I/0设备。驱动程序发出I/0命令后，由设备控制器控制基本的I0操作。此时，驱动进程阻塞，直到中断到来时将它唤醒。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>中断处理程序。保存被中断进程的CPU环境，转入相应的中断处理程序，恢复被中断进程的现场后返回到被中断进程。</p>
<ol>
<li>唤醒被阻塞的驱动进程.</li>
<li>保存被中断进程的CPU环境。将处理机状态字、程序计数器，保存在中断保留区中。</li>
<li>分析中断原因，转入相应的中断处理程序。</li>
<li>中断处理。对于不同设备，有不同的中断处理程序，如打印、数据输入等，根据设备控制器的状态，结束中断。</li>
<li>恢复被中断进程的现场后返回到被中断进程。</li>
</ol>
</li>
<li><p>硬件。执行IO操作。</p>
</li>
</ol>
</li>
<li><p>当一个进程从文件中读一个数据块时，需要通过系统调用取得0S服务来完成;设备独立性软件接收到I/0请求后，首先在高速缓存中查找相应的页面，如果没有，则调用设备驱动程序向硬件发出一个请求，由驱动程序负责从磁盘读取目标数据块。当磁盘操作完成后，由硬件产生一个中断，并转入中断处理程序，检查中断原因，提取设备状态，转入相应的设备驱动程序，唤醒用户进程，结束此次I/0请求，继续用户进程的运行。</p>
</li>
<li><p>为实现设备的独立性，系统必须设置一张逻辑设备表，用于将应用程序中所使用的逻辑设备名映射为物理设备名。当进程使用逻辑设备名请求分配I/O设备时，系统在逻辑设备表中建立一个表目，填入应用程序中使用的逻辑设备名、系统分配的物理设备名、以及设备驱动程序的入口地址。</p>
</li>
<li><p>逻辑设备表的设置方式<br>第一种是在整个系统中只设置一张逻辑设备表，这要求所有用户不能使用相同的逻辑设备名。</p>
<p>第二种方式是为每个用户设置一张逻辑设备表。将逻辑设备表放入用户进程的PCB中，这样，不同用户可以使用相同的逻辑设备访问物理设备。</p>
</li>
<li><p>设备独立性的优点<br>(1)设备分配时的灵活性。当进程使用物理设备名请求设备时，如果设备忙碌，进程会阻塞。当进程使用逻辑设备名请求某类设备时，系统可将任一台空闲的设备分配给进程，仅当所有设备全忙碌时，进程才会阻塞。<br>(2)易于实现I/0重定向。I/0重定向，指用于I/0操作的设备可以更换，而不必改变应用程序。例如:当调试程序时，可将程序的所有输出送往屏幕显示;如果将输出结果打印时，不必修改应用程序，只须将I/0重定向的逻辑设备表中的显示端，改为打印机。</p>
</li>
</ul>
<h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><h3 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h3><ol>
<li><p>设备控制表DCT</p>
<p>系统为每个设备设置一-张设备控制表，用于记录该设备的情况。在设备控制表中，包含:<br>(1)设备类型<br>(2)设备标识符<br>(3)设备队列的队首指针(队列中存放请求设备未被满足的PCB)<br>(4)设备状态<br>(5)与设备相连的控制器表指针<br>(6)重复执行次数。系统规定在设备工作中发生错误时可重复执行次数。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218092248978.png" alt="image-20201218092248978"></p>
</li>
<li><p>控制器控制表</p>
<p>系统为每个设备控制器设置一张设备控制器表，用于记录该设备控制器的情况。包含:</p>
<p>(1)设备控制器标识符<br>(2)设备控制器状态<br>(3)与设备控制器相连的通道表指针<br>(4)控制器队列的队首指针<br>(5)控制器队列的队尾指针</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218092354998.png" alt="image-20201218092354998"></p>
</li>
<li><p>通道控制表</p>
<p>系统为每个通道配有一-张通道表，用于记录该通道的情况。包含:<br>(1)通道标识符<br>(2)通道状态<br>(3)与通道连接的设备控制器表首址<br>(4)通道队列的队首指针<br>(5)通道队列的队尾指针</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218092453900.png" alt="image-20201218092453900"></p>
</li>
<li><p>系统设备表</p>
<p>系统设备表是个系统范围的数据结构，记录了系统中全部设备的情况。每个设备占一个表目，其中包括:<br>(1)设备类型<br>(2)设备标识符<br>(3)设备控制表<br>(4)设备驱动程序的入口</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218092831185.png" alt="image-20201218092831185"></p>
</li>
</ol>
<h3 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h3><ol>
<li>设备的固有属性<br>(1) 独享设备。采取独占分配策略<br>(2) 共享设备。可以通过某种调度方式，分配给多个进程使用。<br>(3) 虚拟设备。指通过采用虚拟技术，使一台物理设备可变成多台逻辑上的共享设备。可以分配给多个进程使用。</li>
<li>设备分配算法<br>(1) 先来先服务<br>当多个进程对同一设备提出I/0请求时，该算法根据进程提出请求的先后次序，排成一个设备请求队列，总是将设备分配给队首进程。<br>(2) 优先级高者优先<br>在这种算法中，总是优先权高的进程优先获得资源。对于优先权相同的进程，按照先来先服务的原则排队。</li>
<li>设备分配中的安全性<br>(1) 安全分配方式<br>当进程请求资源时，便进入阻塞状态，直到I/0操作完成才被唤醒。但进程的并发度低，资源的利用率低。<br>(2)不安全分配方式<br>当进程请求资源时，仍继续运行，需要时又发出第2个I/0请求，第3个I/0请求等，按照安全性算法进行计算，仅当状态安全时，才分配。这种方式稍复杂，但进程的并发度高。</li>
</ol>
<h3 id="独占设备的分配程序"><a href="#独占设备的分配程序" class="headerlink" title="独占设备的分配程序"></a>独占设备的分配程序</h3><ol>
<li><p>基本的设备分配程序<br>当进程提出I/0请求后，按下列3个步骤进行分配。<br>(1) 分配设备</p>
<p>首先，根据I/0请求中的物理设备名，查找SDT， 找出该设备的设备控制表DCT，根据DCT中的设备状态字段，可知设备是否正忙。若忙，将该进程的PCB挂在设备的等待队列中;若不忙，按照一-定的算法计算设备分配的安全性，来分配设备。</p>
<p>(2) 分配控制器</p>
<p>在系统将设备分配给请求进程后，从DCT中找到与该设备相连的控制器的COCT，根据COCT中的状态字段，可知该设备控制器是否正忙。若忙，将该进程的PCB挂在设备控制器的等待队列中;若不忙，将设备控制器分配给进程。</p>
<p>(3) 分配通道</p>
<p>在系统将设备控制器分配给请求进程后，从控制器控制表COCT中找到与该控制器相连的通道的通道控制表CHCT，根据CHCT中的状态字段，可知该通道是否正忙。若忙，将该进程的PCB挂在通道的等待队列中;若不忙，将通道分配给进程。</p>
</li>
<li><p>设备分配程序的改进<br>(1) 增加设备的独立性<br>进程利用逻辑设备名请求I/0。系统首先从系统设备表SDT中找出第一个该类设备的设备控制表DCT，若设备忙，再查找第2个该类设备的DCT;仅当所有该类设备都忙时，才将该进程的PCB挂在该类设备的等待队列中。<br>(2)考虑多通路情况<br>可以按照多通路情况进行改进。例如，若设备连接的第一个控制器忙碌时，应查看第2个控制器，仅当所有该类设备控制器都忙时，才将该进程的PCB挂在该类设备控制器的等待队列中。<br>同理，通道分配也是一样的。</p>
</li>
</ol>
<h3 id="SPOOLing技术"><a href="#SPOOLing技术" class="headerlink" title="SPOOLing技术"></a>SPOOLing技术</h3><ol>
<li><p>什么是SPOOLing<br>当系统中引入了多道程序技术后，可以利用其中的一道程序，来模拟脱机输入时的外围控制机功能，把低速I/0设备，上的数据传送到高速磁盘上;再用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。<br>这样，便可在主机的直接控制下，实现脱机输入、输出功能。此时的外围操作与CPU对数据的处理同时进行，把这种在联机情况下实现的同时外围操作称为SPOOLing，或称为假脱机操作。</p>
</li>
<li><p>SPOOLing系统的组成</p>
<p>(1) 输入井、输出井这是在磁盘上开辟的两大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存I/0设备输入的数据;输出井是模拟脱机输出时的磁盘设备，用于暂存用户程序的输出数据。</p>
<p>(2) 输入缓冲区、输出缓冲区为缓和CPU与磁盘之间速度不匹配的矛盾，在内存中开辟输入缓冲区、输出缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井;输出缓冲区用于暂存由输出井送来的数据，以后再传送到输出设备。</p>
<p>(3) 输入进程、输出进程两个进程用于模拟脱机IO时的外围控制机。输入进程用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备、通过输入缓冲区、再送到输入井，当CPU需要数据时，直接从输入井读入内存;输出进程用于模拟脱机输出时的外围控制机，将用户要求输出的数据，先从内存送到输出井，待输出设备空闲时，再将输出井中的数据，通过输出缓冲区、送到输出设备上。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218093846748.png" alt="image-20201218093846748"></p>
</li>
<li><p>共享打印机<br>当用户进程请求打印输出时，SPO0Ling 系统同意为它打印输出，但并不立即把打印机分配给该用户进程，只为它做两件事:<br>①由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中;<br>②输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该 表挂到请求打印队列上。</p>
<p>如果还有进程请求打印，系统仍为之做上述两件事情。<br>当打印机空闲时，输出进程从请求打印队列的队首，取出一张请求打印表，根据表中的要求，将要打印的数据，从输出井传送到内存缓冲区，进行打印;直到所有请求响应完成，输出进程阻塞;仅当再有打印请求时，才被唤醒。</p>
</li>
<li><p>SPOOLing系统的特点<br> (1)提高了I/O的速度。<br>(2)将独占设备改造为共享设备。</p>
<p>(3)实现了虚拟设备功能。</p>
</li>
</ol>
<h2 id="磁盘存储器管理"><a href="#磁盘存储器管理" class="headerlink" title="磁盘存储器管理"></a>磁盘存储器管理</h2><h3 id="磁盘性能简述"><a href="#磁盘性能简述" class="headerlink" title="磁盘性能简述"></a>磁盘性能简述</h3><ol>
<li><p>数据的组织和格式<br>磁盘设备可包括一到多个物理盘片，每个磁盘片分一个或者两个存储面;<br>每个磁盘面被组织成若干个同心环，称为磁道，各磁道之间留有必要的间隙。<br>每条磁道存储相同数目的二进制位，磁盘密度指每英寸中所存储的位数，内层磁道的密度比外层高。<br>每个磁道逻辑上划分成若干个扇区，一个扇区称为一个盘块，各扇区之间保留一定的间隙。</p>
</li>
<li><p>磁盘在使用前，一定要低级格式化。磁盘格式化后，要对磁盘分区。</p>
</li>
<li><p>在真正使用磁盘前，还要进行一次高级格式化，即设置一个引导块、空闲存储管理、根目录、和一个空文件系统。<br>常用的分区格式有: FAT32、NTFS等</p>
</li>
<li><p>磁盘的类型<br>(1)固定头磁盘<br>这种磁盘在每条磁道上都有一读/写磁头，所有的磁头都被装在一刚性磁臂中。通过这些磁头可访问所有各磁道，进行并行读/写，有效地提高了磁盘的I/0速度。这种结构的磁盘主要用于大容量磁盘上。<br>(2)移动头磁盘<br>每一个盘面仅配有一个磁头，也被装入磁臂中。为能访问该盘面上的所有磁道，该磁头必须移动以进行寻道。可见，移动磁头仅能以串行方式读/写，致使其I/0速度较慢;但由于其结构简单，故仍广泛应用于中小型磁盘设备中。</p>
</li>
<li><p>磁盘访问时间<br>(1)寻道时间Ts<br>指把磁臂(磁头)移动到指定磁道上所经历的时间。该时间是启动磁臂的时间s与磁头移动n条磁道所花费的时间之和，即<br><code>Ts=m*n+s</code><br>其中，m是一常数，与磁盘驱动器的速度有关，对一般磁盘，m=0.2; 对高速磁盘，m≤0.1，磁臂的启动时间约为2ms。</p>
</li>
<li><p>磁盘访问时间<br>(2)旋转延迟时间T π<br>指定扇区移动到磁头下面所经历的时间。<br>对于硬盘，典型的旋转速度大多为5400 r/min，每转需时11.1ms，平均旋转延迟时间Tπ为5.55ms;对于软盘，其旋转速度为300<br>r/min或600 r/min，这样，平均T τ为50~ 100 ms。</p>
</li>
<li><p>磁盘访问时间<br>(3)传输时间Tt<br>指把数据从磁盘读出或向磁盘写入数据所经历的时间。Tt的大小与每次所读/写的字节数b和旋转速度有关。<br><code>Tt=b/rN</code><br>其中，r为磁盘每秒钟的转数; N为一条磁道上的字节数，当一-次读/写的字节数相当于半条磁道上的字节数时，Tt与T τ相同。</p>
</li>
<li><p>磁盘访问时间<br>访问时间Ta表示为: </p>
<p><code>Ta=Ts+1/2r+b/rN</code><br>可见，数据存放集中，有利于提高传输效率。</p>
</li>
</ol>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><ol>
<li><p>先来先服务FCFS<br>(1)根据进程请求访问磁盘的先后次序，进行调度。<br>(2)举例说明<br>按照先来先服务的调度方法，得到平均寻道时间为55.3.<br>(3)简单，适合于请求磁盘I/O进程数目较少的场合。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218095531159.png" alt="image-20201218095531159"></p>
</li>
<li><p>最短寻道时间优先(SSTF)<br>(1)该算法优先选择这样的进程:该进程要求访问的磁道与当前磁头所在磁道的距离最近，以使每次的寻道时间最短。<br>(2)举例说明<br>按照最短寻道时间优先的调度方法，得到平均寻道时间为27.5.<br>(3)较之先来先服务的调度方法，有更好的寻道性能。</p>
<p>SSTF算法虽然能获得较好的寻道性能，却可能导致某个进程发生“饥饿”(Starvation)现象。因为只要不断有新进程的请求到达，且其所要访问的磁道、与磁头当前所在磁道的距离较近，这种新进程的I/0请求必须优先满足，老进程出现“饥饿”现象。对SSTF算法略加修改后，形成SCAN算法。</p>
</li>
<li><p>扫描SCAN算法<br>(1)该算法优先考虑的是磁头当前的移动方向，再考虑进程欲访问的磁道与当前磁道的距离最近。<br>(2)例如:</p>
<p>从磁道100#开始，向外移动方向;利<br>用扫描SCAN算法，得到磁道号次序为: 100， 150, 160，184， 90，58， 55，39， 38，18;平均寻道时间为27.8<br>(3) SCAN算法似电梯的运行，称电梯调度算法。SCAN算法具有较好的寻道性能，能够防止“饥饿’现象，应用于大、中、小型机器中。</p>
</li>
</ol>
<h3 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h3><ol>
<li>磁盘高速缓存的形式<br>指利用内存中的存储空间，来暂存从磁盘中读出的一系列盘块中的信息。高速缓存是一组在逻辑上属于磁盘，物理上是驻留在内存中的盘块。<br>高速缓存在内存中可分成两种形式。<br>(1)在内存中开辟一个单独的存储空间来作为磁盘高速缓存，其大小是固定的，不会受应用程序多少的影响;<br>(2)把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘I/O时(作为磁盘高速缓存)共享。当磁盘I/O的频繁程度较高时，该缓冲池可能包含更多的内存空间;而在应用程序运行得较多时，该缓冲池可能只剩下较少的内存空间。</li>
<li>数据交付方式<br>系统可以采取两种方式，将数据交付给请求进程:<br>(1)数据交付。直接将高速缓存中的数据，传送到请求者进程的内存工作区中。<br>(2)指针交付。只将指向高速缓存中某区域的指针，交付给请求者进程。后一种方式由于所传送的数据量少，节省了数据从磁盘高速缓存存储空间到进程的内存工作区的时间。</li>
<li>置换算法<br>由于请求调页中的联想存储器与高速缓存的工作情况不同，因而使得在置换算法中所应考虑的问题也有所差异。现在不少系统在设计其高速缓存的置换算法时，除了考虑到最近最久未使用这一原则外，还考虑了以下几点:<br>(1) 访问频率。<br>(2) 可预见性。<br>(3) 数据的一致性。</li>
<li>周期性地写回磁盘<br>在UNIX系统中专门增设了一个修改程序，在后台运行，该程序周期性地调用一个系统调用SYNC，其主要功能是强制性地将所有在高速缓存中已修改的盘块数据写回磁盘，一般是把两次调用SYNC的时间间隔定为30s。这样，因系统故障所造成的工作损失不会超过30s的劳动量。</li>
</ol>
<h3 id="提高磁盘I-O速度的其它方法"><a href="#提高磁盘I-O速度的其它方法" class="headerlink" title="提高磁盘I/O速度的其它方法"></a>提高磁盘I/O速度的其它方法</h3><ol>
<li>提前读。对于顺序文件的访问，可以采用预告读文件的方式，将下一个盘块的数据也读入缓冲区。</li>
<li>延迟写。如:在缓冲区A中的数据，不马上写回磁盘，只挂在空闲区的末尾。当进程使用缓冲区快到A时，再将A中的数据写入磁盘后，把缓冲区分配出去。</li>
<li>优化物理块的分布。一个文件的多个物理块安排的分散，会增加磁头的移动时间，寻道时间增大。可以将同一个磁道上的若干个盘块组成一个簇，如一个簇包含4个盘块，以簇为单位进行分配，提高访问速度。</li>
<li>虚拟盘。指利用内存空间去仿真磁盘，称为RAM盘。当创建虚拟盘后，其操作与硬盘一样;但虚拟盘是易失性存储器，当关机或重新启动计算机时，虚拟盘上的信息将被丢失，所以在关机或重新启动计算机前，一定要及时把在虚拟盘上的重要的数据存放到真正的硬盘中。</li>
</ol>
<h3 id="廉价磁盘冗余阵列"><a href="#廉价磁盘冗余阵列" class="headerlink" title="廉价磁盘冗余阵列"></a>廉价磁盘冗余阵列</h3><ol>
<li>并行交叉存取</li>
</ol>
<p>​    在系统中，有多台磁盘驱动器，系统将每一个盘块中的数据分为若千个子盘块数据，再把每一个子盘块的数据分别存储到各个不同磁盘中的相同位置上;当把数据传送到内存时，可采用并行传输方式，将各盘块中的子盘块数据，同时向内存中传输，大大减少传输时间。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218100348051.png" alt="image-20201218100348051"></p>
<p>例如:在存放一个文件时，可将该文件中的第1个数据子块放在第1个磁盘驱动器上;将该文件中的第2个数据子块放在第2个磁盘驱动器上;<br>…..将该文件中的第N个数据子块放在第N个磁盘驱动器上。在读取数据时，可采用并行传输方式，同时从1-N个数据 子块读出数据，将磁盘I/0的速度提高了N-1倍。</p>
<ol start="2">
<li>RAID的分级<br>(1) RAID 0级。采用了并行交叉存取技术，提高了I/0速度。但无冗余校验功能，可靠性不好。<br>(2) RAID 1级。具有磁盘镜像功能。如:当磁盘阵列中具有8个盘时，利用4个作为数据盘，4个作为镜像盘，当读写数据时，同时写入数据盘和镜像盘。其可靠性较好，但磁盘利用率只有50%。<br>(3)RAID 3级。具有并行传输功能的磁盘阵列。它利用一台奇偶校验盘来完成数据的校验功能。如:当阵列中有7个盘时，利用6个作为数据盘，1 个作为校验盘，其磁盘利用率为6/7;常用于科学计算、图像处理等。</li>
</ol>
<p>(4) RAID 5级。是一种具有独立传送功能的磁盘阵列。每个驱动器都有各自独立的数据通路，独立地进行读写，无专门的校验盘;其校验信息，是以螺旋的方式，散布在所有数据盘上，故可靠性好。其磁盘利用率高;常用于I/0较频繁的事务处理中。<br>(5) RAID 6级和RAID 7级。在RAID6中，设置了1个专用的、可快速访问的异步校验盘; RAID7 是RAID6的改进;所有磁盘都具有较高的传输速率、优异的性能，但价格昂贵。</p>
<ol start="3">
<li><p>RAID的优点<br> (1)可靠性高。<br>(2)磁盘I/O速度高。<br>(3)性能/价格比高。</p>
</li>
<li><p>磁盘访问时间由寻道时间 Ts、旋转延迟时间 Tr、传输时间 Tt 这三部分组成。 </p>
<p>（1）Ts 是启动磁臂时间 s 与磁头移动 n 条磁道的时间和，即 Ts = m × n + s。 </p>
<p>（2） Tr 是指定扇区移动到磁头下面所经历的时间。 硬盘 15000r/min 时 Tr 为 2ms;软盘 300 或 600r/min 时 Tr 为 50~100ms。</p>
<p>（3）Tt 是指数据从磁盘读出或向磁盘写入经历的时间。Tt 的大小与每次读/写的字节 数 b 和旋转速度有关：Tt = b/rN。</p>
</li>
</ol>
<h1 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h1><h2 id="文件、记录和数据项"><a href="#文件、记录和数据项" class="headerlink" title="文件、记录和数据项"></a>文件、记录和数据项</h2><p>文件:具有文件名的一组相关元素的集合<br>记录:一组有意义的数据项的集合<br>数据项:描述一个对象在某方面的属性</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101203114.png" alt="image-20201218101203114"></p>
<p>文件除了文件名之外，还包括:文件类型、文件长度、物理位置、建立时间等主要属性。</p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101300199.png" alt="image-20201218101300199"></p>
<h2 id="文件系统模型"><a href="#文件系统模型" class="headerlink" title="文件系统模型"></a>文件系统模型</h2><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101315444.png" alt="image-20201218101315444"></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101326902.png" alt="image-20201218101326902"></p>
<h1 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h1><h2 id="文件逻辑结构的类型"><a href="#文件逻辑结构的类型" class="headerlink" title="文件逻辑结构的类型"></a>文件逻辑结构的类型</h2><p>通常，将文件的逻辑结构分为两大类:<br>1.有结构文件.</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101510849.png" alt="image-20201218101510849"></p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101531847.png" alt="image-20201218101531847"></p>
<p>2.无结构文件</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101553779.png" alt="image-20201218101553779"></p>
<h2 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h2><ol>
<li><p>逻辑记录的排序</p>
<table>
<thead>
<tr>
<th>排序类型</th>
<th>顺序</th>
<th>查找算法</th>
</tr>
</thead>
<tbody><tr>
<td>串结构</td>
<td>存入时间有序</td>
<td>顺序查找</td>
</tr>
<tr>
<td>顺序结构</td>
<td>关键字有序(如字母顺序等)</td>
<td>高效算法(折半,插值,跳步)</td>
</tr>
</tbody></table>
</li>
<li><p>对顺序文件的读/写操作<br>对于定长记录(记录长L)的文件，在读一个文件时，可设置一个指针Rptr为当前记录的逻辑地址的首地址，通过Rptr+=L,确定下一条记录的逻辑地址。同样，在写文件时，通过Wptr+=L, 确定下一条记录的逻辑地址。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101953069.png" alt="image-20201218101953069"></p>
</li>
<li><p>顺序文件的优缺点<br>优点:<br>在对记录进行批量存取时，效率最高。<br>缺点:<br>在交互应用时，如果增加或删除一个记录时，性能较差。</p>
</li>
</ol>
<h2 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h2><p>对于变长记录的顺序文件，可设置一个读写指针，加上每条记录的长度，确定下一条记录的逻辑地址。针对变长记录的顺序文件，由于记录长度不同，只能顺序读取，故引入索引文件。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218102128191.png" alt="image-20201218102128191"></p>
<p>组织方法:<br>为变长记录文件建立索引表，包括每个记录的索引号、长度、及指向该记录的指针。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218102214393.png" alt="image-20201218102214393"></p>
<p>(1) 优点:在对索引文件检索时，首先检索索引表。由于索引表本身是一个定长记录的顺序文件，可利用折半查找法去检索索引表，从中找到相应的表项，通过表项指针，方便地对主文件中的记录实现直接存取。<br>(2)缺点:索引文件除了主文件外，还须配置一个索引表，在索引表中，每个记录都要有一个索引项，因此提高了存储费用。</p>
<h2 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h2><p>索引顺序文件，是顺序文件、索引文件上述两种文件构成方式的结合。<br>其所有记录按顺序方式组织，首先，将所有记录分为若干个组;然后，为主文件建立一张索引表，在索引表中为每组中的第一个记录建立一个索引项。</p>
<p>在索引顺序文件进行检索时，首先根据提供的关键字，检索索引表，找到该记录所在记录组中、第一个记录的表项，从而得到该记录组第一个记录在主文件中的位置;然后，再利用顺序查找法，去查找主文件，从中找到所要求的记录。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218103634556.png" alt="image-20201218103634556"></p>
<h2 id="直接文件和哈希文件"><a href="#直接文件和哈希文件" class="headerlink" title="直接文件和哈希文件"></a>直接文件和哈希文件</h2><ol>
<li>直接文件<br>根据给定的记录键值直接获得指定记录的物理地址，称为键值转换。</li>
<li>哈希文件<br>利用Hash函数，将记录键值转换为相应记录的地址。</li>
</ol>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218103741370.png" alt="image-20201218103741370"></p>
<h1 id="外存分配方式"><a href="#外存分配方式" class="headerlink" title="外存分配方式"></a>外存分配方式</h1><h2 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h2><ol>
<li>连续分配方式要求为每一个文件分配一组相邻接的盘块,将逻辑文件中的记录，顺序地存储到邻接的物理盘块中，这样形成的文件称为顺序文件结构。<br>在文件目录中，需要记录文件第一个记录所在盘块号、及文件长度。<br>文件空间的分配与回收算法，与内存的动态分区分配算法相似。</li>
<li>连续分配方式的优缺点<br>优点:<br>顺序访问速度快。<br>缺点:<br>(1)要求有连续的存储空间;<br>(2)必须事先知道文件的长度;<br>(3)不能灵活地删除和插入记录。</li>
</ol>
<h2 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h2><ul>
<li><p>连接文件:为文件<font color='red'>分配多个不连续的盘块</font>,在通过每个盘块上的链接指针,将同属于一个文件的多个离散盘块,链接成一个链表.</p>
<ul>
<li>(1)采用离散分配方式,消除了外部碎片;</li>
<li>(2)能满足文件的动态增长的需要,无需事先知道文件的大小;</li>
<li>(3)对插入,删除和修改记录比较容易.</li>
</ul>
</li>
<li><p>隐式链接</p>
<ul>
<li><p>在文件目录的每个目录项中,都必须含有指向链接文件的第一个盘块和最后一个盘块的指针.</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218110559712.png" alt="image-20201218110559712"></p>
</li>
<li><p>隐式链接的分配方式提高了外存的利用率,但存在以下问题:</p>
<p>(1)只适合于顺序访问,不适合随机访问:例如:但访问文件所在的第i个盘块时,必须先读出文件的第一个盘块第二个盘块…就这样顺序的查找.直到第i个盘块.</p>
<p>(2)可靠性差.只要有一个指针出现问题,就会导致整个链断开.</p>
</li>
</ul>
</li>
<li><p>显式连接</p>
<ul>
<li><p>把用于连接文件的各物理块的指针,显式地存放在内存的文件分配表中.</p>
</li>
<li><p>在整个磁盘中,仅设置一张文件分配表FAT,表的序号是物理块号,从0开始,每个文件的物理地址,即文件存放的第一个盘块,可指向文件分配表相对应的盘块号.</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218111246819.png" alt="image-20201218111246819"></p>
</li>
</ul>
</li>
</ul>
<h2 id="FAT和NTFS技术"><a href="#FAT和NTFS技术" class="headerlink" title="FAT和NTFS技术"></a>FAT和NTFS技术</h2><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218111303009.png" alt="image-20201218111303009"></p>
<ul>
<li>早期的MS-DOS，采用FAT12文件系统:<br>(1) FAT表占用的存储空间。对于1.2MB软盘， 每个盘块大小为512B，FAT中共有2.4K个表项(1.2MB/512B) ; 每个表项占12位(1.5B) ，故FAT表占用3.6KB的存储空间(<code>2.4K*1.5B</code>) 。<br>(2)最大磁盘容量。FAT表最多允许212=4096个表项，假设每个盘块为512B,则每个磁盘分区的容量为2MB(4096*512B)。一个物理磁盘支持4个逻辑分区,磁盘的最大容量为8MB。<br>(3)簇是一组连续的扇区，在盘块分配时，当不以盘块为单位、以簇为基本单位时，可适应大容量磁盘的需要。假设一个簇包含两个扇区时，磁盘的最大容量为16MB;当一个簇包含8个扇区时，磁盘的最大容量为64MB。随着磁盘容量的增加，簇内碎片成倍增加。<br>(4)只能支持8+3格式的文件名。</li>
</ul>
<h2 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h2><ol>
<li><p>单级索引分配<br>为**<em>每个文件分配一个索引块**</em>，再把分配给该文件的所有盘块号都记录在该索引块中。</p>
<p>在文件的目录项中包含指向该索引块的指针。</p>
</li>
</ol>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218115916162.png" alt="image-20201218115916162"></p>
<ul>
<li>优点:单级索引分配方式支持直接访问。如:当读文件的第i个盘块时，可以方便地从索引块中找到第i个盘块号。</li>
<li>缺点:当文件只需要1-2个盘块时，仍需为之分配一个索引块，索引块的利用率很低。</li>
</ul>
<ol start="2">
<li>多级索引分配<ul>
<li>大文件需占据多个索引块，通过链指针将各索引块按序链接起来。</li>
<li>索引块较多时，可继续为索引块建立索引。即系统再分配一个索引块，将一级索引的索引块，如第一块、第二块…等索引块的盘块号填入到此索引表中，形成两级索引方式。</li>
</ul>
</li>
</ol>
<p>(1)如果每个盘块大小为4KB，每个盘块号占4B大小，则一个索引块可放1K个盘块号，单级索引所允许的文件大小为4MB。<br>(2)这样，两级索引可包含的盘块号总数1K* 1K=1M个盘块号，所允许的文件长度为4GB。</p>
<ol start="3">
<li>混合索引分配<br>将多种索引分配方式相结合而形成的一种分配方式<br>(1)直接地址<br>(2)一次间接地址<br>(3)多次间接地址</li>
</ol>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218120457660.png" alt="image-20201218120457660"></p>
<h1 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h1><h2 id="文件控制块和索引结点"><a href="#文件控制块和索引结点" class="headerlink" title="文件控制块和索引结点"></a>文件控制块和索引结点</h2><ol>
<li><p>文件控制块FCB<br>定义:是操作系统用来描述和控制文件的数据结构。</p>
<ul>
<li>每一个文件都有一个文件控制块，文件控制块的有序集合称为文件目录。FCB包含三类信息:<br>(1)基本信息<br>(2)存取控制信息<br>(3)使用信息</li>
</ul>
</li>
<li><p>索引结点<br>UNIX系统中，把文件名和文件描述信息分开，由文件描述信息单独构成索引结点(简称i结点)</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218151931794.png" alt="image-20201218151931794"></p>
</li>
<li><p>磁盘索引结点</p>
<ul>
<li>文件主标识符</li>
<li>文件类型</li>
<li>文件存取权限</li>
<li>文件物理地址</li>
<li>文件长度</li>
<li>文件连接计数</li>
<li>文件存取时间</li>
</ul>
</li>
<li><p>内存索引结点</p>
<ul>
<li>索引结点编号</li>
<li>状态</li>
<li>访问计数</li>
<li>文件系统的逻辑设备号</li>
<li>链接指针</li>
</ul>
</li>
</ol>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h2 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218153351448.png" alt="image-20201218153351448"></p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218153404934.png" alt="image-20201218153404934"></p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218153433550.png" alt="image-20201218153433550"></p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218153450747.png" alt="image-20201218153450747"></p>
<h2 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h2><p>当用户要访问一个文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件的索引结点;然后，根据索引结点中所记录的盘块号，换算出文件在磁盘上的物理位置;最后，通过磁盘驱动程序，将所需文件读入内存。目录查询方式主要有两种:</p>
<p>(1)线性检索法(2) hash方法</p>
<ol>
<li><p>线性检索法<br>在树形目录中，用户提供的文件名是由多个文件分量名组成的路径名，此时需对多级目录进行查找。例如:查找usr/ast/mbox文件的过程。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218153810887.png" alt="image-20201218153810887"></p>
</li>
<li><p>Hash方法<br>若建立了一张Hash索引文件目录，系统利用用户提供的文件名，并将它变换为文件目录的索引值，再利用该索引值到目录中去查找。</p>
</li>
</ol>
<h1 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h1><h2 id="空闲表法和空闲链表法"><a href="#空闲表法和空闲链表法" class="headerlink" title="空闲表法和空闲链表法"></a>空闲表法和空闲链表法</h2><ol>
<li><p>空闲表法<br>(1)空闲表的组织属于连续分配方式，为所有空闲区，建立一张空闲表，每个空闲区对应一个空闲表项，再将所有空闲区按，其起始盘块号递增的次序排列。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218154254156.png" alt="image-20201218154254156"><br>(2)存储空间的分配与回收<br>分配过程:可采用**<em>首次适应算法或最佳适应算法**</em>，顺序地检索空闲表的各表项，直至找到第一个其大小能满足要求的空闲区，再将该盘区分配给用户(进程)，同时修改空闲表。<br>回收过程:同内存回收的方法。<br>(3)特点:属连续分配方式，可减少访问磁盘的I/O频率，适应于文件较小的场合或对换区管理中。</p>
</li>
<li><p>空闲链表法<br>(1) 空闲盘块链<br>将磁盘上的所有空闲区以*<strong>盘块**<em>为单位拉成一条链，其中的每一个盘块都有指向后继盘块的指针。当用户因创建文件请求分配存储空间时，系统从空闲盘块链首开始，依次摘下适当数目的空闲盘块分配给用户。<br>当删除文件时，系统将回收的盘块依次插入到空闲盘块链的末尾。这种方式简单，但</em></strong>磁盘操作次数重复多次***。</p>
<p>(2) 空闲盘区链<br>将磁盘上的所有空闲盘区(<strong>每个盘区可包含若干个盘块</strong>)拉成一条链。在每个盘区上除含有指示下一个空闲盘区的指针外，还有指明本空闲盘区的盘块数。其分配、回收算法与内存的动态分区方式相似，通常采用首次适应算法。</p>
</li>
</ol>
<h2 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h2><ol>
<li><p>位示图<br>将磁盘_上的所有盘块，都有一个二进制位与之对应，可用M*N个位数构成位示图，<code>M*N</code>等 于磁盘的总块数。利用二进制的一位“0”、或者“1”来表示磁盘中一个盘块的使用情况。</p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218154729556.png" alt="image-20201218154729556"></p>
<ul>
<li><p>盘块的分配</p>
<p>(1)顺序扫描位示图,从中找出一个或一组其值为”0”的二进制位( “0”表示空闲时)。<br>(2)将所找到的一个或一组二 进制位,转换成与之相应的盘块号。公式: <code>b=n(i-1)+j</code></p>
<p>(3)修改位示图，令map [i,j] =1。</p>
</li>
<li><p>盘块的回收<br>(1)将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为: <code>i=(b-1)DIV n+1</code> ;<code> j= (b-1)MOD n+1</code><br>(2)修改位示图。令map [i,j] =0。</p>
</li>
</ul>
</li>
</ol>
<h2 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h2><ol>
<li><p>空闲盘块的组织<br>(1) 空闲盘块号栈，用来存放当前可用的一组空闲盘块的盘块号，以及栈中尚有的空闲盘块数N，N有栈顶指针的作用</p>
<p>(2) 文件区中的所有空闲盘块被分成若干个组。<br>(3) 将每一组含有的盘块总数N和该组所有的盘块号记入其**<em>前一组**</em>的第一个盘块的S. free(0) ~S. free (99)中。</p>
<p>(4)将第一组的盘块总数和所有的盘块号记入空闲盘块号栈中，作为当前可供分配的空闲盘块号。</p>
<p>(5) 最末一组只有99个盘块，其盘块号分别记入其前一组的S. free(1) ~S. free (99)中，而在S. free(0)中则存放‘0”,作为空闲盘块链的结束标志。</p>
</li>
</ol>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218155035413.png" alt="image-20201218155035413"></p>
<ol start="2">
<li><p>空闲盘块的分配<br>(1) 检查空闲盘块号栈是否上锁。若未上锁，则从栈顶取出一空闲盘块号将与之对应的盘块分配给用户，然后将栈顶指针下移一格。若该盘块号已是栈底S.free(0)，栈中最后一个可分配的盘块;由于该盘块中记录有下一组可用 的盘块号，须调用磁盘读过程， 将栈底盘块号所对应盘块的内容读入栈中，作为新盘块号栈的内容，并将原栈底对应的盘块分配出去。<br>(2) 然后，分配一相应的缓冲区(作为该盘块的缓冲区)。<br>(3)最后，把栈中的空闲盘块数减1，并返回。</p>
</li>
<li><p>空闲盘块的回收<br>(1)将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加1操作。<br>(2)当栈中空闲盘块号数目已达100时，表示栈已满，便将现有栈中的100个盘块号记入新回收的盘块中，再将其盘块号作为新栈底。</p>
</li>
</ol>
<h1 id="文件的共享与保护"><a href="#文件的共享与保护" class="headerlink" title="文件的共享与保护"></a>文件的共享与保护</h1><h2 id="基于索引结点的文件共享"><a href="#基于索引结点的文件共享" class="headerlink" title="基于索引结点的文件共享"></a>基于索引结点的文件共享</h2><ul>
<li>利用索引结点实现共享<br>利用索引结点，将文件的物理地址、以及其它的文件属性等信息，不再放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。任何用户对文件进行增加、或者修改操作，所引起的相应结点内容的改变，都是其他用户可见的。<br>在索引结点中，还设置一个链接计数count，用于表示链接到本索引结点(即文件)上的用户目录项的数目。</li>
</ul>
<h2 id="利用符号链实现文件共享"><a href="#利用符号链实现文件共享" class="headerlink" title="利用符号链实现文件共享"></a>利用符号链实现文件共享</h2><ul>
<li>思想:允许一个文件或子目录有多个父目录，但其中仅有一个作为主父目录，其它的几个父目录都是通过符号链接方式与之相链接的。</li>
<li>例如:为使B能共享C的一个文件F，可以由系统创建一个LINK类型的同名新文件F，并把该文件放在B的目录中，该新文件的内容只包含了被链接文件的路径名。这种链接方法称为符号链接，新文件中的路径名被称为符号链，当B去读LINK类型的文件时，将被OS截获，OS根据新文件中的路径名，去读那个文件，从而实现用户B对文件的共享。</li>
<li>优点:能够链接任何地方的文件，只需提供该文件所在机器的网络地址、以及该机器中的文件路径即可。</li>
<li>缺点:按路径查找进行访问，可能需要多次的读盘，开销大。允许使用多个不同的名字访问共享文件，因此遍历文件系统时，会重复访问此共享文件。</li>
</ul>
<h2 id="磁盘容错技术"><a href="#磁盘容错技术" class="headerlink" title="磁盘容错技术"></a>磁盘容错技术</h2><ol>
<li>第一级容错技术<br>(1)双份目录和双份文件分配表<br>(2)热修复重定向和写后读校验<ul>
<li>热修复重定向</li>
<li>写后读校验方式</li>
</ul>
</li>
</ol>
<ul>
<li>热修复重定向区:系统将磁盘容量的一部分(如2%-3%)作为热修复重定向区，用于存放当发现磁盘有缺陷时的待写数据，并对写入该区的数据进行登记，以便以后对数据进行访问。</li>
<li>写后读校验方式:为保证数据写入到完好的盘块中，应每次从内存缓冲区向磁盘中写入一个数据块后，又立即从磁盘上读出该数据块，并送至另一个缓冲区中，再将该缓冲区内容、与内存缓冲区保留的数据进行比较。若一致，则写入成功;若不一致，再重写;若重写后仍不一致，认为该盘块有缺陷，此时，便将应写入该盘块的数据，写入到热修复重定向区中。</li>
</ul>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218160729872.png" alt="image-20201218160729872"></p>
<p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218160743925.png" alt="image-20201218160743925"></p>
<h1 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h1><h2 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h2><ul>
<li>用户在终端上键入命令，由终端处理程序接收该命令，并在用户终端屏幕上，以字符方式显示用户输入的命令信息、及命令执行结果。用户在终端 上键入的命令称为命令语言，命令语言以命令为基本单位完成OS特定的功能，可分(1) 为命令行方式、(2)批命令方式。</li>
<li>命令行方式指以行为单位输入和显示不同的命令，是由一组命令动词和参数组成的，具有规定的词法、语法和语义。<br>一般形式为: command argl arg2 … argn</li>
<li>其命令执行是串行的、间断的，当一条命令执行完成后，系统发出新的命令输入提示符，用户继续输入下一条命令。</li>
<li>操作系统支持一种批命令的接口方式，允许用户预先将一系列命令组织在一种称为批命令的文件中，一次建立，多次执行。<br>如: DOS的. BAT文件，UNIX的shell文件等。<br>可减少用户输入命令的次数，节省时间、减少出错概率。</li>
</ul>
<h3 id="联机命令的类型"><a href="#联机命令的类型" class="headerlink" title="联机命令的类型"></a>联机命令的类型</h3><h4 id="系统访问类"><a href="#系统访问类" class="headerlink" title="系统访问类"></a>系统访问类</h4><p>注册命令: Login    /提示用户键入自己的注册名<br>                 Password  /提示用户键入自己的口令</p>
<h4 id="磁盘操作类"><a href="#磁盘操作类" class="headerlink" title="磁盘操作类"></a>磁盘操作类</h4><p>(1)磁盘格式化命令Format<br>(2)复制整个软盘命令Diskcopy。<br>(3)软盘比较命令Diskcomp。<br>(4)备份与恢复命令Backup、Restore</p>
<h4 id="文件操作类"><a href="#文件操作类" class="headerlink" title="文件操作类"></a>文件操作类</h4><p>(1) 显示文件命令type<br>(2) 拷贝文件命令copy<br>(3)文件比较命令comp<br>(4) 重新命名命令Rename<br>(5) 删除文件命令erase</p>
<h4 id="目录操作类"><a href="#目录操作类" class="headerlink" title="目录操作类"></a>目录操作类</h4><p>(1) 建立子目录命令mkdir<br>(2) 显示目录命令dir<br>(3) 删除子目录命令rmdir<br>(4) 显示目录结构命令tree<br>(5) 改变当前目录命令chdir</p>
<h4 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h4><p>(1)输入输出重定向命令<br>(2)管道连接Command1| Command2|…|Commandn<br>(3)过滤命令find/N “erase”</p>
<p>许多操作系统提供了命令的并发执行方式，UNIX系统提供了这种机制，用户可以在命令后面加上“&amp;”号，将该命令放在后台执行。<br>例如:当文件打印时间较长时，可将其作为后台命令处理，以便用户在前台继续键入其它命令，两条命令可并行处理。</p>
<h4 id="特殊字符处理"><a href="#特殊字符处理" class="headerlink" title="特殊字符处理"></a>特殊字符处理</h4><p>(1) 中断字符。许多系统中，利用Break或Delete或Ctrl+C键作为中断字符。<br>(2) 停止上卷字符。许多系统中，是利用Ctrl+S键来停止屏幕上卷的。<br>(3) 恢复上卷字符。许多系统中，利用Ctrl+Q键使停止上卷的屏幕恢复上卷。</p>
<ul>
<li>在联机操作方式下，终端处理程序把用户键入的信息送到键盘缓冲区中保存，当用户键入回车符，便把控制权交给命令解释程序。命令解释程序在屏幕上给出提示符，请用户键入命令，然后读入该命令、识别命令，再转到相应命令处理程序的入口地址，执行该处理程序，并将处理结果送屏幕上显示。若用户键入的命令有错，而命令解释程序未能予以识别，或在执行中间出现问题时，应显示某一出错信息。</li>
</ul>
<h2 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h2><ul>
<li><p>程序接口，又称应用编程接口API (ApplicationProgramming Interface)， 是应用程序同操作系统之间的接口。<br>程序接口是由操作系统提供的所有系统调用所构成的集合。</p>
</li>
<li><p>所谓，系统调用，就是用户在程序中调用操作系统所提供的一些子功能。通过系统调用命令，中断现行程序，转去执行相应的特定系统功能，完成后，又返回到被中断程序，从发出调用命令之后的一条指令继续执行下去。</p>
</li>
<li><p>在程序中执行系统调用或过程调用，虽然都是对某种功能或服务的需求，但两者从调用形式到具体实现都有很大区别。<br>(1)调用形式不同</p>
<p>过程调用使用一般调用指令，其转向地址是固定不变的，包含在跳转语句中;但系统调用中不包含处理程序入口，而仅仅提供功能号，按功能号调用。</p>
<p>(2)被调用代码的位置不同</p>
<p>过程调用是一种静态调用，调用者和被调用代码在同一程序内，经过编译链接后作为目标代码的一部分。当过程升级或修改时，必须重新编译连接。系统调用是一种动态调用，系统调用的处理代码在操作系统中，系统调用处理代码升级或修改时，与调用程序无关。而且，调用程序的长度也大大缩短，减少了调用程序占用的存储空间。</p>
<p>(3)提供方式不同</p>
<p>过程调用往往由编译系统提供，不同编译系统提供的过程可以不同;系统调用由操作系统提供，一旦操作系统设计好，系统调用的功能、种类与数量便固定不变。</p>
<p>(4)调用的实现不同</p>
<p>程序使用一般机器指令(跳转指令)进行过程调用，是在用户态运行的;程序执行系统调用，是通过中断机构来实现，需要从用户态转变到核心态，在管理状态下执行，安全性好。</p>
</li>
<li><p>系统调用的类型</p>
<ol>
<li><p>进程控制类系统调用</p>
<p>(1)创建进程(fork)。<br>(2)终止进程(exit)。<br>(3)等待子进程结束(wait)。<br>(4)执行一个文件(exec)。<br>(5)获得进程ID。<br>(6)获得用户ID。<br>(7)进程暂停(pause)。</p>
</li>
<li><p>文件操纵类系统调用</p>
<p>(1)创建文件(creat)。<br>(2)打开文件(open)。<br>(3)关闭文件(close)。<br>(4)读和写文件read和write。<br>(5)连接和去连接(link和unlink)</p>
</li>
<li><p>进程通信类系统调用</p>
<p>(1)消息机制。<br>(2)共享存储器机制。<br>(3) 信号量机制。</p>
</li>
</ol>
</li>
<li><p>系统调用的实现<br>首先，将处理机状态由用户态转为系统态;由硬件和内核程序进行系统调用的一般性处理，即保护被中断进程的CPU环境，将处理机状态字PSW、程序计数器PC、系统调用号、用户栈指针以及通用寄存器内容等，压入堆栈;将用户定义的参数传送到指定的地方保存起来。其次，分析系统调用类型，转入相应的系统调用处理子程序。最后，在系统调用处理子程序执行完成后，应恢复被中断(或设置新的)进程的CPU现场，使被中断进程( 或新进程)，继续往下执行。</p>
</li>
</ul>
<h2 id="图形接口"><a href="#图形接口" class="headerlink" title="图形接口"></a>图形接口</h2><ul>
<li><p>图形用户界面GUI (Graphical User Interface) 是指采用图形方式显示的计算机操作界面。20世纪80年代苹果公司将图形用户界面引入微机领域，而后微软公司推出了Windows系统，使得GUI被广泛应用于个人计算机平台。与早期计算机使用的命令行相比，图形界面对于用户来说在视觉上更易于接受，用户使用鼠标等输入设备,操纵屏幕上的图标或菜单选项，不需要死记硬背大量的命令，可以通过窗口、菜单等方式，方便地进行操作。</p>
</li>
<li><p>所谓桌面是指整个屏幕空间，即在运行Windows时用户所看到的屏幕。桌面由多个任务共享。<br>桌面上的图标，用于启动应用程序点击图标，可以完成启动程序、显示数据这两个步骤的工作。<br>设置任务栏的目的，是帮助用户快速启动常用的程序，方便地切换当前的程序。</p>
</li>
<li><p>窗口是指屏幕，上的一块矩形区域，每个任务都通过各自的窗口,显示其操作和运行情况。应用程序可通过窗口向用户展示出系统所能提供的各种服务及其需要用户输入的信息;用户可通过窗口中的图标去查看和操纵应用程序或文档。</p>
</li>
<li><p>对话框是一个只包含标题栏、输入框、按钮的临时窗口，主要用途是实现人机对话，即系统可通过对话框提示用户输入与任务有关的信息。</p>
</li>
</ul>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">xu ling yun</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://xly5.gitee.io/2020/12/13/ji-suan-ji-cao-zuo-xi-tong/">https://xly5.gitee.io/2020/12/13/ji-suan-ji-cao-zuo-xi-tong/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">xu ling yun</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">计算机操作系统</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    
        <style>
    .mvaline-card {
        margin: 1.5rem auto;
    }

    .mvaline-card .card-content {
        padding: 20px 20px 5px 20px;
    }
</style>

<div class="card mvaline-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="mvcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/minivaline/MiniValine.js"></script>
<script>
    new MiniValine({
        el: '#mvcomments',
        appId: 'ggbwU6hl4tMe3yV3HhQF1zFk-gzGzoHsz',
        appKey: 'R7VPCb6JeTtvgmwEF4LQFp6l',
        mode: 'DesertsP',
        placeholder: 'Write a Comment',
        pathname: window.location.pathname,
        lang: '',
        adminEmailMd5: 'de8a7aa53d07e6b6bceb45c64027763d',
        tagMeta: ["管理员", "小伙伴", "访客"],
        master: ["de8a7aa53d07e6b6bceb45c64027763d"],
        friends: ["b5bd5d836c7a0091aa8473e79ed4c25e", "adb7d1cd192658a55c0ad22a3309cecf", "3ce1e6c77b4910f1871106cb30dc62b0", "cfce8dc43725cc14ffcd9fb4892d5bfc"],
        math: true,
        md: true,
        enableQQ: false,
        NoRecordIP: false,
        visitor: true,
        maxNest: 6,
        pageSize: 6,
        serverURLs: '',
        emoticonUrl: ["https://cdn.jsdelivr.net/npm/alus@latest", "https://cdn.jsdelivr.net/gh/MiniValine/qq@latest", "https://cdn.jsdelivr.net/gh/MiniValine/Bilibilis@latest", "https://cdn.jsdelivr.net/gh/MiniValine/tieba@latest", "https://cdn.jsdelivr.net/gh/MiniValine/twemoji@latest", "https://cdn.jsdelivr.net/gh/MiniValine/weibo@latest"],
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/12/22/lu-you-gui-hua-yu-kai-fa-fu-xi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="旅游规划与开发复习">
                        
                        <span class="card-title">旅游规划与开发复习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                             9:53:54
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-12-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%E4%B8%8E%E5%BC%80%E5%8F%91/" class="post-category">
                                    旅游规划与开发
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/12/06/windows-kuai-jie-jian/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="windows快捷键">
                        
                        <span class="card-title">windows快捷键</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
Windows+Ctrl+D:创建一个新桌面
Windows+Ctrl+→或者←:切换桌面
Windows+M:全部最小化
Windows+1到9:打开任务栏的应用
Windows+→和←:两个文件半屏查看
Ctrl+Al+Tab:显示当
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-12-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/window/" class="post-category">
                                    window
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/window/">
                        <span class="chip bg-color">window</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5 ,h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5 ,h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="/about" target="_blank">xu ling yun</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">85.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/xly-star" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1067784811@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>




    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1067784811" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1067784811" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
