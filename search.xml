<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Javase(下)</title>
      <link href="2020/11/14/javase-xia/"/>
      <url>2020/11/14/javase-xia/</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ol><li>每个线程，拥有自己独立的：<strong>栈、程序计数器</strong></li><li>多个线程，共享同一个进程中的结构：<strong>方法区、堆</strong>。</li><li>一个Java应用程序<code>java.exe</code>，其实至少三个线程：<code>main()主线程</code>，<code>gc()垃圾回收线程</code>，<code>异常处理线程</code>。当然如果发生异常，会影响主线程。</li></ol><h1 id="Thread类中的常用的方法"><a href="#Thread类中的常用的方法" class="headerlink" title="Thread类中的常用的方法:"></a>Thread类中的常用的方法:</h1><ul><li><ol><li><code>start()</code>:启动当前线程；调用当前线程的<code>run()</code></li></ol></li><li><ol start="2"><li><code>run()</code>: 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li></ol></li><li><ol start="3"><li><code>currentThread()</code>:静态方法，返回执行当前代码的线程</li></ol></li><li><ol start="4"><li><code>getName()</code>:获取当前线程的名字</li></ol></li><li><ol start="5"><li><code>setName()</code>:设置当前线程的名字</li></ol></li><li><ol start="6"><li><code>yield()</code>:释放当前<code>cpu</code>的执行权</li></ol></li><li><ol start="7"><li><code>join()</code>:在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</li></ol></li><li><ol start="8"><li><code>stop()</code>:已过时。当执行此方法时，强制结束当前线程。</li></ol></li><li><ol start="9"><li><code>sleep(long millitime)</code>:让当前线程“睡眠”指定的<code>millitime</code>毫秒。在指定的<code>millitime</code>毫秒时间内，当前线程是阻塞状态。</li></ol></li><li><ol start="10"><li><code>isAlive()</code>:判断当前线程是否存活</li></ol></li></ul><h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><ul><li><p><code>MAX_PRIORITY：10</code></p></li><li><p><code>MIN _PRIORITY：1</code></p></li><li><p><code>NORM_PRIORITY：5 </code> –&gt;默认优先级</p></li></ul><ol><li><p>如何获取和设置当前线程的优先级：</p><ul><li>  <code>getPriority()</code>:获取线程的优先级</li><li>  <code>setPriority(int p)</code>:设置线程的优先级</li></ul></li><li><p>说明：高优先级的线程要抢占低优先级线程<code>cpu</code>的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p></li></ol><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><pre><code>public class ThreadPool &#123;    public static void main(String[] args) &#123;        //1. 提供指定线程数量的线程池        ExecutorService service = Executors.newFixedThreadPool(10);        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;        //设置线程池的属性//        System.out.println(service.getClass());//        service1.setCorePoolSize(15);//        service1.setKeepAliveTime();        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象        service.execute(new NumberThread());//适合适用于Runnable        service.execute(new NumberThread1());//适合适用于Runnable//        service.submit(Callable callable);//适合使用于Callable        //3.关闭连接池        service.shutdown();    &#125;&#125;</code></pre><h1 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h1><ol><li>当对字符串重新赋值时，需要重写指定内存区域赋值，<strong>不能使用原有的value进行赋值</strong>。</li><li>当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，<strong>不能使用原有的value进行赋值</strong>。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，<strong>不能使用原有的value进行赋值</strong>。</li></ol><h1 id="字符串拼接方式赋值的对比"><a href="#字符串拼接方式赋值的对比" class="headerlink" title="字符串拼接方式赋值的对比"></a>字符串拼接方式赋值的对比</h1><ol><li>常量与常量的拼接结果在<strong>常量池</strong>。且常量池中不会存在相同内容的常量。</li><li>只要其中一个是变量，结果就在<strong>堆</strong>中。</li><li>如果拼接的结果调用<code>intern()</code>方法，返回值就在<strong>常量池</strong>中</li></ol><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><pre><code> @Test    public void test3()&#123;        HashSet set = new HashSet();        Person p1 = new Person(1001,&quot;AA&quot;);        Person p2 = new Person(1002,&quot;BB&quot;);        set.add(p1);        set.add(p2);        System.out.println(set);        p1.name = &quot;CC&quot;;        set.remove(p1);//因为p1.name的值变为CC然后哈希值也就不一样了在对应哈希值位置没有元素所以删除失败        System.out.println(set);//输出p1、p2        set.add(new Person(1001,&quot;CC&quot;));//对应哈希值位置没有元素添加成功        System.out.println(set);        set.add(new Person(1001,&quot;AA&quot;));        System.out.println(set);//对应哈希值位置上的值的哈希值与其不匹配所以添加成功    &#125;&#125;</code></pre><p>总结要修改<code>hashSet</code>集合的值需要把该值先<strong>删除</strong>在修改然后<strong>重新添加</strong>不然会出问题</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ol><li><p><strong>静态方法中不能使用类的泛型。</strong></p><pre><code>    public static void show(T orderT)&#123;        System.out.println(orderT);    &#125;//错误</code></pre></li><li><p><strong>泛型方法</strong></p><p>在方法中出现了泛型的结构，<strong>泛型参数与类的泛型参数没任何关系</strong>。<br>换句话说，泛型方法所属的类是不是泛型类都没关系。<br>泛型方法，可以声明为静态的。原因：<strong>泛型参数是在调用方法时确定的。并非在实例化类时确定</strong>。</p><pre><code>public static &lt;E&gt;  List&lt;E&gt; copyFromArrayToList(E[] arr)&#123;    ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();    for(E e : arr)&#123;    list.add(e);    &#125;    return list;&#125;</code></pre></li><li><p><strong>泛型不同的引用不能相互赋值</strong></p><pre><code>@Testpublic void test3()&#123;    ArrayList&lt;String&gt; list1 = null;    ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();    //泛型不同的引用不能相互赋值。    //        list1 = list2;    Person p1 = null;    Person p2 = null;    p1 = p2;</code></pre></li></ol><p>   }</p><pre><code>4. 泛型在继承方面的体现  虽然类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。  补充：类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类5. 通配符：?**类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没关系的，二者共同的父类是：G&lt;?&gt;**</code></pre><pre><code>@Test   public void test3()&#123;       List&lt;Object&gt; list1 = null;       List&lt;String&gt; list2 = null;       List&lt;?&gt; list = null;       list = list1;       list = list2;       //编译通过</code></pre><p>   //        print(list1);<br>   //        print(list2);</p><pre><code>       //       List&lt;String&gt; list3 = new ArrayList&lt;&gt;();       list3.add(&quot;AA&quot;);       list3.add(&quot;BB&quot;);       list3.add(&quot;CC&quot;);       list = list3;       //添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。       //除了添加null之外。</code></pre><p>   //        list.add(“DD”);<br>   //        list.add(‘?’);</p><pre><code>       list.add(null);       //获取(读取)：允许读取数据，读取的数据类型为Object。       Object o = list.get(0);       System.out.println(o);   &#125;</code></pre><pre><code>6. 有限制条件的通配符的使用*  ? extends A:                  ***G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类**** ? super A:                  ***G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类***例子：</code></pre><pre><code>   @Test   public void test4()&#123;       List&lt;? extends Person&gt; list1 = null;       List&lt;? super Person&gt; list2 = null;       List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;();       List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;();       List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;();       list1 = list3;       list1 = list4;</code></pre><p>   //        list1 = list5;</p><p>   //           list2 = list3;<br>           list2 = list4;<br>           list2 = list5;</p><pre><code>       //读取数据：       list1 = list3;       Person p = list1.get(0);       //编译不通过       //Student s = list1.get(0);       list2 = list4;       Object obj = list2.get(0);       ////编译不通过</code></pre><p>   //        Person obj = list2.get(0);</p><pre><code>       //写入数据：       //编译不通过</code></pre><p>   //        list1.add(new Student());              </p><pre><code>       //编译通过       list2.add(new Person());       list2.add(new Student());   &#125;    </code></pre><pre><code># BufferedReader和BufferedWriter</code></pre><p>@Test<br>    public void testBufferedReaderBufferedWriter(){<br>        BufferedReader br = null;<br>        BufferedWriter bw = null;<br>        try {<br>            //创建文件和相应的流<br>            br = new BufferedReader(new FileReader(new File(“dbcp.txt”)));<br>            bw = new BufferedWriter(new FileWriter(new File(“dbcp1.txt”)));</p><pre><code>        //读写操作        //方式一：使用char[]数组</code></pre><p>//            char[] cbuf = new char[1024];<br>//            int len;<br>//            while((len = br.read(cbuf)) != -1){<br>//                bw.write(cbuf,0,len);<br>//    //            bw.flush();<br>//            }</p><pre><code>        //方式二：使用String        String data;        while((data = br.readLine()) != null)&#123;            //方法一：</code></pre><p>//                bw.write(data + “\n”);//data中不包含换行符<br>                //方法二：<br>                bw.write(data);//data中不包含换行符<br>                bw.newLine();//提供换行的操作</p><pre><code>        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        //关闭资源        if(bw != null)&#123;            try &#123;                bw.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if(br != null)&#123;            try &#123;                br.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><pre><code># 修改默认的输入和输出行为System类的`setIn(InputStream is)` / `setOut(PrintStream ps)`方式重新指定输入和输出的流。# 获取运行时类的带泛型的父类的泛型</code></pre><pre><code>@Testpublic void test4()&#123;    Class clazz = Person.class;    Type genericSuperclass = clazz.getGenericSuperclass();    ParameterizedType paramType = (ParameterizedType) genericSuperclass;    //获取泛型类型    Type[] actualTypeArguments = paramType.getActualTypeArguments();</code></pre><p>//        System.out.println(actualTypeArguments[0].getTypeName());<br>        System.out.println(((Class)actualTypeArguments[0]).getName());<br>    }</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE小知识</title>
      <link href="2020/11/13/javase-xiao-zhi-shi/"/>
      <url>2020/11/13/javase-xiao-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ol><li><p>？+= ？ 和？ = ？+ ？区别？</p><ul><li><pre><code>short s1 = 10;//s1 = s1 + 2;//编译失败,2是int型,需要short型s1 += 2;//结论：不会改变变量本身的数据类型</code></pre></li></ul></li></ol><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><ol><li><pre><code>//区分&amp; 与 &amp;&amp;    //相同点1：&amp; 与  &amp;&amp; 的运算结果相同    //相同点2：当符号左边是true时，二者都会执行符号右边的运算    //不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。    //开发中，推荐使用&amp;&amp;</code></pre></li><li><pre><code>// 区分：| 与 ||     //相同点1：| 与  || 的运算结果相同    //相同点2：当符号左边是false时，二者都会执行符号右边的运算    //不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算    //开发中，推荐使用||</code></pre></li></ol><h1 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h1><ol><li><p>你能否写出最高效的2 * 8的实现方式？<br>答案：2 &lt;&lt; 3  或  8 &lt;&lt; 1相当于(2*2^3)</p></li><li><pre><code>1. 位运算符操作的都是整型的数据2. &lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2   &gt;&gt; :在一定范围内，每向右移1位，相当于 / 2</code></pre></li></ol><h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><ol><li><pre><code>① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。  当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构  末尾结束为止。② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构③ switch结构中的表达式，只能是如下的6种数据类型之一：   byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)④ case 之后只能声明常量。不能声明范围。⑤ break关键字是可选的。⑥ default:相当于if-else结构中的else.    default结构是可选的，而且位置是灵活的。3.如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。4.break在switch-case中是可选的</code></pre></li></ol><h1 id="跳出多重循环"><a href="#跳出多重循环" class="headerlink" title="跳出多重循环"></a>跳出多重循环</h1><ol><li><pre><code>label:for（i=0;i&lt;10;i++）   for(j=0;j&lt;4;j++)    if(j%4==0)         break label;跳出多重循环；label:for（i=0;i&lt;10;i++）   for(j=0;j&lt;4;j++)    if(j%4==0)         continue label;</code></pre></li></ol><h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><ol><li><pre><code>import java.util.Scanner;class ScannerTest&#123;    public static void main(String[] args)&#123;        //2.Scanner的实例化        Scanner scan = new Scanner(System.in);        //3.调用Scanner类的相关方法        System.out.println(&quot;请输入你的姓名：&quot;);        String name = scan.next();        System.out.println(name);        System.out.println(&quot;请输入你的芳龄：&quot;);        int age = scan.nextInt();        System.out.println(age);        System.out.println(&quot;请输入你的体重：&quot;);        double weight = scan.nextDouble();        System.out.println(weight);        System.out.println(&quot;你是否相中我了呢？(true/false)&quot;);        boolean isLove = scan.nextBoolean();        System.out.println(isLove);        //对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串        System.out.println(&quot;请输入你的性别：(男/女)&quot;);        String gender = scan.next();//&quot;男&quot;        char genderChar = gender.charAt(0);//获取索引为0位置上的字符        System.out.println(genderChar);        &#125;&#125;</code></pre></li></ol><h1 id="数组默认初始化化值"><a href="#数组默认初始化化值" class="headerlink" title="数组默认初始化化值"></a>数组默认初始化化值</h1><ol><li><p>一维数组元素的默认初始化值</p><pre><code>&gt; 数组元素是整型：0&gt; 数组元素是浮点型：0.0&gt; 数组元素是char型：0或&#39;\u0000&#39;，而非&#39;0&#39;&gt; 数组元素是boolean型：false&gt; 数组元素是引用数据类型：null</code></pre></li><li><p>二维数组元素的默认初始化值</p><pre><code> *     规定：二维数组分为外层数组的元素，内层数组的元素 *         int[][] arr = new int[4][3]; *         外层元素：arr[0],arr[1]等 *         内层元素：arr[0][0],arr[1][2]等 *  *   ⑤ 数组元素的默认初始化值  *   针对于初始化方式一：比如：int[][] arr = new int[4][3]; *      外层元素的初始化值为：地址值 *      内层元素的初始化值为：与一维数组初始化情况相同 *       *   针对于初始化方式二：比如：int[][] arr = new int[4][]; *       外层元素的初始化值为：null *      内层元素的初始化值为：不能调用，否则报错NullPointException。</code></pre></li></ol><h1 id="对象默认初始值"><a href="#对象默认初始值" class="headerlink" title="对象默认初始值"></a>对象默认初始值</h1><ul><li><ol><li>默认初始化值的情况：</li></ol><p>属性：类的属性，根据其类型，都默认初始化值。</p><p>整型（byte、short、int、long：0）</p><p>浮点型（float、double：0.0）</p><p>字符型（char：0  （或’\u0000’））</p><p>布尔型（boolean：false）</p><p>引用数据类型（类、数组、接口：null）</p></li></ul><p>   局部变量：没默认初始化值。</p><p>   意味着，我们在调用局部变量之前，一定要显式赋值。</p><p>   特别地：形参在调用时，我们赋值即可。</p><ul><li><p>2.4 在内存中加载的位置：</p><p>属性：加载到堆空间中   （非static）</p><p><strong>局部变量：加载到栈空间</strong></p></li></ul><h1 id="this调用构造器"><a href="#this调用构造器" class="headerlink" title="this调用构造器"></a>this调用构造器</h1><ol><li><pre><code>① 我们在类的构造器中，可以显式的使用&quot;this(形参列表)&quot;方式，调用本类中指定的其他构造器② 构造器中不能通过&quot;this(形参列表)&quot;方式调用自己③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了&quot;this(形参列表)&quot;④ 规定：&quot;this(形参列表)&quot;必须声明在当前构造器的首行⑤ 构造器内部，最多只能声明一个&quot;this(形参列表)&quot;，用来调用其他的构造器</code></pre></li></ol><h1 id="super调用构造器"><a href="#super调用构造器" class="headerlink" title="super调用构造器"></a>super调用构造器</h1><ol><li><pre><code>1. 我们可以在子类的构造器中显式的使用&quot;super(形参列表)&quot;的方式，调用父类中声明的指定的构造器2. &quot;super(形参列表)&quot;的使用，必须声明在子类构造器的首行！3. 我们在类的构造器中，针对于&quot;this(形参列表)&quot;或&quot;super(形参列表)&quot;只能二一，不能同时出现4. 在构造器的首行，没显式的声明&quot;this(形参列表)&quot;或&quot;super(形参列表)&quot;，则默认调用的是父类中空参的构造器：super()5. 在类的多个构造器中，至少一个类的构造器中使用了&quot;super(形参列表)&quot;，调用父类中的构造器</code></pre></li></ol><h1 id="import的使用："><a href="#import的使用：" class="headerlink" title="import的使用："></a>import的使用：</h1><ol><li><pre><code>import:导入 * 1. 在源文件中显式的使用import结构导入指定包下的类、接口 * 2. 声明在包的声明和类的声明之间 * 3. 如果需要导入多个结构，则并列写出即可 * 4. 可以使用&quot;xxx.*&quot;的方式，表示可以导入xxx包下的所结构 * 5. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 * 6. 如果使用的类或接口是本包下定义的，则可以省略import结构 * 7. 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。 * 8. 使用&quot;xxx.*&quot;方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 *  * 9. import static:导入指定类或接口中的静态结构:属性或方法。 </code></pre><h1 id="重写的规则"><a href="#重写的规则" class="headerlink" title="重写的规则"></a>重写的规则</h1><ol><li><p>方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{</p><p>​                                    //方法体</p><p>​                        }</p><ul><li><pre><code>    约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</code></pre></li><li><pre><code>    ① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</code></pre></li><li>② 子类重写的方法的权限修饰符<strong>不小于</strong>父类被重写的方法的权限修饰符</li></ul><p>​      <strong>特殊情况：子类不能重写父类中声明为private权限的方法</strong></p><ul><li>③ 返回值类型：</li></ul><p>​     父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</p><p>​     <strong>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</strong></p><p>​     父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型     (必须也是double)</p><ul><li>④ 子类重写的方法抛出的异常类型<strong>不大于</strong>父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）</li></ul><hr><ul><li>   子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写)。    </li></ul></li></ol></li></ol><h1 id="：运算符"><a href="#：运算符" class="headerlink" title="== ：运算符"></a>== ：运算符</h1><ul><li><ol><li>可以使用在基本数据类型变量和引用数据类型变量中</li></ol></li><li><ol start="2"><li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（<strong>不一定类型要相同</strong>）</p><p>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p></li></ol></li></ul><ul><li>补充： == 符号使用时，必须保证符号左右两边的变量类型一致<strong>引用类型</strong>。</li></ul><h1 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h1><ol><li><p>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：</p><ul><li><p><strong>由父及子，静态先行。</strong></p></li><li><p>result: </p><pre><code>B父类 A子类this is B’s static block!this is A’s static block!this is B’ static not block!this is B’s constructor!this is A’ static not block!this is A’s constructor</code></pre></li></ul></li></ol><h1 id="属性赋值顺序"><a href="#属性赋值顺序" class="headerlink" title="属性赋值顺序"></a>属性赋值顺序</h1><pre><code> * ①默认初始化 * ②显式初始化/⑤在代码块中赋值 * ③构造器中初始化 * ④有了对象以后，可以通过&quot;对象.属性&quot;或&quot;对象.方法&quot;的方式，进行赋值 *   * 执行的先后顺序：① - ② / ⑤ - ③ - ④</code></pre><h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><ol><li><p>可以用来修饰：类、方法</p></li><li><p>具体的：<br>抽象类,就像是向别人声明:我能赚大钱<br>实例化就是具体的行动<br>因为抽象类只是个声明,而没有计划,也不知道怎么赚钱<br>所以我们是不会投资给钱(内存)他的,就算投资他他也不能做任何事<br>为了保存大家的利益,没有具休的赚钱计划不能让他执行<br>abstract修饰类：抽象类</p><ul><li>   此类不能实例化<ul><li><pre><code> **抽象类中一定有构造器**，便于子类实例化时调用（涉及：子类对象实例化的全过程,子类会调用父类的构造器）</code></pre></li><li><pre><code> 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 ---&gt;抽象的使用前提：继承性</code></pre></li></ul></li></ul></li><li><p>abstract修饰方法：抽象方法</p><ul><li><pre><code>    抽象方法只方法的声明，没方法体</code></pre></li><li><pre><code>    **包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。**</code></pre></li><li><pre><code>   若子类重写了父类中的所的抽象方法后，此子类方可实例化</code></pre></li><li><pre><code>    若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</code></pre></li></ul></li><li><p>注意点：</p><ul><li><pre><code>    abstract不能用来修饰：属性、构造器等结构</code></pre></li><li><pre><code>    abstract不能用来修饰私方法、静态方法、final的方法、final的类（**静态方法不能被重写**）</code></pre></li></ul></li></ol><h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><ol><li><p> 接口使用interface来定义</p></li><li><p>Java中，接口和类是并列的两个结构</p></li><li><p>如何定义接口：定义接口中的成员</p><ol><li><code>JDK7</code>及以前：只能定义全局常量和抽象方法</li><li>全局常量：<code>public static final</code>的.但是书写时，可以<strong>省略不写</strong></li><li>抽象方法：<code>public abstract</code>的</li><li><code> JDK8</code>：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li></ol></li><li><p><strong>接口中不能定义构造器的！</strong>意味着接口不可以实例化</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p><ul><li>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</li><li>如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</li></ul></li><li><p>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性</p><ul><li>格式：<code>class AA extends BB implements CC,DD,EE</code></li></ul></li><li><p><strong>接口与接口之间可以继承，而且可以多继承</strong>(可以多继承（extends），不能实现（implement）)</p><hr></li><li><p>接口的具体使用，体现多态性</p></li><li><p>接口，实际上可以看做是一种规范</p></li></ol><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ul><li>体会1：使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，<strong>延迟到运行时出现</strong>。</li><li>体会2：开发中，由于运行时异常比较常见，所以我们通常就<strong>不针对运行时异常编写</strong>try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github搜索</title>
      <link href="2020/11/12/github-sou-suo/"/>
      <url>2020/11/12/github-sou-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="github搜索命令"><a href="#github搜索命令" class="headerlink" title="github搜索命令"></a>github搜索命令</h1><h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p>redis in:name,description,readme</p><ul><li>搜索在名字，描述，readme中有redis的项目（可选）</li></ul><p>redis in:name</p><ul><li>搜索在名字中有redis的项目（可选）</li></ul><h2 id="starts-和-forks"><a href="#starts-和-forks" class="headerlink" title="starts 和 forks"></a>starts 和 forks</h2><p>redis stars:&gt;=1000 forks:&gt;=5000</p><ul><li>搜索点赞大于等于1000 和 fork大于等于5000的项目</li></ul><p>redis stars:100..5000 forks:100..5000</p><ul><li>搜索点赞在100到5000 和 fork 在100到5000的项目</li></ul><h2 id="awesome"><a href="#awesome" class="headerlink" title="awesome"></a>awesome</h2><p>awesome redis</p><ul><li>搜索出该关键字的精品教程</li></ul><h2 id="L"><a href="#L" class="headerlink" title="#L"></a>#L</h2><p>在网站地址后面加上#L数字-L数字，可高亮显示代码</p><p>例如：</p><p><a href="https://github.com/redis/redis/blob/unstable/deps/hiredis/async.h#L13-L30">https://github.com/redis/redis/blob/unstable/deps/hiredis/async.h#L13-L30</a></p><p>表示从13行到30行高亮显示</p><h2 id="T搜索"><a href="#T搜索" class="headerlink" title="T搜索"></a>T搜索</h2><p>在项目中按字母小T可以把文件排列出来好找</p><h2 id="查看附件活跃用户"><a href="#查看附件活跃用户" class="headerlink" title="查看附件活跃用户"></a>查看附件活跃用户</h2><p>location:zhangzhou language:java</p><p>可以查看附件活跃的用户</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux查看资源占用命令</title>
      <link href="2020/11/12/linux-cha-kan-zi-yuan-zhan-yong-ming-ling/"/>
      <url>2020/11/12/linux-cha-kan-zi-yuan-zhan-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="生产环境出现cpu占用过高-怎么定位"><a href="#生产环境出现cpu占用过高-怎么定位" class="headerlink" title="生产环境出现cpu占用过高,怎么定位"></a>生产环境出现<code>cpu</code>占用过高,怎么定位</h1><h2 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估:"></a>性能评估:</h2><ul><li>整机: <code>top</code> 或者 uptime系统性能命令的精简版</li><li><code>cpu</code>:<code>vmstat -n 2 3</code>: 输出三次每两秒一次</li><li>内存:<code>free -h</code></li><li>磁盘:<code>df -h</code>:h:human </li><li>磁盘io:<code>iostat -xdk 2 3</code> </li><li>网络io:<code>ifstat</code></li></ul><h2 id="cpu占用过高的分析思路"><a href="#cpu占用过高的分析思路" class="headerlink" title="cpu占用过高的分析思路"></a>cpu占用过高的分析思路</h2><ol><li>先用<code>top</code>命令找到cpu占比最高的</li><li><code>ps -ef</code>或者jps进一步定位,得知是怎样一个后台程序给我们惹事</li><li>定位到具体线程或者代码<code>ps -mp 进程 -o THREAD,tid,time</code>: tid线程id<ol><li>m:显示所有线程</li><li>p:pid进程使用cpu时间</li><li>o:该参数后是用户自定义格式</li></ol></li><li>将线程id转换为16进程，字母小写</li><li>jstack 进程id|grep tid（16进制字母小写） -A60</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七大垃圾收集器</title>
      <link href="2020/11/11/qi-da-la-ji-shou-ji-qi/"/>
      <url>2020/11/11/qi-da-la-ji-shou-ji-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="四大主要的垃圾收集器"><a href="#四大主要的垃圾收集器" class="headerlink" title="四大主要的垃圾收集器"></a>四大主要的垃圾收集器</h1><p><img src="/medias/GC/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="垃圾收集器" title="垃圾收集器"></p><ol><li><p>Serial:串行垃圾收集器,是单线程的垃圾收集器,会暂停所有用户线程<code>STW</code>(Stop The World),所以不适合服务器环境使用</p></li><li><p>Parallel:并行垃圾收集器(默认),是多线程的垃圾收集器,会暂停所有用户线程<code>STW</code>(Stop The World),比串行回收速度快</p></li><li><p><code>CMS</code>(Concurrent Mark Sweep):并发标记清除垃圾收集器,用户线程和垃圾收集器线程同时执行(不一定是并行,可能交替执行),不需要用户线程停顿,互联网公司多用它,适用对响应时间有要求的场景</p></li><li><p><code>G1</code>:把需要<code>GC</code>的地方分为一个一个小块</p></li></ol><h1 id="七大垃圾回收器"><a href="#七大垃圾回收器" class="headerlink" title="七大垃圾回收器"></a>七大垃圾回收器</h1><ol><li><p><code>UseSerialGC</code></p></li><li><p><code>UseSerialOldGc</code>:淘汰了</p></li><li><p><code>UseeParallelGC</code></p></li><li><p><code>UseConcMarkSweepGC</code></p></li><li><p><code>UseParNewGC</code></p></li><li><p><code>UseParallelOldGC</code></p></li><li><p><code>UseG1GC</code></p><p><code>java -XX:+PrintCommandLineFlags -version</code>:查看默认<code>GC</code></p><p><code>jps -l</code>:查看进程号</p><p><code>jinfo -flag UseSerialGC 进程号</code>:查看该进程是否使用串行垃圾回收器</p></li></ol><p><img src="/medias/GC/%E4%B8%83%E5%A4%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BD%BF%E7%94%A8%E5%9C%B0.png" alt="七大垃圾收集器使用地" title="七大垃圾收集器使用地"></p><p><img src="/medias/GC/%E4%B8%83%E5%A4%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="七大垃圾收集器" title="七大垃圾收集器"></p><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ol><li><code>DefNew</code>:Default New Generation(<code>UseSerialGC</code>)</li><li><code>Tenured</code>:Old(<code>UseSerialOldGC</code>)</li><li><code>ParNew</code>:Parallel  New Generation(<code>UseParNewGC</code>)</li><li><code>PSYoungGen</code>:Parallel Scavenge(<code>UseeParallelGC</code>)</li><li><code>ParOldGen</code>:Parallel Old Generation(<code>UseParallelOldGC</code>)</li></ol><h2 id="GC之Seriial收集器"><a href="#GC之Seriial收集器" class="headerlink" title="GC之Seriial收集器"></a>GC之Seriial收集器</h2><p>代码例子(在<code>vm option</code>上配置<code>-Xms10m -Xmx10m -XX:+UseSerialGC -XX:+PrintGCDetails</code>)：</p><pre><code>public class HelloGC &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;**********HelloGC&quot;);        byte[] bytes = new byte[30 * 1024 * 1024];    &#125;&#125;</code></pre><p>result:<code>DefNew</code>(<code>UseSerialGC</code>)<code>Tenured</code>(<code>UseSerialOldGC</code>)在新生代单线程垃圾回收,老年代单线程垃圾回收,新生代复制算法,老年代标记-整理算法</p><pre><code>**********HelloGC[GC (Allocation Failure) [DefNew: 1810K-&gt;320K(3072K), 0.0014614 secs][Tenured: 321K-&gt;640K(6848K), 0.0016918 secs] 1810K-&gt;640K(9920K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0032163 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [Tenured: 640K-&gt;622K(6848K), 0.0016333 secs] 640K-&gt;622K(9920K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0016594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation   total 3072K, used 76K [0x00000000ff600000, 0x00000000ff950000, 0x00000000ff950000)  eden space 2752K,   2% used [0x00000000ff600000, 0x00000000ff613248, 0x00000000ff8b0000)  from space 320K,   0% used [0x00000000ff900000, 0x00000000ff900000, 0x00000000ff950000)  to   space 320K,   0% used [0x00000000ff8b0000, 0x00000000ff8b0000, 0x00000000ff900000) tenured generation   total 6848K, used 622K [0x00000000ff950000, 0x0000000100000000, 0x0000000100000000)   the space 6848K,   9% used [0x00000000ff950000, 0x00000000ff9eb9f0, 0x00000000ff9eba00, 0x0000000100000000) Metaspace       used 3258K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.gc.HelloGC.main(HelloGC.java:11)</code></pre><h2 id="GC之ParNew收集器"><a href="#GC之ParNew收集器" class="headerlink" title="GC之ParNew收集器"></a>GC之ParNew收集器</h2><p>代码例子(在<code>vm option</code>上配置<code>-Xms10m -Xmx10m -XX:+UseParNewGC -XX:+PrintGCDetails</code>)：</p><p><code>ParNew</code>(<code>UseParNewGC</code>)<code>Tenured</code>(<code>UseSerialOldGC</code>)在新生代多线程垃圾回收,老年代单线程垃圾回收,新生代复制算法,老年代标记-整理算法</p><pre><code>**********HelloGC[GC (Allocation Failure) [ParNew: 1810K-&gt;320K(3072K), 0.0006521 secs][Tenured: 313K-&gt;629K(6848K), 0.0017193 secs] 1810K-&gt;629K(9920K), [Metaspace: 3211K-&gt;3211K(1056768K)], 0.0024309 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [Tenured: 629K-&gt;597K(6848K), 0.0015012 secs] 629K-&gt;597K(9920K), [Metaspace: 3211K-&gt;3211K(1056768K)], 0.0015256 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap par new generation   total 3072K, used 123K [0x00000000ff600000, 0x00000000ff950000, 0x00000000ff950000)  eden space 2752K,   4% used [0x00000000ff600000, 0x00000000ff61ef90, 0x00000000ff8b0000)  from space 320K,   0% used [0x00000000ff900000, 0x00000000ff900000, 0x00000000ff950000)  to   space 320K,   0% used [0x00000000ff8b0000, 0x00000000ff8b0000, 0x00000000ff900000) tenured generation   total 6848K, used 597K [0x00000000ff950000, 0x0000000100000000, 0x0000000100000000)   the space 6848K,   8% used [0x00000000ff950000, 0x00000000ff9e5788, 0x00000000ff9e5800, 0x0000000100000000) Metaspace       used 3258K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.gc.HelloGC.main(HelloGC.java:11)</code></pre><h2 id="GC之Parallel收集器"><a href="#GC之Parallel收集器" class="headerlink" title="GC之Parallel收集器"></a>GC之Parallel收集器</h2><p>代码示例(在<code>vm option</code>上配置<code>-Xms10m -Xmx10m -XX:+UseParallelGC -XX:+PrintGCDetails</code>)：</p><p><code>Parallel Scavenge</code>是类似与1<code>ParNew</code>也是一个新生代垃圾收集器.使用复制算法也是一个并行的多线程的垃圾收集器,俗称吞吐量优先收集器</p><p><img src="/medias/GC/Parallel.png" alt="Parallel" title="Parallel"></p><p><code>PSYoungGen</code>(<code>UseeParallelGC</code>)<code>ParOldGen</code>(<code>UseParallelOldGC</code>)在新生代多线程垃圾回收,老年代多线程垃圾回收,新生代复制算法,老年代标记-整理算法</p><pre><code>**********HelloGC[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;512K(2560K)] 2048K-&gt;716K(9728K), 0.0068775 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 512K-&gt;480K(2560K)] 716K-&gt;708K(9728K), 0.0045273 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (Allocation Failure) [PSYoungGen: 480K-&gt;0K(2560K)] [ParOldGen: 228K-&gt;682K(7168K)] 708K-&gt;682K(9728K), [Metaspace: 3058K-&gt;3058K(1056768K)], 0.0239250 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 682K-&gt;682K(9728K), 0.0113502 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 682K-&gt;666K(7168K)] 682K-&gt;666K(9728K), [Metaspace: 3058K-&gt;3058K(1056768K)], 0.0181336 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] Heap PSYoungGen      total 2560K, used 101K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)  eden space 2048K, 4% used [0x00000000ffd00000,0x00000000ffd196a8,0x00000000fff00000)  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen       total 7168K, used 666K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)  object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a6a58,0x00000000ffd00000) Metaspace       used 3091K, capacity 4556K, committed 4864K, reserved 1056768K  class space    used 327K, capacity 392K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.gc.HelloGC.main(HelloGC.java:11)</code></pre><h2 id="GC之ParallelOld收集器"><a href="#GC之ParallelOld收集器" class="headerlink" title="GC之ParallelOld收集器"></a>GC之ParallelOld收集器</h2><p>与GC的Parallel一样</p><h2 id="GC之CMS收集器"><a href="#GC之CMS收集器" class="headerlink" title="GC之CMS收集器"></a>GC之CMS收集器</h2><p>是一种以获取最短回收停顿时间为目标的收集器,适合互联网站或者B/S系统的服务器上,这类应用尤其重视服务器的响应速度,,希望系统的停顿时间最短.CMS非常适合堆内存大,<code>cpu</code>核心数多的服务器端应用,也是<code>G1</code>出现前大型应用的首选收集器</p><p><img src="/medias/GC/CMS.png" alt="CMS" title="CMS"></p><p>并发标记清除收集器的组合是 <code>ParNew</code>+<code>CMS</code>+<code>Serial Old</code></p><p>并发收集低停顿,并发指和用户线程一起执行</p><p>开启该GC收集器的参数 <code>-XX:+UseConcMarkSweepGC</code> 开启该参数后会自动将<code>-XX:+UseParNewGC</code>打开</p><p>开启该参数后,使用ParNew(Young区用) + CMS(Old区用) + Serial Old (备份),,Serial Old将作为CMS出错后的后备收集器</p><p><code> -Xms10m -Xmx10m -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails</code></p><h3 id="CMS四步过程"><a href="#CMS四步过程" class="headerlink" title="CMS四步过程"></a>CMS四步过程</h3><ul><li>初始标记(CMS initial Mark)</li><li>并发标记(CMS concurrent mark) 和用户线程一起</li><li>重新标记(CMS remark)</li><li>并发清除(CMS concurrent sweep) 和用户线程一起</li></ul><p><img src="/medias/GC/CMS%E6%A0%87%E8%AE%B0%E5%9B%9B%E6%AD%A5.png" alt="CMS标记四步" title="CMS标记四步"></p><ul><li><p>优点:并发收集低停顿</p></li><li><p>缺点:由于并发进行,CMS在收集与应用线程会同时增加堆内存的占用,<strong>也就是说,CMS必须要在老年代堆内存用尽之前完成垃圾回收,否则CMS回收失败时</strong>,将触发担保机制,串行老年代收集器将会以STW的方式进行一次GC.从而造成较大的停顿时间,</p><p>并发执行对<code>cpu</code>资源压力大,    采用标记清除算法会导致大量内存碎片</p><p>代码示例(<code>-Xms10m -Xmx10m -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails</code>):</p><pre><code>public class HelloGC &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;**********HelloGC&quot;);//        byte[] bytes = new byte[30 * 1024 * 1024];        String str = &quot;XU&quot;;        try &#123;            while (true)&#123;                str += new Random().nextInt(11111111) + new Random().nextInt(4545455);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;        &#125;    &#125;&#125;</code></pre><p>result:</p><pre><code>[GC (CMS Initial Mark) [1 CMS-initial-mark: 6153K(6848K)] 6587K(9920K), 0.0001189 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-mark-start][CMS-concurrent-mark: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-preclean-start][CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [ParNew: 2963K-&gt;293K(3072K), 0.0005385 secs] 9116K-&gt;6447K(9920K), 0.0005712 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (CMS Final Remark) [YG occupancy: 591 K (3072 K)][Rescan (parallel) , 0.0001756 secs][weak refs processing, 0.0000061 secs][class unloading, 0.0002227 secs][scrub symbol table, 0.0003613 secs][scrub string table, 0.0001051 secs][1 CMS-remark: 6154K(6848K)] 6745K(9920K), 0.0009344 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-sweep-start][CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-reset-start][CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </code></pre></li></ul><h2 id="GC之Serial-Old收集器"><a href="#GC之Serial-Old收集器" class="headerlink" title="GC之Serial Old收集器"></a>GC之Serial Old收集器</h2><p>Serial Old 是Serial 垃圾收集器的老年代版本,已经废弃</p><h1 id="垃圾回收器的选择"><a href="#垃圾回收器的选择" class="headerlink" title="垃圾回收器的选择"></a>垃圾回收器的选择</h1><ul><li><p>单<code>cpu</code>或小内存,单机程序</p><p><code>-XX:+UseSerialGC</code></p></li><li><p>多<code>cpu</code>,需要大吞吐量,如后台计算型应用</p><p><code>-XX:+UseParallelOldGC</code>或者<code>-XX:+UseParallelGC</code></p></li><li><p>多<code>cpu</code>,追求低停顿时间,需要快速响应的互联网应用</p><p><code>-XX:+UseConcMarkSweepGC</code> <code>-XX:+UseParNewGC</code></p></li></ul><p><img src="/medias/GC/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9.png" alt="垃圾收集器的选择" title="垃圾收集器的选择"></p><h2 id="GC之G1垃圾收集器"><a href="#GC之G1垃圾收集器" class="headerlink" title="GC之G1垃圾收集器"></a>GC之G1垃圾收集器</h2><p><img src="/medias/GC/G1.png" alt="G1" title="G1"></p><ul><li>主要的改变是Eden,Survivor和Tenured等内存不在连续,而是分为一个一个大小一样的region区域</li><li>每个region从1M到32M不等.一个region可能属于Eden,Survivor和Tenured内存区域</li></ul><p><img src="/medias/GC/G1%E7%89%B9%E7%82%B9.png" alt="G1特点" title="G1特点"></p><p><img src="/medias/GC/G1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png" alt="G1底层原理" title="G1底层原理"></p><p>Humongous:大对象</p><p><img src="/medias/GC/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="G1收集器运行示意图" title="G1收集器运行示意图"></p><p><img src="/medias/GC/G1%E5%92%8CCMS%E6%AF%94%E8%BE%83.png" alt="G1和CMS比较" title="G1和CMS比较"></p><p>G1使用需要的参数</p><p><code>-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=100</code>:使用G1+最大内存+设置最大停顿时间</p><p> <code>-XX:MaxGCPauseMillis=100</code>：最大GC的停顿时间单位毫秒，这个是软目标，JVM将尽可能（但不保证）停顿时间小于这个时间</p><p>比起CMS的两个优势：</p><ul><li>G1不会产生内存碎片</li><li>可以精准控制停顿时间。该垃圾收集器是把整个堆(新生代、老年代)划分为多个固定大小的区域，根据每次允许停顿的时间去收集垃圾最多的区域</li></ul><pre><code>[GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0014347 secs]   [Parallel Time: 1.2 ms, GC Workers: 4]      [GC Worker Start (ms): Min: 136.4, Avg: 136.7, Max: 136.9, Diff: 0.5]      [Ext Root Scanning (ms): Min: 0.0, Avg: 0.6, Max: 1.1, Diff: 1.1, Sum: 2.3]      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]      [Object Copy (ms): Min: 0.0, Avg: 0.3, Max: 0.6, Diff: 0.6, Sum: 1.3]      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1]         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]      [GC Worker Total (ms): Min: 0.7, Avg: 0.9, Max: 1.2, Diff: 0.5, Sum: 3.8]      [GC Worker End (ms): Min: 137.6, Avg: 137.6, Max: 137.6, Diff: 0.0]   [Code Root Fixup: 0.0 ms]   [Code Root Purge: 0.0 ms]   [Clear CT: 0.0 ms]   [Other: 0.2 ms]      [Choose CSet: 0.0 ms]      [Ref Proc: 0.1 ms]      [Ref Enq: 0.0 ms]      [Redirty Cards: 0.0 ms]      [Humongous Register: 0.0 ms]      [Humongous Reclaim: 0.0 ms]      [Free CSet: 0.0 ms]   [Eden: 2048.0K(6144.0K)-&gt;0.0B(4096.0K) Survivors: 0.0B-&gt;1024.0K Heap: 1830.3K(10.0M)-&gt;712.1K(10.0M)] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC concurrent-root-region-scan-start][GC pause (G1 Humongous Allocation) (young)[GC concurrent-root-region-scan-end, 0.0004298 secs][GC concurrent-mark-start], 0.0010375 secs]   [Root Region Scan Waiting: 0.2 ms]   [Parallel Time: 0.7 ms, GC Workers: 4]      [GC Worker Start (ms): Min: 138.5, Avg: 138.5, Max: 138.5, Diff: 0.1]      [Ext Root Scanning (ms): Min: 0.1, Avg: 0.2, Max: 0.2, Diff: 0.1, Sum: 0.7]      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]      [Object Copy (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.0, Sum: 1.8]      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]         [Termination Attempts: Min: 1, Avg: 2.8, Max: 4, Diff: 3, Sum: 11]      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]      [GC Worker Total (ms): Min: 0.6, Avg: 0.6, Max: 0.6, Diff: 0.1, Sum: 2.5]      [GC Worker End (ms): Min: 139.1, Avg: 139.1, Max: 139.1, Diff: 0.0]   [Code Root Fixup: 0.0 ms]   [Code Root Purge: 0.0 ms]   [Clear CT: 0.0 ms]   [Other: 0.2 ms]      [Choose CSet: 0.0 ms]      [Ref Proc: 0.1 ms]      [Ref Enq: 0.0 ms]      [Redirty Cards: 0.0 ms]      [Humongous Register: 0.0 ms]      [Humongous Reclaim: 0.0 ms]      [Free CSet: 0.0 ms]   [Eden: 0.0B(4096.0K)-&gt;0.0B(4096.0K) Survivors: 1024.0K-&gt;0.0B Heap: 712.1K(10.0M)-&gt;621.5K(10.0M)] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC concurrent-mark-end, 0.0010623 secs][Full GC (Allocation Failure)  621K-&gt;606K(10M), 0.0019750 secs]   [Eden: 0.0B(4096.0K)-&gt;0.0B(4096.0K) Survivors: 0.0B-&gt;0.0B Heap: 621.5K(10.0M)-&gt;606.9K(10.0M)], [Metaspace: 3195K-&gt;3195K(1056768K)] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure)  606K-&gt;588K(10M), 0.0018673 secs]   [Eden: 0.0B(4096.0K)-&gt;0.0B(4096.0K) Survivors: 0.0B-&gt;0.0B Heap: 606.9K(10.0M)-&gt;588.8K(10.0M)], [Metaspace: 3195K-&gt;3195K(1056768K)] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC remark, 0.0000079 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC concurrent-mark-abort]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.gc.HelloGC.main(HelloGC.java:13)Heap garbage-first heap   total 10240K, used 588K [0x00000000ff600000, 0x00000000ff700050, 0x0000000100000000)  region size 1024K, 1 young (1024K), 0 survivors (0K) Metaspace       used 3259K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p>只有 garbage-first heap 和Metaspace</p>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOM详解</title>
      <link href="2020/11/11/oom-xiang-jie/"/>
      <url>2020/11/11/oom-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的OOM-Out-Of-Memory"><a href="#常见的OOM-Out-Of-Memory" class="headerlink" title="常见的OOM(Out Of Memory)"></a>常见的<code>OOM</code>(Out Of Memory)</h1><ol><li><p><code>java.lang.OutOfMemoryError: Java heap space</code>: <code>java</code>堆溢出</p><p>代码示例(在<code>vm option</code>上设置<code>-Xms10m -Xmx10m</code>堆的最大内存和初始内存都为<code>10m</code>):</p><pre><code>public class JavaHeapSpaceDemo &#123;    public static void main(String[] args) &#123;        //申请30m大对象        byte[] bytes = new byte[30 * 1024 * 1024];        //Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    &#125;&#125;</code></pre><p>result:`Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</p><pre><code>at com.xu.juc.oom.JavaHeapSpaceDemo.main(JavaHeapSpaceDemo.java:9)`</code></pre></li><li><p><code>java.lang.OutOfMemoryError: unable to create new native thread</code>:单个进程创建的线程数达到最大,<code>linux</code>默认是1024</p><p>代码示例:</p><pre><code>public class UnableCreateNewNativeThreadDemo &#123;    public static void main(String[] args) &#123;        int i = 0;        while (true)&#123;            i++;            new Thread(()-&gt;&#123;                 try &#123;                    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);                 &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                 &#125;            &#125;,&quot;t1&quot;).start();            System.out.println(&quot;i=&quot;+i);            //Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread        &#125;    &#125;&#125;</code></pre><p>result:</p><pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread    at java.lang.Thread.start0(Native Method)    at java.lang.Thread.start(Thread.java:717)    at com.xu.juc.oom.UnableCreateNewNativeThreadDemo.main(UnableCreateNewNativeThreadDemo.java:20)</code></pre><p>解决方法:在<code>linux</code>下执行<code>ulimit -u</code>命令查看单进程的最大线程数root用户不限制,需要修改最大线程数</p><p><code>vim /etc/security/limits.d/20-nproc.conf</code> 在末尾加上<code>用户名 soft nproc 需要的线程数</code></p></li><li><p><code>java.lang.OutOfMemoryError: Direct buffer memory</code>:最大直接内存溢出,在<code>JVM</code>堆外的内存,元空间就是在那里,<code>NIO</code>可以在直接内存申请对象,而直接内存不归<code>GC</code>管,没有垃圾回收,所以<code>NIO</code>很容易导致这个异常</p><p>代码示例(在<code>vm option</code>上设置<code>-XX:MaxDirectMemorySize=5m</code>最大直接内存为<code>5m</code>):</p><pre><code>public class DirectBufferMemoryDemo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;配置的MaxDirectMemory： &quot; + (sun.misc.VM.maxDirectMemory()/(double)1024/1024) + &quot;MB&quot;);        try &#123;           TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;           e.printStackTrace();        &#125;        //-XX:MaxDirectMemorySize=5m 我们配置为5MB，但实际使用6MB        ByteBuffer bb = ByteBuffer.allocateDirect(6*1024*1024);        //Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory    &#125;&#125;</code></pre><p>result:</p><pre><code>配置的MaxDirectMemory： 5.0MBException in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory    at java.nio.Bits.reserveMemory(Bits.java:694)    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)    at com.xu.juc.oom.DirectBufferMemoryDemo.main(DirectBufferMemoryDemo.java:19)</code></pre></li></ol><p>4.<code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</code>:元空间内存溢出,静态对象过多</p><p>代码示例(在<code>vm option</code>上设置<code>-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</code>最大元空间内存为<code>10m</code>且需要导入两个jar包<code>asm-2.2.3.jar</code>和<code>cglib-nodep-2.2.2</code>):</p><pre><code>public class MetaspaceSizeDemo &#123;    static class OOMTest &#123;    &#125;    public static void main(String[] args) &#123;        int i = 0;        try &#123;            while (true) &#123;                i++;                Enhancer enhancer = new Enhancer();                enhancer.setSuperclass(OOMTest.class);                enhancer.setUseCache(false);                enhancer.setCallback(new MethodInterceptor() &#123;                    @Override                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;                        return methodProxy.invoke(o, args);                    &#125;                &#125;);                enhancer.create();            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;finally &#123;            System.out.println(&quot;************多少次之后发生了异常：&quot; + i);        &#125;        //Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace    &#125;&#125;</code></pre><p>result:</p><pre><code>************多少次之后发生了异常：345Exception in thread &quot;main&quot; Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;main&quot;</code></pre><ol start="5"><li><p><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>:<code>GC</code>回收时间过长抛出,过长的定义是,超过98%的时间用来<code>GC</code>并且回收了不到2%的堆内存,连续多次<code>GC</code>都只回收了不到2%的极端情况才会抛出,该错误会导致<code>GC</code>清理的一点内存很快就会被再次填满,迫使<code>GC</code>再次执行,形成恶性循环,<code>GC</code>使用率100%但是<code>GC</code>却没有成果</p><p>代码示例(在<code>vm option</code>上设置<code>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code>堆的最大内存和初始内存都为<code>10m</code>最大直接内存为<code>5m</code>):</p><pre><code>public class OverHheadLimitExceededDemo &#123;    public static void main(String[] args) &#123;        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        int  i = 0;        while (true)&#123;            list.add(String.valueOf(++i).intern());        &#125;        //Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded    &#125;&#125;</code></pre><p>result:<code>GC</code>效果不明显</p><pre><code>[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;480K(2560K)] 2048K-&gt;936K(9728K), 0.0013541 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2528K-&gt;497K(2560K)] 2984K-&gt;2637K(9728K), 0.0029600 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2545K-&gt;496K(2560K)] 4685K-&gt;4570K(9728K), 0.0026608 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2544K-&gt;504K(2560K)] 6618K-&gt;6570K(9728K), 0.0027356 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 504K-&gt;0K(2560K)] [ParOldGen: 6066K-&gt;6227K(7168K)] 6570K-&gt;6227K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0532608 secs] [Times: user=0.11 sys=0.00, real=0.05 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;821K(2560K)] [ParOldGen: 6227K-&gt;7034K(7168K)] 8275K-&gt;7856K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0433280 secs] [Times: user=0.08 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;2006K(2560K)] [ParOldGen: 7034K-&gt;7034K(7168K)] 9082K-&gt;9040K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0380094 secs] [Times: user=0.08 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;2047K(2560K)] [ParOldGen: 7034K-&gt;7034K(7168K)] 9082K-&gt;9082K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0271896 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7034K-&gt;7034K(7168K)] 9082K-&gt;9082K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0327770 secs] [Times: user=0.03 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7035K-&gt;7035K(7168K)] 9083K-&gt;9083K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0426577 secs] [Times: user=0.08 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7037K-&gt;7037K(7168K)] 9085K-&gt;9085K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0302575 secs] [Times: user=0.05 sys=0.02, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7039K-&gt;7039K(7168K)] 9087K-&gt;9087K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0286187 secs] [Times: user=0.05 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7041K-&gt;7041K(7168K)] 9089K-&gt;9089K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0273682 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7042K-&gt;7042K(7168K)] 9090K-&gt;9090K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0283171 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7044K-&gt;7044K(7168K)] 9092K-&gt;9092K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0307638 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7046K-&gt;7046K(7168K)] 9094K-&gt;9094K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0278689 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7048K-&gt;7048K(7168K)] 9096K-&gt;9096K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0330232 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7049K-&gt;7049K(7168K)] 9097K-&gt;9097K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0329980 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7051K-&gt;7051K(7168K)] 9099K-&gt;9099K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0330133 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7053K-&gt;7053K(7168K)] 9101K-&gt;9101K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0309811 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7055K-&gt;7055K(7168K)] 9103K-&gt;9103K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0313091 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7056K-&gt;7056K(7168K)] 9104K-&gt;9104K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0320053 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7058K-&gt;7058K(7168K)] 9106K-&gt;9106K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0321824 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7060K-&gt;7060K(7168K)] 9108K-&gt;9108K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0319028 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7062K-&gt;7062K(7168K)] 9110K-&gt;9110K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0301211 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7063K-&gt;7063K(7168K)] 9111K-&gt;9111K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0344197 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7065K-&gt;7065K(7168K)] 9113K-&gt;9113K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0339853 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7067K-&gt;7067K(7168K)] 9115K-&gt;9115K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0362988 secs] [Times: user=0.06 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7069K-&gt;7069K(7168K)] 9117K-&gt;9117K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0304594 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7070K-&gt;7070K(7168K)] 9118K-&gt;9118K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0320628 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7082K-&gt;7077K(7168K)] 9130K-&gt;9125K(9728K), [Metaspace: 3242K-&gt;3242K(1056768K)], 0.0312339 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7080K-&gt;7060K(7168K)] 9128K-&gt;9108K(9728K), [Metaspace: 3245K-&gt;3245K(1056768K)], 0.0404792 secs] [Times: user=0.11 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7062K-&gt;7062K(7168K)] 9110K-&gt;9110K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0328442 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7064K-&gt;7064K(7168K)] 9112K-&gt;9112K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0336342 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7065K-&gt;7065K(7168K)] 9113K-&gt;9113K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0367303 secs] [Times: user=0.11 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7067K-&gt;7067K(7168K)] 9115K-&gt;9115K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0329345 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7069K-&gt;7069K(7168K)] 9117K-&gt;9117K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0322445 secs] [Times: user=0.16 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7071K-&gt;7071K(7168K)] 9119K-&gt;9119K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0324392 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7073K-&gt;7073K(7168K)] 9121K-&gt;9121K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0318748 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7074K-&gt;7074K(7168K)] 9122K-&gt;9122K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0308626 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7076K-&gt;7076K(7168K)] 9124K-&gt;9124K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0388157 secs] [Times: user=0.09 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7081K-&gt;7078K(7168K)] 9129K-&gt;9126K(9728K), [Metaspace: 3251K-&gt;3251K(1056768K)], 0.0312564 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7079K-&gt;7079K(7168K)] 9127K-&gt;9127K(9728K), [Metaspace: 3252K-&gt;3252K(1056768K)], 0.0332782 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7081K-&gt;7081K(7168K)] 9129K-&gt;9129K(9728K), [Metaspace: 3252K-&gt;3252K(1056768K)], 0.0313380 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7083K-&gt;7083K(7168K)] 9131K-&gt;9131K(9728K), [Metaspace: 3252K-&gt;3252K(1056768K)], 0.0302698 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7085K-&gt;7085K(7168K)] 9133K-&gt;9133K(9728K), [Metaspace: 3252K-&gt;3252K(1056768K)], 0.0311400 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7143K-&gt;647K(7168K)] 9191K-&gt;647K(9728K), [Metaspace: 3304K-&gt;3304K(1056768K)], 0.0042610 secs] [Times: user=0.05 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 2560K, used 70K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)  eden space 2048K, 4% used [0x00000000ffd00000,0x00000000ffd15368,0x00000000fff00000)  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen       total 7168K, used 647K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)  object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a1ce0,0x00000000ffd00000) Metaspace       used 3371K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 362K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded    at java.lang.Integer.toString(Integer.java:403)    at java.lang.String.valueOf(String.java:3099)    at com.xu.juc.oom.OverHheadLimitExceededDemo.main(OverHheadLimitExceededDemo.java:15)</code></pre></li><li><p><code>java.lang.StackOverflowError</code>:栈内存溢出</p><p>代码示例:</p><pre><code>public class StackOverFlowErrorDemo &#123;    public static void main(String[] args) &#123;        stackOverFlowError();    &#125;    private static void stackOverFlowError() &#123;        stackOverFlowError();        //Exception in thread &quot;main&quot; java.lang.StackOverflowError    &#125;&#125;</code></pre><p>result:`Exception in thread “main” java.lang.StackOverflowError</p><pre><code>at com.xu.juc.oom.StackOverFlowErrorDemo.stackOverFlowError(StackOverFlowErrorDemo.java:13)`</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> OOM </category>
          
          <category> Exception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCRoot</title>
      <link href="2020/11/10/gcroot/"/>
      <url>2020/11/10/gcroot/</url>
      
        <content type="html"><![CDATA[<p><img src="/medias/GC/GCRoot.png" alt="GCRoot" title="GCRoot"></p><p>软引用一半回收一半不回收，内存满回收，在垃圾回收的灰框内就是回收的引用，外面就是不回收的引用</p><ul><li><p><code>GCRoot</code>:枚举根节点做可达性分析（根搜索路径）</p></li><li><p>Java中可以作为<code>GC Roots</code> 的对象</p><ol><li>虚拟机栈(栈帧中的局部变量区,也叫局部变量)</li><li>方法区中的类静态属性引用对象</li><li>方法区中的常量引用对象</li><li>本地方法栈中的<code>JNI</code>(Native方法)引用的对象</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCRoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四大引用</title>
      <link href="2020/11/10/si-da-yin-yong/"/>
      <url>2020/11/10/si-da-yin-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h1><p>强引用就算<code>oom</code>异常也不会被回收</p><p>例子:</p><pre><code>Object o1 = new Object();Object o2 = o1;o1 = null;System.gc();System.out.println(o2);</code></pre><p>result: <code>java.lang.Object@677327b6</code></p><h1 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h1><p>软引用在内存充足的时候不会被回收,在内存不足的时候回被回收</p><p>内存充足例子:</p><pre><code> Object o1 = new Object(); SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o1); System.out.println(o1); System.out.println(softReference.get()); o1 = null; System.gc(); System.out.println(&quot;==================&quot;); System.out.println(o1); System.out.println(softReference.get());</code></pre><p>result:</p><pre><code>java.lang.Object@677327b6java.lang.Object@677327b6==================nulljava.lang.Object@677327b6</code></pre><p>内存不足例子:(在<code>VM option</code>上加上<code>-Xms10m -Xmx10m</code>设置堆内存大小为<code>10m</code>):</p><pre><code>  Object o1 = new Object();  SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o1);  System.out.println(o1);  System.out.println(softReference.get());  o1 = null;  try &#123;  //申请30m内存  byte[] bytes = new byte[10 * 1024 * 1024];  &#125; catch (Exception e) &#123;  e.printStackTrace();  &#125; finally &#123;  System.out.println(&quot;==================&quot;);  System.out.println(o1);  System.out.println(softReference.get());  &#125;</code></pre><p>result:内存不足软引用被回收</p><pre><code>java.lang.Object@677327b6java.lang.Object@677327b6==================nullnullException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.reference.ReferenceDemo.softReferenceNoMemoryNoOut(ReferenceDemo.java:75)    at com.xu.juc.reference.ReferenceDemo.main(ReferenceDemo.java:38)</code></pre><h1 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h1><p>弱引用一旦发生<code>GC</code>就被回收</p><p>例子:</p><pre><code>Object o1 = new Object();WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(o1);System.out.println(o1);System.out.println(weakReference.get());o1 = null;System.gc();System.out.println(&quot;==================&quot;);System.out.println(o1);System.out.println(weakReference.get());</code></pre><p>result:</p><pre><code>java.lang.Object@677327b6java.lang.Object@677327b6==================nullnull</code></pre><h1 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h1><p>虚引用的get方法总是返回<code>null</code>,虚引用需要和<code>ReferenceQueue</code>同时使用,在虚引用被回收前被回收的对象会被加入引用队列中,用来作为回收前的通知效果</p><p>例子:</p><pre><code>Object o1 = new Object();ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(o1,referenceQueue);System.out.println(o1);System.out.println(phantomReference.get());System.out.println(referenceQueue.poll());o1 = null;System.gc();System.out.println(&quot;==================&quot;);System.out.println(o1);System.out.println(phantomReference.get());System.out.println(referenceQueue.poll());</code></pre><p>result:队列中有被回收的对象,虚引用中的get返回<code>null</code></p><pre><code>java.lang.Object@677327b6nullnull==================nullnulljava.lang.ref.PhantomReference@14ae5a5</code></pre><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a><code>WeakHashMap</code></h1><p><code>WeakHashMap</code>在key值不可用时<code>GC</code>将该key-value回收就是回收（Node）</p><p>例子：</p><pre><code>HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();Integer key = new Integer(1);String value = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);map.put(key, value);System.out.println(map);key = null;System.gc();System.out.println(map);System.out.println(&quot;=======================&quot;);WeakHashMap&lt;Integer, String&gt; weakHashMap = new WeakHashMap&lt;&gt;();Integer key1 = new Integer(1);String value1 = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);weakHashMap.put(key1, value1);System.out.println(weakHashMap);key1 = null;System.gc();System.out.println(weakHashMap);</code></pre><p>result:<code>key</code>为<code>null</code>而map中的值不会变为<code>null</code>,map中的值时存储在<code>Node</code>节点中的</p><pre><code>&#123;1=1c4f08765c6e4417a72ed8b09bc16de8&#125;&#123;1=1c4f08765c6e4417a72ed8b09bc16de8&#125;=======================&#123;1=6d39fb7b374942d98cb186a5c81a1594&#125;&#123;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> -GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引用类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常用基础参数</title>
      <link href="2020/11/09/jvm-chang-yong-ji-chu-can-shu/"/>
      <url>2020/11/09/jvm-chang-yong-ji-chu-can-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM常用参数"><a href="#JVM常用参数" class="headerlink" title="JVM常用参数"></a>JVM常用参数</h1><ul><li><p>-Xms : 初始大小内存,默认为物理内存的 1/64     (等价于<code>-XX:InitialHeapSize</code>)</p></li><li><p>-Xmx : 最大分配内存大小,默认为物理内存的 1/4   (等价于<code>-XX:MaxHeapSize</code>)</p></li><li><p>-Xss : 单个线程的大小,一般默认为 512k~1024k   (等价于<code>-XX:ThreadStackSize</code>) 默认值与平台属性有关在windows中为0 设值 ：  <code>-Xss128k</code>或者<code>-XX:ThreadStackSize=128k</code></p></li><li><p>-Xmn : 设置年轻代大小(一般不动)</p></li><li><p>-XX:MetaspaceSize : 设置元空间的大小 （元空间和永久代类似：最大的区别元空间并不在虚拟机中，而在本地内存，因此元空间仅受限于本地内存）</p></li><li><p>-XX:+PrintGCDetails : 打印GC细节</p><p>示例：</p><pre><code>[GC (Allocation Failure) [PSYoungGen: 1761K-&gt;488K(2560K)] 1761K-&gt;672K(9728K), 0.0021268 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 488K-&gt;488K(2560K)] 672K-&gt;680K(9728K), 0.0007457 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 488K-&gt;0K(2560K)] [ParOldGen: 192K-&gt;634K(7168K)] 680K-&gt;634K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0044222 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 634K-&gt;634K(9728K), 0.0002551 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 634K-&gt;615K(7168K)] 634K-&gt;615K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0046726 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] Heap PSYoungGen      total 2560K, used 57K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0e580,0x00000000fff00000)  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen       total 7168K, used 615K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)  object space 7168K, 8% used [0x00000000ff600000,0x00000000ff699fd0,0x00000000ffd00000) Metaspace       used 3261K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.TestDemo.main(TestDemo.java:35)</code></pre><p><img src="/medias/GC/GC%E8%AF%A6%E8%A7%A3.png" alt="GC详解" title="GC详解"></p><p><img src="/medias/GC/FullGC%E8%AF%A6%E6%83%85.png" alt="FullGC详情" title="FullGC详情"></p></li><li><p>-XX:SurvivorRatio : 新生代 eden和S0，S1空间比例 默认为8:1:1(-XX:SurvivorRatio=8) </p><ul><li><p>假如(-XX:SurvivorRatio=4)   eden和S0，S1空间比例为4:1:1</p><p>例子：默认</p><pre><code>Heap PSYoungGen      total 78336K, used 5574K [0x000000076b380000, 0x0000000770880000, 0x00000007c0000000)  eden space 69632K, 8% used [0x000000076b380000,0x000000076b8f1a08,0x000000076f780000)  from space 8704K, 0% used [0x0000000770000000,0x0000000770000000,0x0000000770880000)  to   space 8704K, 0% used [0x000000076f780000,0x000000076f780000,0x0000000770000000) ParOldGen       total 175104K, used 0K [0x00000006c1a00000, 0x00000006cc500000, 0x000000076b380000)  object space 175104K, 0% used [0x00000006c1a00000,0x00000006c1a00000,0x00000006cc500000) Metaspace       used 3140K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 341K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p>-XX:SurvivorRatio=4</p><pre><code>Heap PSYoungGen      total 72704K, used 4676K [0x000000076b380000, 0x0000000770880000, 0x00000007c0000000)  eden space 58368K, 8% used [0x000000076b380000,0x000000076b8113a8,0x000000076ec80000)  from space 14336K, 0% used [0x000000076fa80000,0x000000076fa80000,0x0000000770880000)  to   space 14336K, 0% used [0x000000076ec80000,0x000000076ec80000,0x000000076fa80000) ParOldGen       total 175104K, used 0K [0x00000006c1a00000, 0x00000006cc500000, 0x000000076b380000)  object space 175104K, 0% used [0x00000006c1a00000,0x00000006c1a00000,0x00000006cc500000) Metaspace       used 3125K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 337K, capacity 388K, committed 512K, reserved 1048576K</code></pre></li></ul></li><li><p>-XX:NewRatio : 配置老年代和年轻代在堆结构中的比例 默认（-XX:NewRatio=2）新生代占1老年代占2 </p><ul><li><p>假如（-XX:NewRatio=4） 新生代占1 老年代占4</p><p>例子：默认</p><pre><code> PSYoungGen      total 76288K, used 5247K [0x000000076b380000, 0x0000000770880000, 0x00000007c0000000)  eden space 65536K, 8% used [0x000000076b380000,0x000000076b89ff60,0x000000076f380000)  from space 10752K, 0% used [0x000000076fe00000,0x000000076fe00000,0x0000000770880000)  to   space 10752K, 0% used [0x000000076f380000,0x000000076f380000,0x000000076fe00000) ParOldGen       total 175104K, used 0K [0x00000006c1a00000, 0x00000006cc500000, 0x000000076b380000)  object space 175104K, 0% used [0x00000006c1a00000,0x00000006c1a00000,0x00000006cc500000) Metaspace       used 3078K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 332K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p>（-XX:NewRatio=4）</p><pre><code>Heap PSYoungGen      total 46080K, used 4002K [0x000000078d200000, 0x0000000790500000, 0x00000007c0000000)  eden space 39936K, 10% used [0x000000078d200000,0x000000078d5e8828,0x000000078f900000)  from space 6144K, 0% used [0x000000078ff00000,0x000000078ff00000,0x0000000790500000)  to   space 6144K, 0% used [0x000000078f900000,0x000000078f900000,0x000000078ff00000) ParOldGen       total 209920K, used 0K [0x00000006c1a00000, 0x00000006ce700000, 0x000000078d200000)  object space 209920K, 0% used [0x00000006c1a00000,0x00000006c1a00000,0x00000006ce700000) Metaspace       used 3237K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</code></pre></li></ul></li></ul><ul><li><p>-XX:MaxTenuringThreshold : 设置垃圾最大年龄也就是几次GC后到老年代</p><ul><li><p>最大15（JDK8时）</p><pre><code>Error: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit.MaxTenuringThreshold of 18 is invalid; must be between 0 and 15</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM参数</title>
      <link href="2020/11/09/jvm-can-shu/"/>
      <url>2020/11/09/jvm-can-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的三个参数类型"><a href="#JVM的三个参数类型" class="headerlink" title="JVM的三个参数类型"></a>JVM的三个参数类型</h1><h2 id="JVM的标配参数"><a href="#JVM的标配参数" class="headerlink" title="JVM的标配参数"></a>JVM的标配参数</h2><ol><li><p>java -version</p></li><li><p>java -help</p></li><li><p>java -showversion</p><p>没有随着版本变化变化</p></li></ol><h2 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h2><ol><li>-Xint: 解释执行</li><li>-Xcomp:第一次使用就编译成本地代码</li><li>-Xmixed(默认):混合模式</li></ol><h2 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h2><h3 id="Boolean类型的XX参数"><a href="#Boolean类型的XX参数" class="headerlink" title="Boolean类型的XX参数"></a>Boolean类型的XX参数</h3><p>-XX:+或者-某个属性值(+代表开启-代表关闭)</p><ul><li>jps -l : 查看java程序的进程号</li><li>jstack 进程号 : 可以查看某个进程号的运行情况,检查死锁</li><li>jinfo -flag PrintDGDetails 进程号:查看是否开启打印GC细节 ;   jinfo -flag  UseSerialGC 3000:是否使用串行垃圾收集器</li><li>jinfo -flags 进程号: 可以查看JVM的一些基本参数值</li></ul><h3 id="KV型XX参数"><a href="#KV型XX参数" class="headerlink" title="KV型XX参数"></a>KV型XX参数</h3><p>-XX:属性key=属性值value</p><ul><li><p>jinfo -flag MetaspaceSize 进程号: 查看元空间大小            result: -XX:MetaspaceSize=536870912(修改过),在vm option上写入了</p><p>-XX:+PrintGCDetails -XX:MetaspaceSize=512m</p></li><li><p>jinfo -flag MaxTenuringThreshold 进程号：到达多少次GC可以进入养老区（默认15）</p></li><li><p>java -XX:+PrintFlagsInitial: 查看JVM参数的初始值</p></li><li><p>java -XX:+PrintFlagsFinal -version(或 .class文件名)：查看JVM最终参数 （=的是为修改的参数 :=是修改过的参数）相当于在运行时打开了打印最终参数的命令 可以写入多个XX参数 <strong>实际上就是运行java命令然后可以加上一些XX参数</strong></p></li><li><p>java -XX:+PrintCommandLineFlags -version(或 .class文件名)： 查看一些基本的JVM参数值，<strong>主要是为了查看使用的GC垃圾收集器是什么</strong></p></li></ul><p><strong>提示</strong></p><ul><li>-Xms：是-XX:InitialHeapSize的缩写</li><li>-Xmx：是-XX:MaxHeapSize的缩写</li><li>所以他们两个参数是XX型参数（这两个值一般设为一样在生产环境，防止GC次数多）在很多情况下，-Xms和-Xmx设置成一样的。这么设置，是因为当Heap不够用时，会发生内存抖动，影响程序运行稳定性</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor初体验</title>
      <link href="2020/11/07/threadpoolexecutor-chu-ti-yan/"/>
      <url>2020/11/07/threadpoolexecutor-chu-ti-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="创建线程池的五个方法"><a href="#创建线程池的五个方法" class="headerlink" title="创建线程池的五个方法"></a>创建线程池的五个方法</h1><ul><li><p><code>ExecutorService threadPool = Executors.newFixedThreadPool(2);</code>:创建固定数线程池,但是其阻塞队列是<code>new LinkedBlockingQueue&lt;Runnable&gt;()</code>有<code>(Integer.MAX_VALUE)</code>大</p><ol><li><p>主要特点如下:<br>1.1 创建一个定长线程池,可控制线程的最大并发数,超出的线程会在队列中等待.</p><p>1.2 <code>newFixedThreadPool</code>创建的线程池<code>corePoolSize</code>和<code>MaxmumPoolSize</code>是 相等的,它使用的的<code>LinkedBlockingQueue</code></p></li></ol></li></ul><p>代码示例:</p><pre><code>ExecutorService threadPool = Executors.newFixedThreadPool(2);        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //不能再循环中关闭线程池不然抛出默认拒绝策略的异常            threadPool.shutdown();        &#125;</code></pre><ul><li><code>Executors.newSingleThreadExecutor();</code>:创建单一线程,但是其阻塞队列是<code>new LinkedBlockingQueue&lt;Runnable&gt;()</code>有<code>(Integer.MAX_VALUE)</code>大<ol><li>主要特点如下:<br>1.1 创建一个单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务都按照指定顺序执行.<br>1.2 <code>newSingleThreadExecutor</code>将<code>corePoolSize</code>和<code>MaxmumPoolSize</code>都设置为1,它使用的的<code>LinkedBlockingQueue</code></li></ol></li></ul><p>代码示例:</p><pre><code>ExecutorService threadPool = Executors.newSingleThreadExecutor();        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre><ul><li><p><code>ExecutorService threadPool = Executors.newCachedThreadPool();</code>:创建可变线程数，虽然其阻塞队列是<code>SynchronousQueue</code>，但是其<code>MaxmumPoolSize</code>为<code>(Integer.MAX_VALUE)</code></p><ol><li>主要特点如下:<br>1.1 创建一个可缓存线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则创建新线程.<br>1.2 <code>newCachedThreadPool</code>将<code>corePoolSize</code>设置为0,<code>MaxmumPoolSize</code>设置为<code>Integer.MAX_VALUE</code>,它使用的是<code>SynchronousQUeue</code>,也就是说来了任务就创建线程运行,如果线程空闲超过60秒,就销毁线程</li></ol></li></ul><p>代码示例:</p><pre><code>ExecutorService threadPool = Executors.newCachedThreadPool();        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre><ul><li><p><code>Executors.newWorkStealingPool</code>:java8新增,使用目前机器上可以的处理器作为他的并发级别</p><ul><li><img src="/medias/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="线程池" title="线程池"></li></ul></li><li><p><code>手写线程池</code>:</p><ul><li><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.AbortPolicy());</code></pre><p>工作使用!</p></li></ul></li></ul><h1 id="线程池七大参数"><a href="#线程池七大参数" class="headerlink" title="线程池七大参数"></a>线程池七大参数</h1><ol><li><p><code>corePoolSize</code>:线程池常驻的核心线程数</p></li><li><p><code>maximumPoolSize</code>:线程池能够容纳同时执行的最大线程数,此值大于等于1</p></li><li><p><code>keepAliveTime</code>:多余空闲线程的存活时间,当空闲时间达到<code>keepAliveTime</code>值时,多余的线程会被销毁知道只剩下<code>corePoolSize</code>个线程为止</p></li><li><p><code>unit</code>:<code>keepAliveTime</code>的单位</p></li><li><p><code>workQueue</code>:任务队列,被提交但尚未被执行的任务</p></li><li><p><code>threadFactory</code>:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般使用默认即可</p></li><li><p><code>handler</code>:拒接策略,表示当前线程队列满了并且工作线程大于等于线程池最大线程数<code>maximumPoolSize</code>时如何来拒绝</p><ul><li><p>四大拒绝策略都实现了<code>RejectExecutionHandle</code>接口</p><ol><li><p><code>AbortPolicy(默认)</code>:直接抛出异常<code>RejectedException</code>阻止程序的正常运行</p><p>示例:</p><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.AbortPolicy());        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre><p>result:抛出异常</p><pre><code>pool-1-thread-1    服务1pool-1-thread-1    服务3pool-1-thread-1    服务4pool-1-thread-1    服务5pool-1-thread-2    服务2pool-1-thread-3    服务6pool-1-thread-4    服务7pool-1-thread-5    服务8java.util.concurrent.RejectedExecutionException: Task com.xu.juc.threadpool.TreadPoolDemo$$Lambda$1/1023892928@6d03e736 rejected from java.util.concurrent.ThreadPoolExecutor@568db2f2[Running, pool size = 5, active threads = 5, queued tasks = 3, completed tasks = 0]    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)    at com.xu.juc.threadpool.TreadPoolDemo.main(TreadPoolDemo.java:21)</code></pre></li></ol></li></ul></li></ol><ol start="2"><li><p><code>CallerRunPolicy</code>:”调用者执行”一直调用机制,该策略既不会抛弃任务,也不会抛出异常,而是让发起请求者调用</p><p>示例:</p><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.CallerRunsPolicy());        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre></li></ol><p>result:回调使main线程调用方法</p><pre><code> ``` pool-1-thread-1    服务1 main    服务9 main    服务10 pool-1-thread-1    服务3 pool-1-thread-1    服务4 pool-1-thread-1    服务5 pool-1-thread-2    服务2 pool-1-thread-3    服务6 pool-1-thread-4    服务7 pool-1-thread-5    服务8</code></pre><ol start="3"><li><p><code>DiscardOldestPolicy</code>:抛弃任务队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交</p><p>示例:</p><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.DiscardOldestPolicy());        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre></li></ol><p>result:只有八个结果等待最久的两个请求被丢弃</p><pre><code> ``` pool-1-thread-1    服务1 pool-1-thread-2    服务2 pool-1-thread-2    服务5 pool-1-thread-2    服务9 pool-1-thread-2    服务10 pool-1-thread-3    服务6 pool-1-thread-5    服务8 pool-1-thread-4    服务7</code></pre><ol start="4"><li><code>DiscardPolicy</code>:直接丢弃任务,不给予任何处理也不抛出异常.如果允许任务丢失,这是最好的拒绝策略</li></ol><p>示例:</p><pre><code> ``` ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                     5,                                                     1L,                                                     TimeUnit.SECONDS,                                                     new LinkedBlockingQueue&lt;&gt;(3),                                                     Executors.defaultThreadFactory(),                                                     new ThreadPoolExecutor.DiscardPolicy());         try &#123;             for (int i = 0; i &lt; 10; i++) &#123;                 final int tempInt = i;                 threadPool.execute(() -&gt; &#123;                     System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                 &#125;);             &#125;         &#125; catch (Exception e) &#123;             e.printStackTrace();         &#125; finally &#123;             threadPool.shutdown();         &#125;</code></pre><p>result:只有八个请求被服务，后面到的请求直接被抛弃,不给予处理</p><pre><code> pool-1-thread-1    服务1 pool-1-thread-1    服务3 pool-1-thread-1    服务4 pool-1-thread-1    服务5 pool-1-thread-2    服务2 pool-1-thread-4    服务7 pool-1-thread-3    服务6 pool-1-thread-5    服务8</code></pre><p>线程池底层工作原理：</p><ol><li>在创建了线程池后，线程池中的线程数为零。</li><li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<ol><li>如果正在运行的线程数量小于<code>corePoolSize</code>，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于<code>corePoolSize</code>，那么将这个任务放入队列；</li><li>如果这个时候队列满了且正在运行的线程数量还小于<code>maximumPoolSize</code>，那么还是要创建非核心线程立刻运行<strong>这个任务</strong>(不是运行在队列中等待的任务，而是新请求的任务)；</li><li>如果队列满了且正在运行的线程数量大于或等于<code>maximumPoolSize</code>，那么线程池会启动饱和拒绝策略来执行。</li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做超过一定的时间（<code>keepAliveTime</code>）时，线程会判断：<ol><li>如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉。</li><li>所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code>的大小。</li></ol></li></ol><h2 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h2><h2 id="cpu密集型"><a href="#cpu密集型" class="headerlink" title="cpu密集型:"></a><code>cpu</code>密集型:</h2><ul><li><p><code>System.out.println(Runtime.getRuntime().availableProcessors());</code>查看cpu核心数</p><p><code>cpu</code>密集的意思是该任务需要大量的运算,而没有阻塞,<code>cpu</code>一直全速运行.</p><p><code>cpu</code>密集任务只有在真正的多核<code>cpu</code>上才可能得到加速(通过多线程),而在单核<code>cpu</code>上,无论你看多少个模拟的多线程该任务都不可能得到加速,因为<code>cpu</code>总的运算能力就只有那些</p><p><code>cpu</code>密集型任务配置尽可能少的线程数量</p></li><li><p>公式:<code>cpu</code>核心数+1个线程的线程池</p></li></ul><h2 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型:"></a><code>IO</code>密集型:</h2><ol><li><ul><li><p>由于IO密集型任务线程并不是一直在执行任务,则应尽可能配置多线程数</p></li><li><p>公式:<code>cpu</code>核心数*2</p></li></ul></li><li><ul><li><img src="/medias/JUC/IO%E5%AF%86%E9%9B%86%E5%9E%8B.png" alt="IO密集型" title="IO密集型"></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者模式</title>
      <link href="2020/11/07/sheng-chan-zhe-xiao-fei-zhe-mo-shi/"/>
      <url>2020/11/07/sheng-chan-zhe-xiao-fei-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="传统生产者消费者模式"><a href="#传统生产者消费者模式" class="headerlink" title="传统生产者消费者模式"></a>传统生产者消费者模式</h1><pre><code>/** * 共享资源类 */class ShareData &#123;    private int num = 0;    private Lock lock = new ReentrantLock();    private Condition condition = lock.newCondition();    public void increment() throws Exception &#123;        lock.lock();        try &#123;            //判断 防止虚假唤醒使用while            while (num != 0) &#123;                //等待 不生产                condition.await();            &#125;            //干活            num++;            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + num);            //通知唤醒            condition.signalAll();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void deIncrement() throws Exception &#123;        lock.lock();        try &#123;            //判断            while (num == 0) &#123;                //等待 不生产                condition.await();            &#125;            //干活            num--;            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + num);            //通知唤醒            condition.signalAll();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;/** * Description * 一个初始值为0的变量 两个线程交替操作 一个加1 一个减1来5轮 * * @author veliger@163.com * @version 1.0 * @date 2019-04-13 14:01 **/public class ProdConsumerTraditionDemo &#123;    public static void main(String[] args) &#123;        ShareData shareData = new ShareData();        new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 5; i++) &#123;                try &#123;                    shareData.increment();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;AA&quot;).start();        new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 5; i++) &#123;                try &#123;                    shareData.deIncrement();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;BB&quot;).start();    &#125;&#125;</code></pre><p>加锁是可以保证原子性和可见性的：</p><ul><li>JMM（Java Memory Model）中关于<code>synchronized</code>有如下规定，线程加锁时，必须清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取；线程在解锁时，需要把工作内存中最新的共享变量的值写入到主存，以此来保证共享变量的可见性。(ps这里是个泛指，不是说只有在退出synchronized时才同步变量到主存)</li></ul><h1 id="使用阻塞队列的生产者消费者模式"><a href="#使用阻塞队列的生产者消费者模式" class="headerlink" title="使用阻塞队列的生产者消费者模式"></a>使用阻塞队列的生产者消费者模式</h1><ul><li>代码示例:</li></ul><pre><code>import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;class Cake &#123;    private volatile Boolean FLAG = true;    private AtomicInteger atomicInteger = new AtomicInteger();    private BlockingQueue&lt;String&gt; blockingQueue = null;    public Cake(BlockingQueue&lt;String&gt; blockingQueue) &#123;        this.blockingQueue = blockingQueue;    &#125;    public void productCake() throws InterruptedException &#123;        String data = &quot;&quot;;        Boolean resultValue;        while (FLAG) &#123;            //保证原子性 ,线程安全,CAS            data = atomicInteger.incrementAndGet() + &quot;&quot;;            //blockingQueue有加锁线程安全 ,最多就是存入BlockingQueue中的顺序不是按照1,2,3但是不会出错            resultValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);            if (resultValue) &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t 线程生产&quot; + data + &quot;成功&quot;);            &#125;            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(&quot;老板叫停不在生产蛋糕&quot;);    &#125;    public void consumer() throws InterruptedException &#123;        String result = &quot;&quot;;        while (FLAG) &#123;            result = blockingQueue.poll(2L, TimeUnit.SECONDS);            if (result == null || result == &quot;&quot;) &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t 蛋糕超过两秒没有生产出来消费结束&quot;);                FLAG = false;                System.out.println();                System.out.println();                return;            &#125;            System.out.println(Thread.currentThread().getName() + &quot;\t 线程消费&quot; + result + &quot;成功&quot;);            System.out.println();            System.out.println();        &#125;    &#125;    public void stop() &#123;        FLAG = false;    &#125;&#125;/** * 不使用lock和synchronized的生产者消费者模式 * * @author xulingyun * @create 2020-11-06 10:45 */public class ProductAndConsumer &#123;    public static void main(String[] args) &#123;        Cake cake = new Cake(new ArrayBlockingQueue&lt;&gt;(3));        new Thread(() -&gt; &#123;            try &#123;                cake.productCake();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, &quot;product&quot;).start();        new Thread(() -&gt; &#123;            try &#123;                cake.consumer();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, &quot;consumer&quot;).start();        try &#123;            TimeUnit.SECONDS.sleep(5);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        cake.stop();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> 生产者消费者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产者 </tag>
            
            <tag> 消费者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列的使用</title>
      <link href="2020/11/07/zu-sai-dui-lie-de-shi-yong/"/>
      <url>2020/11/07/zu-sai-dui-lie-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="阻塞队列初认识"><a href="#阻塞队列初认识" class="headerlink" title="阻塞队列初认识"></a>阻塞队列初认识</h1><ul><li>当阻塞队列是空时,从队列中获取元素的操作将会被阻塞.</li><li>当阻塞队列是满时,往队列中添加元素的操作将会被阻塞.</li><li>同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞,知道其他线程从队列中移除一个或者多个元素或者全清空队列后使队列重新变得空闲起来并后续新增.</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>在多线程领域:所谓阻塞,在某些情况下会挂起线程(即线程阻塞),一旦条件满足,被挂起的线程优惠被自动唤醒</li><li>为什么需要使用<code>BlockingQueue</code></li><li>好处是我们不需要关心什么时候需要阻塞线程,什么时候需要唤醒线程,因为<code>BlockingQueue</code>都一手给你包办好了</li><li>在concurrent包 发布以前,在多线程环境下,我们每个程序员都必须自己去控制这些细节,尤其还要兼顾效率和线程安全,而这会给我们的程序带来不小的复杂度.</li></ul><p><img src="/medias/JUC/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="阻塞队列" title="阻塞队列"></p><h2 id="阻塞队列的种类及分析"><a href="#阻塞队列的种类及分析" class="headerlink" title="阻塞队列的种类及分析"></a>阻塞队列的种类及分析</h2><pre><code> 1. **` ArrayBlockingQueue`**:由数组结构组成的有界阻塞队列 2. **`LinkedBlockingQueue`**:由链表结构组成的有界阻塞队列(但默认大小是(`Integer.MAX_VALUE`)21亿 3. `PriorityBlockingQueue`:支持优先级排列的无界阻塞队列 4. `DelayQueue`:使用优先级队列实现的延迟无界阻塞队列 5. **`SynchronousQueue`**:不存储元素的阻塞队列，也即是单个元素的阻塞队列(个人定制版) 6. `LinkedTransferQueue`:有链表结构组成的无界阻塞队列 7. `LinkedBlocking`**`Deque`**:由链表结构组成的双向阻塞队列</code></pre><ul><li><strong><code>SynchronousQueue</code></strong>:没有容量与其他<code>BlcokingQueue</code>不同,<code>SynchronousQueue</code>是一个不存储元素的<code>BlcokingQueue</code>每个<code>put</code>操作必须要等待一个<code>take</code>操作,否则不能继续添加元素,反之亦然(只能使用<code>put()</code>,<code>take()</code>和<code>offer(E e, long timeout, TimeUnit unit)</code>,<code>poll(long timeout, TimeUnit unit)</code>，使用其他两组方法是因为没有存储空间直接抛异常或者返回false)</li></ul><pre><code>import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;/** * @author xulingyun * @create 2020-11-06 9:00 */public class BlockingQueueDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        //不能存储元素，个人定制版，只能使用过时不候offer（time），和不见不散put,使用add和offer直接抛异常或者返回false        SynchronousQueue&lt;String&gt; synchronousQueue = new SynchronousQueue&lt;&gt;();        new Thread(()-&gt;&#123;            try &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t put a&quot;);                synchronousQueue.put(&quot;a&quot;);                System.out.println(Thread.currentThread().getName() + &quot;\t put b&quot;);                synchronousQueue.put(&quot;b&quot;);                System.out.println(Thread.currentThread().getName() + &quot;\t put c&quot;);                synchronousQueue.put(&quot;c&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t1&quot;).start();        new Thread(()-&gt;&#123;            try &#123;                try &#123;                   TimeUnit.SECONDS.sleep(3);                &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;\t take&quot;);                System.out.println(synchronousQueue.take());                try &#123;                   TimeUnit.SECONDS.sleep(3);                &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;\t take&quot;);                System.out.println(synchronousQueue.take());                try &#123;                   TimeUnit.SECONDS.sleep(3);                &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;\t take&quot;);                System.out.println(synchronousQueue.take());            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t2&quot;).start();    &#125;    private static void offer2() throws InterruptedException &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        System.out.println(blockingQueue.offer(&quot;a&quot;, 1, TimeUnit.SECONDS));        System.out.println(blockingQueue.offer(&quot;b&quot;, 1, TimeUnit.SECONDS));        System.out.println(blockingQueue.offer(&quot;c&quot;, 1, TimeUnit.SECONDS));        //过时不候        System.out.println(blockingQueue.offer(&quot;d&quot;, 1, TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));    &#125;    private static void offer() &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        System.out.println(blockingQueue.offer(&quot;a&quot;));        System.out.println(blockingQueue.offer(&quot;b&quot;));        System.out.println(blockingQueue.offer(&quot;c&quot;));        System.out.println(blockingQueue.offer(&quot;x&quot;));        System.out.println(blockingQueue.peek());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());    &#125;    private static void take() throws InterruptedException &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        blockingQueue.put(&quot;a&quot;);        blockingQueue.put(&quot;b&quot;);        blockingQueue.put(&quot;c&quot;);        //不见不散 一直阻塞//        blockingQueue.put(&quot;x&quot;);        System.out.println(blockingQueue.take());        System.out.println(blockingQueue.take());        System.out.println(blockingQueue.take());        System.out.println(blockingQueue.take());    &#125;    private static void exception() &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        System.out.println(blockingQueue.add(&quot;a&quot;));        System.out.println(blockingQueue.add(&quot;b&quot;));        System.out.println(blockingQueue.add(&quot;c&quot;));        //队列满抛异常 Queue full//        System.out.println(blockingQueue.add(&quot;x&quot;));        //检查队列头元素        System.out.println(blockingQueue.element());        System.out.println(blockingQueue.remove());        System.out.println(blockingQueue.remove());        System.out.println(blockingQueue.remove());        //队列空报异常NoSuchElementException        System.out.println(blockingQueue.remove());    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> 阻塞队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四种锁的认识</title>
      <link href="2020/11/07/si-chong-suo-de-ren-shi/"/>
      <url>2020/11/07/si-chong-suo-de-ren-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>​        <strong>公平锁：</strong></p><ul><li><p>是指多个线程按照申请锁的顺序来获取锁类似排队打饭 先来后到</p><p><strong>非公平锁：</strong></p></li><li><p>​    是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象</p><p><strong>公平锁/非公平锁</strong></p><ul><li><p>并发包<code>ReentrantLock</code>的创建可以指定构 造函数的boolean类型来得到公平锁或者非公平锁 默认是非公平锁</p></li><li><p><code>ReentrantLock</code>而言,<br>通过构造哈希数指定该锁是否是公平锁 默认是非公平锁 非公平锁的优点在于吞吐量比公平锁大.</p></li></ul></li></ul><pre><code>   对于`synchronized`而言 也是一种非公平锁.</code></pre><p><img src="/medias/JUC/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="公平锁和非公平锁" title="公平锁和非公平锁"></p><h1 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁/递归锁"></a>可重入锁/递归锁</h1><pre><code>*    可重入锁（也叫递归锁），`ReentrantLock`和`Synchronized`都是可重入锁，可重入锁的就是同一线程外层函数获得锁之后内层还有同一个锁可以直接进入而不会陷入死锁，进入内层函数时自动获得锁，**线程可以进入任何一个它已经拥有的锁所同步的代码中**</code></pre><ul><li>可重入锁(也叫做递归锁)<pre><code>* 指的是同一先生外层函数获得锁后,内层敌对函数任然能获取该锁的代码* 在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁* 也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块</code></pre><ul><li>   代码示例：</li></ul></li></ul><pre><code>import java.util.concurrent.locks.ReentrantLock;class ReentrantLockTest&#123;    ReentrantLock lock = new ReentrantLock();    public void method1()&#123;        lock.lock();        try &#123;            System.out.println(&quot;发送短信&quot;);            method2();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void method2()&#123;        lock.lock();        try &#123;            System.out.println(&quot;发送邮箱&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;/** * @author xulingyun * @create 2020-10-30 10:00 */public class LockTest &#123;    public static void main(String[] args) &#123;        ReentrantLockTest reentrantLockTest = new ReentrantLockTest();        reentrantLockTest.method1();    &#125;&#125;</code></pre><ul><li>也可以加多个<code>lock.lock()</code>只要有对应的<code>lock.unlock()</code>即可，不会陷入死锁，要是数量不对应会产生死锁</li></ul><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><pre><code>import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;/** * 手写自旋锁：好处不会阻塞，缺点cpu消耗大 * * @author xulingyun * @create 2020-10-30 10:47 */public class SpinLock &#123;    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();    public void myLock() &#123;        Thread thread = Thread.currentThread();        while (!atomicReference.compareAndSet(null, thread)) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + &quot;线程获得锁!&quot;);    &#125;    public void myUnLock() &#123;        Thread thread = Thread.currentThread();        atomicReference.compareAndSet(thread, null);        System.out.println(Thread.currentThread().getName() + &quot;线程释放锁!&quot;);    &#125;    public static void main(String[] args) &#123;        SpinLock spinLock = new SpinLock();        new Thread(() -&gt; &#123;            spinLock.myLock();            try &#123;                TimeUnit.SECONDS.sleep(5);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            spinLock.myUnLock();        &#125;, &quot;t1&quot;).start();        //主线程睡眠一秒保证t1线程先获得锁        try &#123;            TimeUnit.SECONDS.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        new Thread(() -&gt; &#123;            spinLock.myLock();            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            spinLock.myUnLock();        &#125;, &quot;t2&quot;).start();    &#125;&#125;</code></pre><ul><li>优点：尝试获得锁时不会被阻塞，而是采用循环的方式去尝试获得锁，这样的好处是减少上下文切换消耗的资源。</li><li>缺点：自旋锁虽然减少了上下文切换消耗的资源但是会增加<code>cpu</code>资源的消耗，因为要是某个线程一直在循环尝试获得锁<code>cpu</code>一直在为他消耗性能。</li></ul><h1 id="独占锁-写锁-共享锁-读锁"><a href="#独占锁-写锁-共享锁-读锁" class="headerlink" title="独占锁(写锁)/共享锁(读锁)"></a>独占锁(写锁)/共享锁(读锁)</h1><ul><li>独占锁(写锁) 指该锁一次只能被一个线程所占有,对于<code>ReentrantLock</code>和<code>Synchronized</code>来说都是独占锁</li><li>共享锁(读锁) 指该锁可以被多个线程所共有</li><li>对于<code>ReentrantReadWriteLock</code>其写锁是独占锁，读锁是共享锁</li><li>读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程都是互斥</li></ul><p>代码示例：</p><pre><code>import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantReadWriteLock;class MyCache &#123;    private volatile Map&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();    public void put(String key, Object value) &#123;        rwLock.writeLock().lock();        try &#123;            System.out.println(Thread.currentThread().getName() + &quot;正在写入:&quot; + key);            hashMap.put(key, value);            System.out.println(Thread.currentThread().getName() + &quot;写入完成!&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            rwLock.writeLock().unlock();        &#125;    &#125;    public void get(String key) &#123;        rwLock.readLock().lock();        try &#123;            System.out.println(Thread.currentThread().getName() + &quot;正在读取&quot;);            try &#123;                TimeUnit.MILLISECONDS.sleep(300);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            Object result = hashMap.get(key);            System.out.println(Thread.currentThread().getName() + &quot;读取成功：&quot; + result);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            rwLock.readLock().unlock();        &#125;    &#125;&#125;/** * 读写锁 * 读锁：共享锁 * 写锁：独占锁 * 读读：不排斥 * 读写：排斥 * 写写：排斥 * 写操作 原子+独占 整个过程必须是一个完成的统一整体 中间不允许被分割 被打断 * @author xulingyun * @create 2020-10-30 12:17 */public class ReadWriteLockDemo &#123;    public static void main(String[] args) &#123;        MyCache cache = new MyCache();        for (int i = 0; i &lt; 5; i++) &#123;            final int temp = i;            new Thread(() -&gt; &#123;                cache.put(temp + &quot;&quot;, temp + &quot;&quot;);                cache.get(temp + &quot;&quot;);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公平锁 </tag>
            
            <tag> 非公平锁 </tag>
            
            <tag> 可重入锁 </tag>
            
            <tag> 递归锁 </tag>
            
            <tag> 自旋锁 </tag>
            
            <tag> 独占锁(写锁) </tag>
            
            <tag> 共享锁(读锁) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABA问题</title>
      <link href="2020/10/29/aba-wen-ti/"/>
      <url>2020/10/29/aba-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="ABA问题的产生"><a href="#ABA问题的产生" class="headerlink" title="ABA问题的产生"></a>ABA问题的产生</h1><p><img src="/medias/JUC/ABA%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F.png" alt="ABA问题的产生" title="ABA问题的产生"></p><ul><li><p>解决</p><p>使用原子引用，增加版本（类似与乐观锁）。使用atomic包中的<code>AtomicStampedReference</code>类解决ABA问题，业务逻辑允许也可以不解决ABA</p></li><li><p>代码示例：</p><pre><code>package com.xu.juc;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.atomic.AtomicStampedReference;/** * @author xulingyun * @create 2020-10-29 18:21 */public class ABADemo &#123;    static AtomicReference&lt;Integer&gt; atomicReference = new AtomicReference&lt;&gt;(100);    static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100, 1);    public static void main(String[] args) &#123;        System.out.println(&quot;==========ABA的产生==========&quot;);        new Thread(() -&gt; &#123;            atomicReference.compareAndSet(100, 101);            atomicReference.compareAndSet(101, 100);        &#125;, &quot;t1&quot;).start();        new Thread(() -&gt; &#123;            //睡眠一秒让t1线程进行一次ABA            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            boolean flag = atomicReference.compareAndSet(100, 2020);            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + flag + &quot;修改后的值：&quot; + atomicReference);        &#125;, &quot;t2&quot;).start();        try &#123;            TimeUnit.SECONDS.sleep(2);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;==========ABA的解决==========&quot;);        new Thread(() -&gt; &#123;            int stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + &quot;第一次版本号：&quot; + stamp);            //睡眠一秒使t4获取相同的stamp            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);            System.out.println(Thread.currentThread().getName() + &quot;第二次版本号：&quot; + atomicStampedReference.getStamp());            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);            System.out.println(Thread.currentThread().getName() + &quot;第三次版本号：&quot; + atomicStampedReference.getStamp());        &#125;, &quot;t3&quot;).start();        new Thread(() -&gt; &#123;            int stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + &quot;第一次版本号：&quot; + stamp);            //睡眠三秒让t3线程执行完ABA            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            boolean flag = atomicStampedReference.compareAndSet(100, 2020, stamp, stamp + 1);            System.out.println(Thread.currentThread().getName() + &quot;当前修改是否成功：&quot; + flag + &quot;\t最终atomicStampedReference值:&quot; + atomicStampedReference.getReference());        &#125;, &quot;t4&quot;).start();    &#125;&#125;</code></pre><p><code>result</code>:</p><pre><code>==========ABA的产生==========t2    true修改后的值：2020==========ABA的解决==========t3第一次版本号：1t4第一次版本号：1t3第二次版本号：2t3第三次版本号：3t4当前修改是否成功：false    最终atomicStampedReference值:100</code></pre><p>第一次没有加版本控制产生ABA问题，第二次使用了<code>AtomicStampedReference</code>类解决了ABA问题，类似于乐观锁加上版本号解决ABA。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> ABA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> ABA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS的底层分析</title>
      <link href="2020/10/29/cas-de-di-ceng-fen-xi/"/>
      <url>2020/10/29/cas-de-di-ceng-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="CAS-Compare-And-Swap-比较交换"><a href="#CAS-Compare-And-Swap-比较交换" class="headerlink" title="CAS (Compare And Swap)比较交换"></a>CAS (Compare And Swap)比较交换</h1><h2 id="为什么atomic包下面的类可以保证原子性？"><a href="#为什么atomic包下面的类可以保证原子性？" class="headerlink" title="为什么atomic包下面的类可以保证原子性？"></a>为什么atomic包下面的类可以保证原子性？</h2><p>​    1.  atomic包中的getAndIncrement使用的是unsafe中的方法，unsafe类内是调用系统资源的方法<code>native</code>修饰有很多，其中在实现getAndIncrement时使用了<code>compareAndSwapInt</code>方法，<code>compareAndSwapInt</code>是cpu原语(下面解释)，所以在修改value时是不会出现多线程不安全的问题，保证了原子性</p><p><img src="/medias/JUC/CAS%E6%BA%90%E7%A0%81.png" alt="CAS源码" title="CAS源码"></p><ol start="2"><li><p>在getAddInt第一个变量是代表当前对象，第二个变量是代表内存偏移量(即在内存地址的值)，第三个变量代表修改的值</p></li><li><p>var5获取到内存地址的值然后在修改时与重新获取的值做比较，若是值不变就修改当前内存地址的值，且方法true取反，循环结束</p></li><li><p>若是值与之前获取的var5不一致则修改失败，返回false，取反循环继续</p></li><li><p><strong><code>compareAndSwapInt</code>方法是一个cpu原语</strong></p></li><li><p>cpu原语：计算机进程的控制通常由原语完成。所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被<strong>中断</strong>(个人理解:有点类似与锁)。</p></li></ol><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p><img src="/medias/JUC/CAS%E7%BC%BA%E7%82%B9.png" alt="CAS缺点" title="CAS缺点"></p><ol><li>cpu开销可能会大</li><li>只能保证一个共享变量的原子性</li><li>产生ABA问题（请看下一篇博客）</li></ol><h2 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h2><p>​      unsafe是CAS的核心类由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后面,基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法.<br>注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> cpu原语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> unsafe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式最终版</title>
      <link href="2020/10/29/dan-li-mo-shi-zui-zhong-ban/"/>
      <url>2020/10/29/dan-li-mo-shi-zui-zhong-ban/</url>
      
        <content type="html"><![CDATA[<pre><code># 单例模式</code></pre><p><img src="/medias/JUC/DCL%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8.png" alt="DCL线程不安全" title="DCL线程不安全"></p><p><img src="/medias/JUC/DCL%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A82.png" alt="DCL线程不安全" title="DCL线程不安全"></p><pre><code>public class SignalTonDemo &#123;    private static volatile SignalTonDemo instance = null;    private SignalTonDemo() &#123;        System.out.println(Thread.currentThread().getName() + &quot;\t实例化对象&quot;);    &#125;    /**DCL(Double Check Lock)双重检查锁     * 线程还未安全，可能发生指令重排序，会使返回的instance为null     * 实例化对象分为三个阶段     * 1.分配空间     * 2.初始化     * 3.被引用     * 在2,3阶段没有依赖关系可以被指令重排序，先被引用在初始化     * 有几率变成在分配空间后 初始化前下一个线程访问if返回false     * ，然后方法方法instance，因为还未初始化所以instance为null     *     * 使用volatile解决，volatile禁止指令重排序    */    public static SignalTonDemo getInstance() &#123;        if (instance == null) &#123;            synchronized (SignalTonDemo.class) &#123;                if (instance == null) &#123;                    instance = new SignalTonDemo();                &#125;            &#125;        &#125;        return instance;    &#125;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(() -&gt; &#123;                SignalTonDemo.getInstance();            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>加锁是可以保证原子性和可见性的：</p><ul><li>JMM（Java Memory Model）中关于<code>synchronized</code>有如下规定，线程加锁时，必须清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取；线程在解锁时，需要把工作内存中最新的共享变量的值写入到主存，以此来保证共享变量的可见性。(ps这里是个泛指，不是说只有在退出synchronized时才同步变量到主存)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC的认识</title>
      <link href="2020/10/27/jvm-de-ren-shi/"/>
      <url>2020/10/27/jvm-de-ren-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="GC的作用域"><a href="#GC的作用域" class="headerlink" title="GC的作用域"></a>GC的作用域</h1><ul><li>GC作用于方法区(Method Area)和堆(heap)</li><li>GC分为三个区 ，Young区，Old区，Perm区</li><li>次数上频繁回收Young区</li><li>次数上较少收集Old区</li><li>基本不动Perm区</li></ul><h1 id="GC算法的总体概述"><a href="#GC算法的总体概述" class="headerlink" title="GC算法的总体概述"></a>GC算法的总体概述</h1><ul><li>JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收都是指新生代</li><li>因此GC按照回收的区域有分了两种类型：一种是普通的GC<code>minor GC</code>，一种是全局GC<code>major GC</code> or <code>Full GC</code><ul><li>普通GC：只针对新生代区域</li><li>全局GC：针对年老代，偶尔伴随对新生代和永久代的GC</li></ul></li></ul><h1 id="GC的四大回收算法"><a href="#GC的四大回收算法" class="headerlink" title="GC的四大回收算法"></a>GC的四大回收算法</h1><ol><li><p>引用计数法：</p><ul><li><p>缺点：</p><ul><li>每次对象赋值时都要维护引用计数器，且计数器本身也有一定消耗；</li><li>较难处理循环引用</li></ul></li><li><p>JVM一般不采用这种方式</p></li></ul></li><li><p>复制算法<code>Copying</code>：</p><ul><li><p>年轻代采用的<code>minor GC</code>:这种GC就是复制算法</p></li><li><p><img src="/medias/GC/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法" title="复制算法"></p></li><li><p>Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old  generation中，也即一旦收集后，Eden是就变成空的了。<br>  当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。</p><p>-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数</p></li><li><p> HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p></li><li><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p></li><li><p>因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 </p><ul><li>缺点： <ol><li>它浪费了一半的内存，这太要命了。 </li><li>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</li></ol></li></ul></li></ul></li><li><p>标记清除<code>Mark-Sweep</code>：</p><ul><li>老年代一般是标记清除和标记压缩的混合实现</li><li><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="标记清除" title="标记清除"></li><li>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。<br> 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象      标记为存活的对象。<br> 清除：遍历整个堆，把未标记的对象清除。<br>用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。</li><li>缺点：<ul><li>此算法需要暂停整个应用，会产生内存碎片</li><li>首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲</li><li>其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。</li></ul></li></ul></li><li><p>标记压缩<code>Mark-Compact</code>：</p><ul><li><p><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9.png" alt="标记压缩" title="标记压缩"></p></li><li><p>  在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 </p><p> 　　标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价</p></li><li><p>缺点：</p><ul><li>标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法</li></ul></li></ul></li><li><p>标记清除压缩<code>Mark-Sweep-Compact</code>：</p><ul><li><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%8E%8B%E7%BC%A9.png" alt="标记清除压缩" title="标记清除压缩"></li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）</li><li>内存整齐度：复制算法=标记整理算法&gt;标记清除算法</li><li>内存利用率：标记整理算法=标记清除算法&gt;复制算法</li></ol><p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程</p><pre><code>无，没有最好的算法，只有最合适的算法。==========&gt;分代收集算法。</code></pre><ul><li>年轻代(Young Gen)  <ul><li>年轻代特点是区域相对老年代较小，对像存活率低。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul></li><li>老年代(Tenure Gen)<ul><li>老年代的特点是区域较大，对像存活率高。</li><li>这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</li></ul></li><li><strong>Mark阶段的开销与存活对像的数量成正比</strong>，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。</li><li><strong>Sweep阶段的开销与所管理区域的大小形正相关</strong>，但Sweep“就地处决”的特点，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。</li><li><strong>Compact阶段的开销与存活对像的数据成开比</strong>，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。</li><li>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>JVM内存模型以及分区，需要详细到每个分区放什么？</li><li>堆里面的分区：Eden，survival，from ，to ，老年区各自的特点？</li><li>GC的三种收集方法：标记清除，标记压缩，复制算法的原理与特点，分别用在什么地方？</li><li>Minor GC与Full GC分别发生在什么时候？</li></ol>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC的基本认识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile是什么?</title>
      <link href="2020/10/26/volatile-shi-shi-me/"/>
      <url>2020/10/26/volatile-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="valatile是什么？"><a href="#valatile是什么？" class="headerlink" title="valatile是什么？"></a>valatile是什么？</h1><ul><li><p><strong>volatile是一种java虚拟机提供轻量级的同步机制</strong></p></li><li><p><strong>volatile的三个特性</strong></p><ol><li><p>保证可见性</p><ul><li><p>JMM(Java Member Model)Java内存模型</p></li><li><p>由于JVM运行的实体是线程，而每个线程创建时JVM都会为其创建一个工作空间（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主存中，主内存是共享区域，所有线程都可以访问，<strong>但线程对变量的操作（读取赋值等）必须在工作空间中进行，首先要从主内存拷贝数据到工作空间，然后对变量进行操作，操作完成在写回主内存</strong>，不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存中的<strong>变量拷贝副本</strong>，因此不同线程间不能访问对方工作内存，线程间的传值必须通过主内存来完成，其简要访问过程如下：</p><p><img src="/medias/JUC/JMM%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4.png" alt="JMM主内存和工作空间" title="JMM主内存和工作空间"></p></li><li><h2 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h2><pre><code>class Number&#123;    Integer number = 0;    public void addTo30()&#123;        number = 30;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) &#123;        Number number = new Number();        new Thread(()-&gt;&#123;            System.out.println(&quot;Number begin&quot;);            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            number.addTo30();            System.out.println(&quot;修改number=30&quot;);        &#125;, &quot;AAA&quot;).start();        //如果number没有改变就一直死循环        //结果死循环程序未结束，因为主线程复制了number=0到工作空间，之后AAA线程修改了number主线程并不知道        while (number.number == 0)&#123;        &#125;        System.out.println(&quot;Number &quot; + number.number);    &#125;&#125;</code></pre><p><img src="/medias/JUC/%E6%9C%AA%E4%BD%BF%E7%94%A8volatitle.png" alt="未使用volatitle" title="未使用volatitle"></p></li><li><pre><code>class Number&#123;    volatile Integer number = 0;    public void addTo30()&#123;        number = 30;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) &#123;        Number number = new Number();        new Thread(()-&gt;&#123;            System.out.println(&quot;Number begin&quot;);            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            number.addTo30();            System.out.println(&quot;修改number=30&quot;);        &#125;, &quot;AAA&quot;).start();        //如果number没有改变就一直死循环        //结果循环结束，因为number使用了volatile，在线程AAA修改number写回主内存时，        // 主内存通知了main线程，main线程重新读取number值所以循环结束        while (number.number == 0)&#123;        &#125;        System.out.println(&quot;Number &quot; + number.number);    &#125;&#125;</code></pre><p><img src="/medias/JUC/%E4%BD%BF%E7%94%A8volatitle.png" alt="使用volatitle" title="使用volatile"></p></li></ul></li><li><p>不保证原子性</p><ul><li><p>使用volatile的++操作</p><pre><code>class Number&#123;    volatile Integer number = 0;    public void addPlusPlus()&#123;        /*        number++不是原子操作        第一步：取出number数据        第二步：number加一        第三步：写回数据             */        number++;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) throws InterruptedException &#123;         //减少计数JUC辅助工具类        CountDownLatch countDownLatch = new CountDownLatch(20);        Number number = new Number();        for (int i = 1; i &lt;= 20; i++) &#123;            new Thread(()-&gt;&#123;                for (int j = 0; j &lt; 1000; j++) &#123;                    /**                     * 在工作空间volatile虽然会然主内存通知工作空间数据的修改                     * 但是在一个线程写入数据的同时主内存开始通知，其他线程还没被通知到也写入数据到主内存中                     * 产生了写覆盖，所以最后的数值没有到达20000                     */                    number.addPlusPlus();                &#125;                countDownLatch.countDown();            &#125;,&quot;BBB&quot;).start();        &#125;        countDownLatch.await();        System.out.println(&quot;number最终得分：&quot; + number.number);    &#125;&#125;</code></pre><pre><code>result:number最终得分：18167Process finished with exit code 0</code></pre><p>结果表明volatile不保证原子性，虽然使用synchronized可以解决该问题，但是未免有点杀鸡用牛刀，其他解决方法：</p></li><li><p>使用atomicInteger类型可以解决原子性问题：</p><pre><code>class Number&#123;    volatile Integer number = 0;    AtomicInteger atomicInteger = new AtomicInteger();    public void addPlusPlus()&#123;        /*        number++不是原子操作        第一步：取出number数据        第二步：number加一        第三步：写回数据         */        number++;        atomicInteger.getAndIncrement();    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) throws InterruptedException &#123;        //减少计数JUC辅助工具类        CountDownLatch countDownLatch = new CountDownLatch(20);        Number number = new Number();        for (int i = 1; i &lt;= 20; i++) &#123;            new Thread(()-&gt;&#123;                for (int j = 0; j &lt; 1000; j++) &#123;                    number.addPlusPlus();                &#125;                countDownLatch.countDown();            &#125;,&quot;BBB&quot;).start();        &#125;        countDownLatch.await();        System.out.println(&quot;number最终得分：&quot; + number.number);        System.out.println(&quot;atomicInteger最终得分：&quot; + number.atomicInteger);    &#125;&#125;</code></pre><pre><code>result:number最终得分：18923atomicInteger最终得分：20000Process finished with exit code 0</code></pre></li></ul></li></ol></li></ul><ol start="3"><li><p>禁止指令重排</p><p><img src="/medias/JUC/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="指令重排序" title="指令重排序"></p><p>加上volatile可以使指令不重排序</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="2020/10/23/da-jian-ge-ren-bo-ke/"/>
      <url>2020/10/23/da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客需要node-js的npm和git环境"><a href="#搭建博客需要node-js的npm和git环境" class="headerlink" title="搭建博客需要node.js的npm和git环境"></a>搭建博客需要node.js的npm和git环境</h1><h2 id="首先下载npm和git"><a href="#首先下载npm和git" class="headerlink" title="首先下载npm和git"></a>首先下载<a href="http://nodejs.cn/download/">npm</a>和<a href="https://git-scm.com/download/">git</a></h2><h2 id="安装hexo运行环境"><a href="#安装hexo运行环境" class="headerlink" title="安装hexo运行环境"></a>安装hexo运行环境</h2><ol><li><p>npm和git安装完成后的检验是 npm -v 和 node -v</p></li><li><p>如图：</p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%A3%80%E9%AA%8Cnpm%E5%92%8Cnode.png" alt="install" title="node"></p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%A3%80%E9%AA%8Cgit.png" alt="git" title="git"> </p></li></ol><h2 id="安装hexo基本框架"><a href="#安装hexo基本框架" class="headerlink" title="安装hexo基本框架"></a>安装hexo基本框架</h2><ol><li><p>新建一个文件夹给自己的博客找个小窝</p></li><li><p>然后进入新建的文件夹，右击Git Bash Here</p></li><li><pre><code>//第一条   这是安装hexo的基础框架 , npm安装到全局，熟悉的话可以安装局部npm install -g hexo//第二条   这是初始化hexo框架 这个可能会比较慢(要有耐心)hexo init//第三条 安装所需要的组件npm install//第四条 编译生成静态页面hexo g//第五条 启动本地服务hexo s</code></pre></li></ol><ol start="4"><li><p>启动后的结果<img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%BF%90%E8%A1%8C.png" alt="yans" title="演示结果"></p></li><li><p>然后访问 <a href="http://localhost:4000/">http://localhost:4000/</a> <img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%BC%94%E7%A4%BA.png" alt="result" title="页面"></p></li></ol><h1 id="hexo命令大全："><a href="#hexo命令大全：" class="headerlink" title="hexo命令大全："></a>hexo命令大全：</h1><pre><code>hexo n &quot;博客名字&quot; #执行成功后会在根目录下\source\_posts生成一个同名的md文件 #编写这个文件就可 然后执行 hexo clean hexo g  hexo d 部署到github上去hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g  #生成静态网页hexo s  #启动服务预览hexo d  #开始部署hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署</code></pre><h1 id="github配置个人博客免域名"><a href="#github配置个人博客免域名" class="headerlink" title="github配置个人博客免域名"></a>github配置个人博客免域名</h1><ol><li><p>注册一个github账户，用邮箱就行<img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/github%E5%88%9B%E5%BB%BArepositories.png" alt="github" title="github配置"></p></li><li><p>然后点击new </p></li><li><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/github.png" alt="github" title="gitthub"></p></li><li><p>我的因为创建过了所以报错</p></li><li><p>创建repository的名字一定要是 用户名.github.io,不然访问不到</p></li><li><p>之后将code哪里http的git连接复制粘贴到 安装好的hexo的 <code>_config.yml</code> 中</p><pre><code>deploy:  type: git  repo: https://github.com/xu196/xu196.github.io.git  branch: master</code></pre><p>里面 , 运行下面代码在根目录的命令行界面</p><pre><code>hexo cleanhexo ghexo d</code></pre><ul><li>如果上面repo配置的是http的路径<code>hexo d</code> 之后需要输入github的用户名和密码</li><li>要是想要无密码push就需要配置ssh的路径，这里不做过多说明，需要自行百度</li><li><code>hexo d</code> 成功页面</li><li><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/push%E6%88%90%E5%8A%9F.png" alt="push" title="push to github"></li><li>接下来就可以访问博客了， 就是之前设置的<code>repository</code>名字，我的是<code>xly-star.github.io</code></li><li>接下来就可以尽情的开发自己的博客了</li><li>美化博客请看接下来的后续博客！</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
