<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CAS的底层分析</title>
      <link href="2020/10/29/cas-de-di-ceng-fen-xi/"/>
      <url>2020/10/29/cas-de-di-ceng-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="CAS-Compare-And-Swap-比较交换"><a href="#CAS-Compare-And-Swap-比较交换" class="headerlink" title="CAS (Compare And Swap)比较交换"></a>CAS (Compare And Swap)比较交换</h1><h2 id="为什么atomic包下面的类可以保证原子性？"><a href="#为什么atomic包下面的类可以保证原子性？" class="headerlink" title="为什么atomic包下面的类可以保证原子性？"></a>为什么atomic包下面的类可以保证原子性？</h2><p>​    1.  atomic包中的getAndIncrement使用的是unsafe中的方法，unsafe类内是调用系统资源的方法<code>native</code>修饰有很多，其中在实现getAndIncrement时使用了<code>compareAndSwapInt</code>方法，<code>compareAndSwapInt</code>是cpu原语(下面解释)，所以在修改value时是不会出现多线程不安全的问题，保证了原子性</p><p><img src="/medias/JUC/CAS%E6%BA%90%E7%A0%81.png" alt="CAS源码" title="CAS源码"></p><ol start="2"><li><p>在getAddInt第一个变量是代表当前对象，第二个变量是代表内存偏移量(即在内存地址的值)，第三个变量代表修改的值</p></li><li><p>var5获取到内存地址的值然后在修改时与重新获取的值做比较，若是值不变就修改当前内存地址的值，且方法true取反，循环结束</p></li><li><p>若是值与之前获取的var5不一致则修改失败，返回false，取反循环继续</p></li><li><p><strong><code>compareAndSwapInt</code>方法是一个cpu原语</strong></p></li><li><p>cpu原语：计算机进程的控制通常由原语完成。所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被<strong>中断</strong>(个人理解:有点类似与锁)。</p></li></ol><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p><img src="/medias/JUC/CAS%E7%BC%BA%E7%82%B9.png" alt="CAS缺点" title="CAS缺点"></p><ol><li>cpu开销可能会大</li><li>只能保证一个共享变量的原子性</li><li>产生ABA问题（请看下一篇博客）</li></ol><h2 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h2><p>​      unsafe是CAS的核心类由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后面,基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法.<br>注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> cpu原语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> unsafe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式最终版</title>
      <link href="2020/10/29/dan-li-mo-shi-zui-zhong-ban/"/>
      <url>2020/10/29/dan-li-mo-shi-zui-zhong-ban/</url>
      
        <content type="html"><![CDATA[<pre><code># 单例模式</code></pre><p><img src="/medias/JUC/DCL%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8.png" alt="DCL线程不安全" title="DCL线程不安全"></p><p><img src="/medias/JUC/DCL%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A82.png" alt="DCL线程不安全" title="DCL线程不安全"></p><pre><code>public class SignalTonDemo &#123;    private static volatile SignalTonDemo instance = null;    private SignalTonDemo() &#123;        System.out.println(Thread.currentThread().getName() + &quot;\t实例化对象&quot;);    &#125;    /**DCL(Double Check Lock)双重检查锁     * 线程还未安全，可能发生指令重排序，会使返回的instance为null     * 实例化对象分为三个阶段     * 1.分配空间     * 2.初始化     * 3.被引用     * 在2,3阶段没有依赖关系可以被指令重排序，先被引用在初始化     * 有几率变成在分配空间后 初始化前下一个线程访问if返回false     * ，然后方法方法instance，因为还未初始化所以instance为null     *     * 使用volatile解决，volatile禁止指令重排序    */    public static SignalTonDemo getInstance() &#123;        if (instance == null) &#123;            synchronized (SignalTonDemo.class) &#123;                if (instance == null) &#123;                    instance = new SignalTonDemo();                &#125;            &#125;        &#125;        return instance;    &#125;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(() -&gt; &#123;                SignalTonDemo.getInstance();            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC的认识</title>
      <link href="2020/10/27/jvm-de-ren-shi/"/>
      <url>2020/10/27/jvm-de-ren-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="GC的作用域"><a href="#GC的作用域" class="headerlink" title="GC的作用域"></a>GC的作用域</h1><ul><li>GC作用于方法区(Method Area)和堆(heap)</li><li>GC分为三个区 ，Young区，Old区，Perm区</li><li>次数上频繁回收Young区</li><li>次数上较少收集Old区</li><li>基本不动Perm区</li></ul><h1 id="GC算法的总体概述"><a href="#GC算法的总体概述" class="headerlink" title="GC算法的总体概述"></a>GC算法的总体概述</h1><ul><li>JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收都是指新生代</li><li>因此GC按照回收的区域有分了两种类型：一种是普通的GC<code>minor GC</code>，一种是全局GC<code>major GC</code> or <code>Full GC</code><ul><li>普通GC：只针对新生代区域</li><li>全局GC：针对年老代，偶尔伴随对新生代和永久代的GC</li></ul></li></ul><h1 id="GC的四大回收算法"><a href="#GC的四大回收算法" class="headerlink" title="GC的四大回收算法"></a>GC的四大回收算法</h1><ol><li><p>引用计数法：</p><ul><li><p>缺点：</p><ul><li>每次对象赋值时都要维护引用计数器，且计数器本身也有一定消耗；</li><li>较难处理循环引用</li></ul></li><li><p>JVM一般不采用这种方式</p></li></ul></li><li><p>复制算法<code>Copying</code>：</p><ul><li><p>年轻代采用的<code>minor GC</code>:这种GC就是复制算法</p></li><li><p><img src="/medias/GC/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法" title="复制算法"></p></li><li><p>Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old  generation中，也即一旦收集后，Eden是就变成空的了。<br>  当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。</p><p>-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数</p></li><li><p> HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p></li><li><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p></li><li><p>因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 </p><ul><li>缺点： <ol><li>它浪费了一半的内存，这太要命了。 </li><li>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</li></ol></li></ul></li></ul></li><li><p>标记清除<code>Mark-Sweep</code>：</p><ul><li>老年代一般是标记清除和标记压缩的混合实现</li><li><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="标记清除" title="标记清除"></li><li>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。<br> 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象      标记为存活的对象。<br> 清除：遍历整个堆，把未标记的对象清除。<br>用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。</li><li>缺点：<ul><li>此算法需要暂停整个应用，会产生内存碎片</li><li>首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲</li><li>其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。</li></ul></li></ul></li><li><p>标记压缩<code>Mark-Compact</code>：</p><ul><li><p><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9.png" alt="标记压缩" title="标记压缩"></p></li><li><p>  在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 </p><p> 　　标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价</p></li><li><p>缺点：</p><ul><li>标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法</li></ul></li></ul></li><li><p>标记清除压缩<code>Mark-Sweep-Compact</code>：</p><ul><li><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%8E%8B%E7%BC%A9.png" alt="标记清除压缩" title="标记清除压缩"></li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）</li><li>内存整齐度：复制算法=标记整理算法&gt;标记清除算法</li><li>内存利用率：标记整理算法=标记清除算法&gt;复制算法</li></ol><p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程</p><pre><code>无，没有最好的算法，只有最合适的算法。==========&gt;分代收集算法。</code></pre><ul><li>年轻代(Young Gen)  <ul><li>年轻代特点是区域相对老年代较小，对像存活率低。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul></li><li>老年代(Tenure Gen)<ul><li>老年代的特点是区域较大，对像存活率高。</li><li>这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</li></ul></li><li><strong>Mark阶段的开销与存活对像的数量成正比</strong>，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。</li><li><strong>Sweep阶段的开销与所管理区域的大小形正相关</strong>，但Sweep“就地处决”的特点，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。</li><li><strong>Compact阶段的开销与存活对像的数据成开比</strong>，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。</li><li>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>JVM内存模型以及分区，需要详细到每个分区放什么？</li><li>堆里面的分区：Eden，survival，from ，to ，老年区各自的特点？</li><li>GC的三种收集方法：标记清除，标记压缩，复制算法的原理与特点，分别用在什么地方？</li><li>Minor GC与Full GC分别发生在什么时候？</li></ol>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC的基本认识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile是什么?</title>
      <link href="2020/10/26/volatile-shi-shi-me/"/>
      <url>2020/10/26/volatile-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="valatile是什么？"><a href="#valatile是什么？" class="headerlink" title="valatile是什么？"></a>valatile是什么？</h1><ul><li><p><strong>volatile是一种java虚拟机提供轻量级的同步机制</strong></p></li><li><p><strong>volatile的三个特性</strong></p><ol><li><p>保证可见性</p><ul><li><p>JMM(Java Member Model)Java内存模型</p></li><li><p>由于JVM运行的实体是线程，而每个线程创建时JVM都会为其创建一个工作空间（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主存中，主内存是共享区域，所有线程都可以访问，<strong>但线程对变量的操作（读取赋值等）必须在工作空间中进行，首先要从主内存拷贝数据到工作空间，然后对变量进行操作，操作完成在写回主内存</strong>，不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存中的<strong>变量拷贝副本</strong>，因此不同线程间不能访问对方工作内存，线程间的传值必须通过主内存来完成，其简要访问过程如下：</p><p><img src="/medias/JUC/JMM%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4.png" alt="JMM主内存和工作空间" title="JMM主内存和工作空间"></p></li><li><h2 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h2><pre><code>class Number&#123;    Integer number = 0;    public void addTo30()&#123;        number = 30;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) &#123;        Number number = new Number();        new Thread(()-&gt;&#123;            System.out.println(&quot;Number begin&quot;);            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            number.addTo30();            System.out.println(&quot;修改number=30&quot;);        &#125;, &quot;AAA&quot;).start();        //如果number没有改变就一直死循环        //结果死循环程序未结束，因为主线程复制了number=0到工作空间，之后AAA线程修改了number主线程并不知道        while (number.number == 0)&#123;        &#125;        System.out.println(&quot;Number &quot; + number.number);    &#125;&#125;</code></pre><p><img src="/medias/JUC/%E6%9C%AA%E4%BD%BF%E7%94%A8volatitle.png" alt="未使用volatitle" title="未使用volatitle"></p></li><li><pre><code>class Number&#123;    volatile Integer number = 0;    public void addTo30()&#123;        number = 30;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) &#123;        Number number = new Number();        new Thread(()-&gt;&#123;            System.out.println(&quot;Number begin&quot;);            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            number.addTo30();            System.out.println(&quot;修改number=30&quot;);        &#125;, &quot;AAA&quot;).start();        //如果number没有改变就一直死循环        //结果循环结束，因为number使用了volatile，在线程AAA修改number写回主内存时，        // 主内存通知了main线程，main线程重新读取number值所以循环结束        while (number.number == 0)&#123;        &#125;        System.out.println(&quot;Number &quot; + number.number);    &#125;&#125;</code></pre><p><img src="/medias/JUC/%E4%BD%BF%E7%94%A8volatitle.png" alt="使用volatitle" title="使用volatile"></p></li></ul></li><li><p>不保证原子性</p><ul><li><p>使用volatile的++操作</p><pre><code>class Number&#123;    volatile Integer number = 0;    public void addPlusPlus()&#123;        /*        number++不是原子操作        第一步：取出number数据        第二步：number加一        第三步：写回数据             */        number++;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) throws InterruptedException &#123;         //减少计数JUC辅助工具类        CountDownLatch countDownLatch = new CountDownLatch(20);        Number number = new Number();        for (int i = 1; i &lt;= 20; i++) &#123;            new Thread(()-&gt;&#123;                for (int j = 0; j &lt; 1000; j++) &#123;                    /**                     * 在工作空间volatile虽然会然主内存通知工作空间数据的修改                     * 但是在一个线程写入数据的同时主内存开始通知，其他线程还没被通知到也写入数据到主内存中                     * 产生了写覆盖，所以最后的数值没有到达20000                     */                    number.addPlusPlus();                &#125;                countDownLatch.countDown();            &#125;,&quot;BBB&quot;).start();        &#125;        countDownLatch.await();        System.out.println(&quot;number最终得分：&quot; + number.number);    &#125;&#125;</code></pre><pre><code>result:number最终得分：18167Process finished with exit code 0</code></pre><p>结果表明volatile不保证原子性，虽然使用synchronized可以解决该问题，但是未免有点杀鸡用牛刀，其他解决方法：</p></li><li><p>使用atomicInteger类型可以解决原子性问题：</p><pre><code>class Number&#123;    volatile Integer number = 0;    AtomicInteger atomicInteger = new AtomicInteger();    public void addPlusPlus()&#123;        /*        number++不是原子操作        第一步：取出number数据        第二步：number加一        第三步：写回数据         */        number++;        atomicInteger.getAndIncrement();    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) throws InterruptedException &#123;        //减少计数JUC辅助工具类        CountDownLatch countDownLatch = new CountDownLatch(20);        Number number = new Number();        for (int i = 1; i &lt;= 20; i++) &#123;            new Thread(()-&gt;&#123;                for (int j = 0; j &lt; 1000; j++) &#123;                    number.addPlusPlus();                &#125;                countDownLatch.countDown();            &#125;,&quot;BBB&quot;).start();        &#125;        countDownLatch.await();        System.out.println(&quot;number最终得分：&quot; + number.number);        System.out.println(&quot;atomicInteger最终得分：&quot; + number.atomicInteger);    &#125;&#125;</code></pre><pre><code>result:number最终得分：18923atomicInteger最终得分：20000Process finished with exit code 0</code></pre></li></ul></li></ol></li></ul><ol start="3"><li><p>禁止指令重排</p><p><img src="/medias/JUC/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="指令重排序" title="指令重排序"></p><p>加上volatile可以使指令不重排序</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="2020/10/23/da-jian-ge-ren-bo-ke/"/>
      <url>2020/10/23/da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客需要node-js的npm和git环境"><a href="#搭建博客需要node-js的npm和git环境" class="headerlink" title="搭建博客需要node.js的npm和git环境"></a>搭建博客需要node.js的npm和git环境</h1><h2 id="首先下载npm和git"><a href="#首先下载npm和git" class="headerlink" title="首先下载npm和git"></a>首先下载<a href="http://nodejs.cn/download/">npm</a>和<a href="https://git-scm.com/download/">git</a></h2><h2 id="安装hexo运行环境"><a href="#安装hexo运行环境" class="headerlink" title="安装hexo运行环境"></a>安装hexo运行环境</h2><ol><li><p>npm和git安装完成后的检验是 npm -v 和 node -v</p></li><li><p>如图：</p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%A3%80%E9%AA%8Cnpm%E5%92%8Cnode.png" alt="install" title="node"></p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%A3%80%E9%AA%8Cgit.png" alt="git" title="git"> </p></li></ol><h2 id="安装hexo基本框架"><a href="#安装hexo基本框架" class="headerlink" title="安装hexo基本框架"></a>安装hexo基本框架</h2><ol><li><p>新建一个文件夹给自己的博客找个小窝</p></li><li><p>然后进入新建的文件夹，右击Git Bash Here</p></li><li><pre><code>//第一条   这是安装hexo的基础框架 , npm安装到全局，熟悉的话可以安装局部npm install -g hexo//第二条   这是初始化hexo框架 这个可能会比较慢(要有耐心)hexo init//第三条 安装所需要的组件npm install//第四条 编译生成静态页面hexo g//第五条 启动本地服务hexo s</code></pre></li></ol><ol start="4"><li><p>启动后的结果<img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%BF%90%E8%A1%8C.png" alt="yans" title="演示结果"></p></li><li><p>然后访问 <a href="http://localhost:4000/">http://localhost:4000/</a> <img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%BC%94%E7%A4%BA.png" alt="result" title="页面"></p></li></ol><h1 id="hexo命令大全："><a href="#hexo命令大全：" class="headerlink" title="hexo命令大全："></a>hexo命令大全：</h1><pre><code>hexo n &quot;博客名字&quot; #执行成功后会在根目录下\source\_posts生成一个同名的md文件 #编写这个文件就可 然后执行 hexo clean hexo g  hexo d 部署到github上去hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g  #生成静态网页hexo s  #启动服务预览hexo d  #开始部署hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署</code></pre><h1 id="github配置个人博客免域名"><a href="#github配置个人博客免域名" class="headerlink" title="github配置个人博客免域名"></a>github配置个人博客免域名</h1><ol><li><p>注册一个github账户，用邮箱就行<img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/github%E5%88%9B%E5%BB%BArepositories.png" alt="github" title="github配置"></p></li><li><p>然后点击new </p></li><li><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/github.png" alt="github" title="gitthub"></p></li><li><p>我的因为创建过了所以报错</p></li><li><p>创建repository的名字一定要是 用户名.github.io,不然访问不到</p></li><li><p>之后将code哪里http的git连接复制粘贴到 安装好的hexo的 <code>_config.yml</code> 中</p><pre><code>deploy:  type: git  repo: https://github.com/xu196/xu196.github.io.git  branch: master</code></pre><p>里面 , 运行下面代码在根目录的命令行界面</p><pre><code>hexo cleanhexo ghexo d</code></pre><ul><li>如果上面repo配置的是http的路径<code>hexo d</code> 之后需要输入github的用户名和密码</li><li>要是想要无密码push就需要配置ssh的路径，这里不做过多说明，需要自行百度</li><li><code>hexo d</code> 成功页面</li><li><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/push%E6%88%90%E5%8A%9F.png" alt="push" title="push to github"></li><li>接下来就可以访问博客了， 就是之前设置的<code>repository</code>名字，我的是<code>xly-star.github.io</code></li><li>接下来就可以尽情的开发自己的博客了</li><li>美化博客请看接下来的后续博客！</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
