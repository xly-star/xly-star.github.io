<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ThreadPoolExecutor初体验</title>
      <link href="2020/11/07/threadpoolexecutor-chu-ti-yan/"/>
      <url>2020/11/07/threadpoolexecutor-chu-ti-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="创建线程池的五个方法"><a href="#创建线程池的五个方法" class="headerlink" title="创建线程池的五个方法"></a>创建线程池的五个方法</h1><ul><li><p><code>ExecutorService threadPool = Executors.newFixedThreadPool(2);</code>:创建固定数线程池,但是其阻塞队列是<code>new LinkedBlockingQueue&lt;Runnable&gt;()</code>有<code>(Integer.MAX_VALUE)</code>大</p><ol><li><p>主要特点如下:<br>1.1 创建一个定长线程池,可控制线程的最大并发数,超出的线程会在队列中等待.</p><p>1.2 <code>newFixedThreadPool</code>创建的线程池<code>corePoolSize</code>和<code>MaxmumPoolSize</code>是 相等的,它使用的的<code>LinkedBlockingQueue</code></p></li></ol></li></ul><p>代码示例:</p><pre><code>ExecutorService threadPool = Executors.newFixedThreadPool(2);        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //不能再循环中关闭线程池不然抛出默认拒绝策略的异常            threadPool.shutdown();        &#125;</code></pre><ul><li><code>Executors.newSingleThreadExecutor();</code>:创建单一线程,但是其阻塞队列是<code>new LinkedBlockingQueue&lt;Runnable&gt;()</code>有<code>(Integer.MAX_VALUE)</code>大<ol><li>主要特点如下:<br>1.1 创建一个单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务都按照指定顺序执行.<br>1.2 <code>newSingleThreadExecutor</code>将<code>corePoolSize</code>和<code>MaxmumPoolSize</code>都设置为1,它使用的的<code>LinkedBlockingQueue</code></li></ol></li></ul><p>代码示例:</p><pre><code>ExecutorService threadPool = Executors.newSingleThreadExecutor();        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre><ul><li><p><code>ExecutorService threadPool = Executors.newCachedThreadPool();</code>:创建可变线程数，虽然其阻塞队列是<code>SynchronousQueue</code>，但是其<code>MaxmumPoolSize</code>为<code>(Integer.MAX_VALUE)</code></p><ol><li>主要特点如下:<br>1.1 创建一个可缓存线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则创建新线程.<br>1.2 <code>newCachedThreadPool</code>将<code>corePoolSize</code>设置为0,<code>MaxmumPoolSize</code>设置为<code>Integer.MAX_VALUE</code>,它使用的是<code>SynchronousQUeue</code>,也就是说来了任务就创建线程运行,如果线程空闲超过60秒,就销毁线程</li></ol></li></ul><p>代码示例:</p><pre><code>ExecutorService threadPool = Executors.newCachedThreadPool();        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre><ul><li><p><code>Executors.newWorkStealingPool</code>:java8新增,使用目前机器上可以的处理器作为他的并发级别</p><ul><li><img src="/medias/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="线程池" title="线程池"></li></ul></li><li><p><code>手写线程池</code>:</p><ul><li><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.AbortPolicy());</code></pre><p>工作使用!</p></li></ul></li></ul><h1 id="线程池七大参数"><a href="#线程池七大参数" class="headerlink" title="线程池七大参数"></a>线程池七大参数</h1><ol><li><p><code>corePoolSize</code>:线程池常驻的核心线程数</p></li><li><p><code>maximumPoolSize</code>:线程池能够容纳同时执行的最大线程数,此值大于等于1</p></li><li><p><code>keepAliveTime</code>:多余空闲线程的存活时间,当空闲时间达到<code>keepAliveTime</code>值时,多余的线程会被销毁知道只剩下<code>corePoolSize</code>个线程为止</p></li><li><p><code>unit</code>:<code>keepAliveTime</code>的单位</p></li><li><p><code>workQueue</code>:任务队列,被提交但尚未被执行的任务</p></li><li><p><code>threadFactory</code>:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般使用默认即可</p></li><li><p><code>handler</code>:拒接策略,表示当前线程队列满了并且工作线程大于等于线程池最大线程数<code>maximumPoolSize</code>时如何来拒绝</p><ul><li><p>四大拒绝策略都实现了<code>RejectExecutionHandle</code>接口</p><ol><li><p><code>AbortPolicy(默认)</code>:直接抛出异常<code>RejectedException</code>阻止程序的正常运行</p><p>示例:</p><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.AbortPolicy());        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre><p>result:抛出异常</p><pre><code>pool-1-thread-1    服务1pool-1-thread-1    服务3pool-1-thread-1    服务4pool-1-thread-1    服务5pool-1-thread-2    服务2pool-1-thread-3    服务6pool-1-thread-4    服务7pool-1-thread-5    服务8java.util.concurrent.RejectedExecutionException: Task com.xu.juc.threadpool.TreadPoolDemo$$Lambda$1/1023892928@6d03e736 rejected from java.util.concurrent.ThreadPoolExecutor@568db2f2[Running, pool size = 5, active threads = 5, queued tasks = 3, completed tasks = 0]    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)    at com.xu.juc.threadpool.TreadPoolDemo.main(TreadPoolDemo.java:21)</code></pre></li></ol></li></ul></li></ol><ol start="2"><li><p><code>CallerRunPolicy</code>:”调用者执行”一直调用机制,该策略既不会抛弃任务,也不会抛出异常,而是让发起请求者调用</p><p>示例:</p><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.CallerRunsPolicy());        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre></li></ol><p>result:回调使main线程调用方法</p><pre><code> ``` pool-1-thread-1    服务1 main    服务9 main    服务10 pool-1-thread-1    服务3 pool-1-thread-1    服务4 pool-1-thread-1    服务5 pool-1-thread-2    服务2 pool-1-thread-3    服务6 pool-1-thread-4    服务7 pool-1-thread-5    服务8</code></pre><ol start="3"><li><p><code>DiscardOldestPolicy</code>:抛弃任务队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交</p><p>示例:</p><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.DiscardOldestPolicy());        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre></li></ol><p>result:只有八个结果等待最久的两个请求被丢弃</p><pre><code> ``` pool-1-thread-1    服务1 pool-1-thread-2    服务2 pool-1-thread-2    服务5 pool-1-thread-2    服务9 pool-1-thread-2    服务10 pool-1-thread-3    服务6 pool-1-thread-5    服务8 pool-1-thread-4    服务7</code></pre><ol start="4"><li><code>DiscardPolicy</code>:直接丢弃任务,不给予任何处理也不抛出异常.如果允许任务丢失,这是最好的拒绝策略</li></ol><p>示例:</p><pre><code> ``` ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                     5,                                                     1L,                                                     TimeUnit.SECONDS,                                                     new LinkedBlockingQueue&lt;&gt;(3),                                                     Executors.defaultThreadFactory(),                                                     new ThreadPoolExecutor.DiscardPolicy());         try &#123;             for (int i = 0; i &lt; 10; i++) &#123;                 final int tempInt = i;                 threadPool.execute(() -&gt; &#123;                     System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                 &#125;);             &#125;         &#125; catch (Exception e) &#123;             e.printStackTrace();         &#125; finally &#123;             threadPool.shutdown();         &#125;</code></pre><p>result:只有八个请求被服务，后面到的请求直接被抛弃,不给予处理</p><pre><code> pool-1-thread-1    服务1 pool-1-thread-1    服务3 pool-1-thread-1    服务4 pool-1-thread-1    服务5 pool-1-thread-2    服务2 pool-1-thread-4    服务7 pool-1-thread-3    服务6 pool-1-thread-5    服务8</code></pre><p>线程池底层工作原理：</p><ol><li>在创建了线程池后，线程池中的线程数为零。</li><li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<ol><li>如果正在运行的线程数量小于<code>corePoolSize</code>，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于<code>corePoolSize</code>，那么将这个任务放入队列；</li><li>如果这个时候队列满了且正在运行的线程数量还小于<code>maximumPoolSize</code>，那么还是要创建非核心线程立刻运行<strong>这个任务</strong>(不是运行在队列中等待的任务，而是新请求的任务)；</li><li>如果队列满了且正在运行的线程数量大于或等于<code>maximumPoolSize</code>，那么线程池会启动饱和拒绝策略来执行。</li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做超过一定的时间（<code>keepAliveTime</code>）时，线程会判断：<ol><li>如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉。</li><li>所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code>的大小。</li></ol></li></ol><h2 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h2><h2 id="cpu密集型"><a href="#cpu密集型" class="headerlink" title="cpu密集型:"></a><code>cpu</code>密集型:</h2><ul><li><p><code>System.out.println(Runtime.getRuntime().availableProcessors());</code>查看cpu核心数</p><p><code>cpu</code>密集的意思是该任务需要大量的运算,而没有阻塞,<code>cpu</code>一直全速运行.</p><p><code>cpu</code>密集任务只有在真正的多核<code>cpu</code>上才可能得到加速(通过多线程),而在单核<code>cpu</code>上,无论你看多少个模拟的多线程该任务都不可能得到加速,因为<code>cpu</code>总的运算能力就只有那些</p><p><code>cpu</code>密集型任务配置尽可能少的线程数量</p></li><li><p>公式:<code>cpu</code>核心数+1个线程的线程池</p></li></ul><h2 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型:"></a><code>IO</code>密集型:</h2><ol><li><ul><li><p>由于IO密集型任务线程并不是一直在执行任务,则应尽可能配置多线程数</p></li><li><p>公式:<code>cpu</code>核心数*2</p></li></ul></li><li><ul><li><img src="/medias/JUC/IO%E5%AF%86%E9%9B%86%E5%9E%8B.png" alt="IO密集型" title="IO密集型"></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者模式</title>
      <link href="2020/11/07/sheng-chan-zhe-xiao-fei-zhe-mo-shi/"/>
      <url>2020/11/07/sheng-chan-zhe-xiao-fei-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="传统生产者消费者模式"><a href="#传统生产者消费者模式" class="headerlink" title="传统生产者消费者模式"></a>传统生产者消费者模式</h1><pre><code>/** * 共享资源类 */class ShareData &#123;    private int num = 0;    private Lock lock = new ReentrantLock();    private Condition condition = lock.newCondition();    public void increment() throws Exception &#123;        lock.lock();        try &#123;            //判断 防止虚假唤醒使用while            while (num != 0) &#123;                //等待 不生产                condition.await();            &#125;            //干活            num++;            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + num);            //通知唤醒            condition.signalAll();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void deIncrement() throws Exception &#123;        lock.lock();        try &#123;            //判断            while (num == 0) &#123;                //等待 不生产                condition.await();            &#125;            //干活            num--;            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + num);            //通知唤醒            condition.signalAll();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;/** * Description * 一个初始值为0的变量 两个线程交替操作 一个加1 一个减1来5轮 * * @author veliger@163.com * @version 1.0 * @date 2019-04-13 14:01 **/public class ProdConsumerTraditionDemo &#123;    public static void main(String[] args) &#123;        ShareData shareData = new ShareData();        new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 5; i++) &#123;                try &#123;                    shareData.increment();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;AA&quot;).start();        new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 5; i++) &#123;                try &#123;                    shareData.deIncrement();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;BB&quot;).start();    &#125;&#125;</code></pre><p>加锁是可以保证原子性和可见性的：</p><ul><li>JMM（Java Memory Model）中关于<code>synchronized</code>有如下规定，线程加锁时，必须清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取；线程在解锁时，需要把工作内存中最新的共享变量的值写入到主存，以此来保证共享变量的可见性。(ps这里是个泛指，不是说只有在退出synchronized时才同步变量到主存)</li></ul><h1 id="使用阻塞队列的生产者消费者模式"><a href="#使用阻塞队列的生产者消费者模式" class="headerlink" title="使用阻塞队列的生产者消费者模式"></a>使用阻塞队列的生产者消费者模式</h1><ul><li>代码示例:</li></ul><pre><code>import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;class Cake &#123;    private volatile Boolean FLAG = true;    private AtomicInteger atomicInteger = new AtomicInteger();    private BlockingQueue&lt;String&gt; blockingQueue = null;    public Cake(BlockingQueue&lt;String&gt; blockingQueue) &#123;        this.blockingQueue = blockingQueue;    &#125;    public void productCake() throws InterruptedException &#123;        String data = &quot;&quot;;        Boolean resultValue;        while (FLAG) &#123;            //保证原子性 ,线程安全,CAS            data = atomicInteger.incrementAndGet() + &quot;&quot;;            //blockingQueue有加锁线程安全 ,最多就是存入BlockingQueue中的顺序不是按照1,2,3但是不会出错            resultValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);            if (resultValue) &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t 线程生产&quot; + data + &quot;成功&quot;);            &#125;            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(&quot;老板叫停不在生产蛋糕&quot;);    &#125;    public void consumer() throws InterruptedException &#123;        String result = &quot;&quot;;        while (FLAG) &#123;            result = blockingQueue.poll(2L, TimeUnit.SECONDS);            if (result == null || result == &quot;&quot;) &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t 蛋糕超过两秒没有生产出来消费结束&quot;);                FLAG = false;                System.out.println();                System.out.println();                return;            &#125;            System.out.println(Thread.currentThread().getName() + &quot;\t 线程消费&quot; + result + &quot;成功&quot;);            System.out.println();            System.out.println();        &#125;    &#125;    public void stop() &#123;        FLAG = false;    &#125;&#125;/** * 不使用lock和synchronized的生产者消费者模式 * * @author xulingyun * @create 2020-11-06 10:45 */public class ProductAndConsumer &#123;    public static void main(String[] args) &#123;        Cake cake = new Cake(new ArrayBlockingQueue&lt;&gt;(3));        new Thread(() -&gt; &#123;            try &#123;                cake.productCake();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, &quot;product&quot;).start();        new Thread(() -&gt; &#123;            try &#123;                cake.consumer();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, &quot;consumer&quot;).start();        try &#123;            TimeUnit.SECONDS.sleep(5);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        cake.stop();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> 生产者消费者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产者 </tag>
            
            <tag> 消费者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列的使用</title>
      <link href="2020/11/07/zu-sai-dui-lie-de-shi-yong/"/>
      <url>2020/11/07/zu-sai-dui-lie-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="阻塞队列初认识"><a href="#阻塞队列初认识" class="headerlink" title="阻塞队列初认识"></a>阻塞队列初认识</h1><ul><li>当阻塞队列是空时,从队列中获取元素的操作将会被阻塞.</li><li>当阻塞队列是满时,往队列中添加元素的操作将会被阻塞.</li><li>同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞,知道其他线程从队列中移除一个或者多个元素或者全清空队列后使队列重新变得空闲起来并后续新增.</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>在多线程领域:所谓阻塞,在某些情况下会挂起线程(即线程阻塞),一旦条件满足,被挂起的线程优惠被自动唤醒</li><li>为什么需要使用<code>BlockingQueue</code></li><li>好处是我们不需要关心什么时候需要阻塞线程,什么时候需要唤醒线程,因为<code>BlockingQueue</code>都一手给你包办好了</li><li>在concurrent包 发布以前,在多线程环境下,我们每个程序员都必须自己去控制这些细节,尤其还要兼顾效率和线程安全,而这会给我们的程序带来不小的复杂度.</li></ul><p><img src="/medias/JUC/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="阻塞队列" title="阻塞队列"></p><h2 id="阻塞队列的种类及分析"><a href="#阻塞队列的种类及分析" class="headerlink" title="阻塞队列的种类及分析"></a>阻塞队列的种类及分析</h2><pre><code> 1. **` ArrayBlockingQueue`**:由数组结构组成的有界阻塞队列 2. **`LinkedBlockingQueue`**:由链表结构组成的有界阻塞队列(但默认大小是(`Integer.MAX_VALUE`)21亿 3. `PriorityBlockingQueue`:支持优先级排列的无界阻塞队列 4. `DelayQueue`:使用优先级队列实现的延迟无界阻塞队列 5. **`SynchronousQueue`**:不存储元素的阻塞队列，也即是单个元素的阻塞队列(个人定制版) 6. `LinkedTransferQueue`:有链表结构组成的无界阻塞队列 7. `LinkedBlocking`**`Deque`**:由链表结构组成的双向阻塞队列</code></pre><ul><li><strong><code>SynchronousQueue</code></strong>:没有容量与其他<code>BlcokingQueue</code>不同,<code>SynchronousQueue</code>是一个不存储元素的<code>BlcokingQueue</code>每个<code>put</code>操作必须要等待一个<code>take</code>操作,否则不能继续添加元素,反之亦然(只能使用<code>put()</code>,<code>take()</code>和<code>offer(E e, long timeout, TimeUnit unit)</code>,<code>poll(long timeout, TimeUnit unit)</code>，使用其他两组方法是因为没有存储空间直接抛异常或者返回false)</li></ul><pre><code>import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;/** * @author xulingyun * @create 2020-11-06 9:00 */public class BlockingQueueDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        //不能存储元素，个人定制版，只能使用过时不候offer（time），和不见不散put,使用add和offer直接抛异常或者返回false        SynchronousQueue&lt;String&gt; synchronousQueue = new SynchronousQueue&lt;&gt;();        new Thread(()-&gt;&#123;            try &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t put a&quot;);                synchronousQueue.put(&quot;a&quot;);                System.out.println(Thread.currentThread().getName() + &quot;\t put b&quot;);                synchronousQueue.put(&quot;b&quot;);                System.out.println(Thread.currentThread().getName() + &quot;\t put c&quot;);                synchronousQueue.put(&quot;c&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t1&quot;).start();        new Thread(()-&gt;&#123;            try &#123;                try &#123;                   TimeUnit.SECONDS.sleep(3);                &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;\t take&quot;);                System.out.println(synchronousQueue.take());                try &#123;                   TimeUnit.SECONDS.sleep(3);                &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;\t take&quot;);                System.out.println(synchronousQueue.take());                try &#123;                   TimeUnit.SECONDS.sleep(3);                &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;\t take&quot;);                System.out.println(synchronousQueue.take());            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t2&quot;).start();    &#125;    private static void offer2() throws InterruptedException &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        System.out.println(blockingQueue.offer(&quot;a&quot;, 1, TimeUnit.SECONDS));        System.out.println(blockingQueue.offer(&quot;b&quot;, 1, TimeUnit.SECONDS));        System.out.println(blockingQueue.offer(&quot;c&quot;, 1, TimeUnit.SECONDS));        //过时不候        System.out.println(blockingQueue.offer(&quot;d&quot;, 1, TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));    &#125;    private static void offer() &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        System.out.println(blockingQueue.offer(&quot;a&quot;));        System.out.println(blockingQueue.offer(&quot;b&quot;));        System.out.println(blockingQueue.offer(&quot;c&quot;));        System.out.println(blockingQueue.offer(&quot;x&quot;));        System.out.println(blockingQueue.peek());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());    &#125;    private static void take() throws InterruptedException &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        blockingQueue.put(&quot;a&quot;);        blockingQueue.put(&quot;b&quot;);        blockingQueue.put(&quot;c&quot;);        //不见不散 一直阻塞//        blockingQueue.put(&quot;x&quot;);        System.out.println(blockingQueue.take());        System.out.println(blockingQueue.take());        System.out.println(blockingQueue.take());        System.out.println(blockingQueue.take());    &#125;    private static void exception() &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        System.out.println(blockingQueue.add(&quot;a&quot;));        System.out.println(blockingQueue.add(&quot;b&quot;));        System.out.println(blockingQueue.add(&quot;c&quot;));        //队列满抛异常 Queue full//        System.out.println(blockingQueue.add(&quot;x&quot;));        //检查队列头元素        System.out.println(blockingQueue.element());        System.out.println(blockingQueue.remove());        System.out.println(blockingQueue.remove());        System.out.println(blockingQueue.remove());        //队列空报异常NoSuchElementException        System.out.println(blockingQueue.remove());    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> 阻塞队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四种锁的认识</title>
      <link href="2020/11/07/si-chong-suo-de-ren-shi/"/>
      <url>2020/11/07/si-chong-suo-de-ren-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>​        <strong>公平锁：</strong></p><ul><li><p>是指多个线程按照申请锁的顺序来获取锁类似排队打饭 先来后到</p><p><strong>非公平锁：</strong></p></li><li><p>​    是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象</p><p><strong>公平锁/非公平锁</strong></p><ul><li><p>并发包<code>ReentrantLock</code>的创建可以指定构 造函数的boolean类型来得到公平锁或者非公平锁 默认是非公平锁</p></li><li><p><code>ReentrantLock</code>而言,<br>通过构造哈希数指定该锁是否是公平锁 默认是非公平锁 非公平锁的优点在于吞吐量比公平锁大.</p></li></ul></li></ul><pre><code>   对于`synchronized`而言 也是一种非公平锁.</code></pre><p><img src="/medias/JUC/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="公平锁和非公平锁" title="公平锁和非公平锁"></p><h1 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁/递归锁"></a>可重入锁/递归锁</h1><pre><code>*    可重入锁（也叫递归锁），`ReentrantLock`和`Synchronized`都是可重入锁，可重入锁的就是同一线程外层函数获得锁之后内层还有同一个锁可以直接进入而不会陷入死锁，进入内层函数时自动获得锁，**线程可以进入任何一个它已经拥有的锁所同步的代码中**</code></pre><ul><li>可重入锁(也叫做递归锁)<pre><code>* 指的是同一先生外层函数获得锁后,内层敌对函数任然能获取该锁的代码* 在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁* 也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块</code></pre><ul><li>   代码示例：</li></ul></li></ul><pre><code>import java.util.concurrent.locks.ReentrantLock;class ReentrantLockTest&#123;    ReentrantLock lock = new ReentrantLock();    public void method1()&#123;        lock.lock();        try &#123;            System.out.println(&quot;发送短信&quot;);            method2();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void method2()&#123;        lock.lock();        try &#123;            System.out.println(&quot;发送邮箱&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;/** * @author xulingyun * @create 2020-10-30 10:00 */public class LockTest &#123;    public static void main(String[] args) &#123;        ReentrantLockTest reentrantLockTest = new ReentrantLockTest();        reentrantLockTest.method1();    &#125;&#125;</code></pre><ul><li>也可以加多个<code>lock.lock()</code>只要有对应的<code>lock.unlock()</code>即可，不会陷入死锁，要是数量不对应会产生死锁</li></ul><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><pre><code>import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;/** * 手写自旋锁：好处不会阻塞，缺点cpu消耗大 * * @author xulingyun * @create 2020-10-30 10:47 */public class SpinLock &#123;    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();    public void myLock() &#123;        Thread thread = Thread.currentThread();        while (!atomicReference.compareAndSet(null, thread)) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + &quot;线程获得锁!&quot;);    &#125;    public void myUnLock() &#123;        Thread thread = Thread.currentThread();        atomicReference.compareAndSet(thread, null);        System.out.println(Thread.currentThread().getName() + &quot;线程释放锁!&quot;);    &#125;    public static void main(String[] args) &#123;        SpinLock spinLock = new SpinLock();        new Thread(() -&gt; &#123;            spinLock.myLock();            try &#123;                TimeUnit.SECONDS.sleep(5);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            spinLock.myUnLock();        &#125;, &quot;t1&quot;).start();        //主线程睡眠一秒保证t1线程先获得锁        try &#123;            TimeUnit.SECONDS.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        new Thread(() -&gt; &#123;            spinLock.myLock();            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            spinLock.myUnLock();        &#125;, &quot;t2&quot;).start();    &#125;&#125;</code></pre><ul><li>优点：尝试获得锁时不会被阻塞，而是采用循环的方式去尝试获得锁，这样的好处是减少上下文切换消耗的资源。</li><li>缺点：自旋锁虽然减少了上下文切换消耗的资源但是会增加<code>cpu</code>资源的消耗，因为要是某个线程一直在循环尝试获得锁<code>cpu</code>一直在为他消耗性能。</li></ul><h1 id="独占锁-写锁-共享锁-读锁"><a href="#独占锁-写锁-共享锁-读锁" class="headerlink" title="独占锁(写锁)/共享锁(读锁)"></a>独占锁(写锁)/共享锁(读锁)</h1><ul><li>独占锁(写锁) 指该锁一次只能被一个线程所占有,对于<code>ReentrantLock</code>和<code>Synchronized</code>来说都是独占锁</li><li>共享锁(读锁) 指该锁可以被多个线程所共有</li><li>对于<code>ReentrantReadWriteLock</code>其写锁是独占锁，读锁是共享锁</li><li>读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程都是互斥</li></ul><p>代码示例：</p><pre><code>import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantReadWriteLock;class MyCache &#123;    private volatile Map&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();    public void put(String key, Object value) &#123;        rwLock.writeLock().lock();        try &#123;            System.out.println(Thread.currentThread().getName() + &quot;正在写入:&quot; + key);            hashMap.put(key, value);            System.out.println(Thread.currentThread().getName() + &quot;写入完成!&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            rwLock.writeLock().unlock();        &#125;    &#125;    public void get(String key) &#123;        rwLock.readLock().lock();        try &#123;            System.out.println(Thread.currentThread().getName() + &quot;正在读取&quot;);            try &#123;                TimeUnit.MILLISECONDS.sleep(300);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            Object result = hashMap.get(key);            System.out.println(Thread.currentThread().getName() + &quot;读取成功：&quot; + result);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            rwLock.readLock().unlock();        &#125;    &#125;&#125;/** * 读写锁 * 读锁：共享锁 * 写锁：独占锁 * 读读：不排斥 * 读写：排斥 * 写写：排斥 * 写操作 原子+独占 整个过程必须是一个完成的统一整体 中间不允许被分割 被打断 * @author xulingyun * @create 2020-10-30 12:17 */public class ReadWriteLockDemo &#123;    public static void main(String[] args) &#123;        MyCache cache = new MyCache();        for (int i = 0; i &lt; 5; i++) &#123;            final int temp = i;            new Thread(() -&gt; &#123;                cache.put(temp + &quot;&quot;, temp + &quot;&quot;);                cache.get(temp + &quot;&quot;);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公平锁 </tag>
            
            <tag> 非公平锁 </tag>
            
            <tag> 可重入锁 </tag>
            
            <tag> 递归锁 </tag>
            
            <tag> 自旋锁 </tag>
            
            <tag> 独占锁(写锁) </tag>
            
            <tag> 共享锁(读锁) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABA问题</title>
      <link href="2020/10/29/aba-wen-ti/"/>
      <url>2020/10/29/aba-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="ABA问题的产生"><a href="#ABA问题的产生" class="headerlink" title="ABA问题的产生"></a>ABA问题的产生</h1><p><img src="/medias/JUC/ABA%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F.png" alt="ABA问题的产生" title="ABA问题的产生"></p><ul><li><p>解决</p><p>使用原子引用，增加版本（类似与乐观锁）。使用atomic包中的<code>AtomicStampedReference</code>类解决ABA问题，业务逻辑允许也可以不解决ABA</p></li><li><p>代码示例：</p><pre><code>package com.xu.juc;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.atomic.AtomicStampedReference;/** * @author xulingyun * @create 2020-10-29 18:21 */public class ABADemo &#123;    static AtomicReference&lt;Integer&gt; atomicReference = new AtomicReference&lt;&gt;(100);    static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100, 1);    public static void main(String[] args) &#123;        System.out.println(&quot;==========ABA的产生==========&quot;);        new Thread(() -&gt; &#123;            atomicReference.compareAndSet(100, 101);            atomicReference.compareAndSet(101, 100);        &#125;, &quot;t1&quot;).start();        new Thread(() -&gt; &#123;            //睡眠一秒让t1线程进行一次ABA            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            boolean flag = atomicReference.compareAndSet(100, 2020);            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + flag + &quot;修改后的值：&quot; + atomicReference);        &#125;, &quot;t2&quot;).start();        try &#123;            TimeUnit.SECONDS.sleep(2);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;==========ABA的解决==========&quot;);        new Thread(() -&gt; &#123;            int stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + &quot;第一次版本号：&quot; + stamp);            //睡眠一秒使t4获取相同的stamp            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);            System.out.println(Thread.currentThread().getName() + &quot;第二次版本号：&quot; + atomicStampedReference.getStamp());            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);            System.out.println(Thread.currentThread().getName() + &quot;第三次版本号：&quot; + atomicStampedReference.getStamp());        &#125;, &quot;t3&quot;).start();        new Thread(() -&gt; &#123;            int stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + &quot;第一次版本号：&quot; + stamp);            //睡眠三秒让t3线程执行完ABA            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            boolean flag = atomicStampedReference.compareAndSet(100, 2020, stamp, stamp + 1);            System.out.println(Thread.currentThread().getName() + &quot;当前修改是否成功：&quot; + flag + &quot;\t最终atomicStampedReference值:&quot; + atomicStampedReference.getReference());        &#125;, &quot;t4&quot;).start();    &#125;&#125;</code></pre><p><code>result</code>:</p><pre><code>==========ABA的产生==========t2    true修改后的值：2020==========ABA的解决==========t3第一次版本号：1t4第一次版本号：1t3第二次版本号：2t3第三次版本号：3t4当前修改是否成功：false    最终atomicStampedReference值:100</code></pre><p>第一次没有加版本控制产生ABA问题，第二次使用了<code>AtomicStampedReference</code>类解决了ABA问题，类似于乐观锁加上版本号解决ABA。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> ABA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> ABA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS的底层分析</title>
      <link href="2020/10/29/cas-de-di-ceng-fen-xi/"/>
      <url>2020/10/29/cas-de-di-ceng-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="CAS-Compare-And-Swap-比较交换"><a href="#CAS-Compare-And-Swap-比较交换" class="headerlink" title="CAS (Compare And Swap)比较交换"></a>CAS (Compare And Swap)比较交换</h1><h2 id="为什么atomic包下面的类可以保证原子性？"><a href="#为什么atomic包下面的类可以保证原子性？" class="headerlink" title="为什么atomic包下面的类可以保证原子性？"></a>为什么atomic包下面的类可以保证原子性？</h2><p>​    1.  atomic包中的getAndIncrement使用的是unsafe中的方法，unsafe类内是调用系统资源的方法<code>native</code>修饰有很多，其中在实现getAndIncrement时使用了<code>compareAndSwapInt</code>方法，<code>compareAndSwapInt</code>是cpu原语(下面解释)，所以在修改value时是不会出现多线程不安全的问题，保证了原子性</p><p><img src="/medias/JUC/CAS%E6%BA%90%E7%A0%81.png" alt="CAS源码" title="CAS源码"></p><ol start="2"><li><p>在getAddInt第一个变量是代表当前对象，第二个变量是代表内存偏移量(即在内存地址的值)，第三个变量代表修改的值</p></li><li><p>var5获取到内存地址的值然后在修改时与重新获取的值做比较，若是值不变就修改当前内存地址的值，且方法true取反，循环结束</p></li><li><p>若是值与之前获取的var5不一致则修改失败，返回false，取反循环继续</p></li><li><p><strong><code>compareAndSwapInt</code>方法是一个cpu原语</strong></p></li><li><p>cpu原语：计算机进程的控制通常由原语完成。所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被<strong>中断</strong>(个人理解:有点类似与锁)。</p></li></ol><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p><img src="/medias/JUC/CAS%E7%BC%BA%E7%82%B9.png" alt="CAS缺点" title="CAS缺点"></p><ol><li>cpu开销可能会大</li><li>只能保证一个共享变量的原子性</li><li>产生ABA问题（请看下一篇博客）</li></ol><h2 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h2><p>​      unsafe是CAS的核心类由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后面,基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法.<br>注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> cpu原语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> unsafe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式最终版</title>
      <link href="2020/10/29/dan-li-mo-shi-zui-zhong-ban/"/>
      <url>2020/10/29/dan-li-mo-shi-zui-zhong-ban/</url>
      
        <content type="html"><![CDATA[<pre><code># 单例模式</code></pre><p><img src="/medias/JUC/DCL%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8.png" alt="DCL线程不安全" title="DCL线程不安全"></p><p><img src="/medias/JUC/DCL%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A82.png" alt="DCL线程不安全" title="DCL线程不安全"></p><pre><code>public class SignalTonDemo &#123;    private static volatile SignalTonDemo instance = null;    private SignalTonDemo() &#123;        System.out.println(Thread.currentThread().getName() + &quot;\t实例化对象&quot;);    &#125;    /**DCL(Double Check Lock)双重检查锁     * 线程还未安全，可能发生指令重排序，会使返回的instance为null     * 实例化对象分为三个阶段     * 1.分配空间     * 2.初始化     * 3.被引用     * 在2,3阶段没有依赖关系可以被指令重排序，先被引用在初始化     * 有几率变成在分配空间后 初始化前下一个线程访问if返回false     * ，然后方法方法instance，因为还未初始化所以instance为null     *     * 使用volatile解决，volatile禁止指令重排序    */    public static SignalTonDemo getInstance() &#123;        if (instance == null) &#123;            synchronized (SignalTonDemo.class) &#123;                if (instance == null) &#123;                    instance = new SignalTonDemo();                &#125;            &#125;        &#125;        return instance;    &#125;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(() -&gt; &#123;                SignalTonDemo.getInstance();            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>加锁是可以保证原子性和可见性的：</p><ul><li>JMM（Java Memory Model）中关于<code>synchronized</code>有如下规定，线程加锁时，必须清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取；线程在解锁时，需要把工作内存中最新的共享变量的值写入到主存，以此来保证共享变量的可见性。(ps这里是个泛指，不是说只有在退出synchronized时才同步变量到主存)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC的认识</title>
      <link href="2020/10/27/jvm-de-ren-shi/"/>
      <url>2020/10/27/jvm-de-ren-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="GC的作用域"><a href="#GC的作用域" class="headerlink" title="GC的作用域"></a>GC的作用域</h1><ul><li>GC作用于方法区(Method Area)和堆(heap)</li><li>GC分为三个区 ，Young区，Old区，Perm区</li><li>次数上频繁回收Young区</li><li>次数上较少收集Old区</li><li>基本不动Perm区</li></ul><h1 id="GC算法的总体概述"><a href="#GC算法的总体概述" class="headerlink" title="GC算法的总体概述"></a>GC算法的总体概述</h1><ul><li>JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收都是指新生代</li><li>因此GC按照回收的区域有分了两种类型：一种是普通的GC<code>minor GC</code>，一种是全局GC<code>major GC</code> or <code>Full GC</code><ul><li>普通GC：只针对新生代区域</li><li>全局GC：针对年老代，偶尔伴随对新生代和永久代的GC</li></ul></li></ul><h1 id="GC的四大回收算法"><a href="#GC的四大回收算法" class="headerlink" title="GC的四大回收算法"></a>GC的四大回收算法</h1><ol><li><p>引用计数法：</p><ul><li><p>缺点：</p><ul><li>每次对象赋值时都要维护引用计数器，且计数器本身也有一定消耗；</li><li>较难处理循环引用</li></ul></li><li><p>JVM一般不采用这种方式</p></li></ul></li><li><p>复制算法<code>Copying</code>：</p><ul><li><p>年轻代采用的<code>minor GC</code>:这种GC就是复制算法</p></li><li><p><img src="/medias/GC/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法" title="复制算法"></p></li><li><p>Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old  generation中，也即一旦收集后，Eden是就变成空的了。<br>  当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。</p><p>-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数</p></li><li><p> HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p></li><li><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p></li><li><p>因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 </p><ul><li>缺点： <ol><li>它浪费了一半的内存，这太要命了。 </li><li>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</li></ol></li></ul></li></ul></li><li><p>标记清除<code>Mark-Sweep</code>：</p><ul><li>老年代一般是标记清除和标记压缩的混合实现</li><li><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="标记清除" title="标记清除"></li><li>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。<br> 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象      标记为存活的对象。<br> 清除：遍历整个堆，把未标记的对象清除。<br>用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。</li><li>缺点：<ul><li>此算法需要暂停整个应用，会产生内存碎片</li><li>首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲</li><li>其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。</li></ul></li></ul></li><li><p>标记压缩<code>Mark-Compact</code>：</p><ul><li><p><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9.png" alt="标记压缩" title="标记压缩"></p></li><li><p>  在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 </p><p> 　　标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价</p></li><li><p>缺点：</p><ul><li>标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法</li></ul></li></ul></li><li><p>标记清除压缩<code>Mark-Sweep-Compact</code>：</p><ul><li><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%8E%8B%E7%BC%A9.png" alt="标记清除压缩" title="标记清除压缩"></li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）</li><li>内存整齐度：复制算法=标记整理算法&gt;标记清除算法</li><li>内存利用率：标记整理算法=标记清除算法&gt;复制算法</li></ol><p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程</p><pre><code>无，没有最好的算法，只有最合适的算法。==========&gt;分代收集算法。</code></pre><ul><li>年轻代(Young Gen)  <ul><li>年轻代特点是区域相对老年代较小，对像存活率低。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul></li><li>老年代(Tenure Gen)<ul><li>老年代的特点是区域较大，对像存活率高。</li><li>这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</li></ul></li><li><strong>Mark阶段的开销与存活对像的数量成正比</strong>，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。</li><li><strong>Sweep阶段的开销与所管理区域的大小形正相关</strong>，但Sweep“就地处决”的特点，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。</li><li><strong>Compact阶段的开销与存活对像的数据成开比</strong>，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。</li><li>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>JVM内存模型以及分区，需要详细到每个分区放什么？</li><li>堆里面的分区：Eden，survival，from ，to ，老年区各自的特点？</li><li>GC的三种收集方法：标记清除，标记压缩，复制算法的原理与特点，分别用在什么地方？</li><li>Minor GC与Full GC分别发生在什么时候？</li></ol>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC的基本认识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile是什么?</title>
      <link href="2020/10/26/volatile-shi-shi-me/"/>
      <url>2020/10/26/volatile-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="valatile是什么？"><a href="#valatile是什么？" class="headerlink" title="valatile是什么？"></a>valatile是什么？</h1><ul><li><p><strong>volatile是一种java虚拟机提供轻量级的同步机制</strong></p></li><li><p><strong>volatile的三个特性</strong></p><ol><li><p>保证可见性</p><ul><li><p>JMM(Java Member Model)Java内存模型</p></li><li><p>由于JVM运行的实体是线程，而每个线程创建时JVM都会为其创建一个工作空间（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主存中，主内存是共享区域，所有线程都可以访问，<strong>但线程对变量的操作（读取赋值等）必须在工作空间中进行，首先要从主内存拷贝数据到工作空间，然后对变量进行操作，操作完成在写回主内存</strong>，不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存中的<strong>变量拷贝副本</strong>，因此不同线程间不能访问对方工作内存，线程间的传值必须通过主内存来完成，其简要访问过程如下：</p><p><img src="/medias/JUC/JMM%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4.png" alt="JMM主内存和工作空间" title="JMM主内存和工作空间"></p></li><li><h2 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h2><pre><code>class Number&#123;    Integer number = 0;    public void addTo30()&#123;        number = 30;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) &#123;        Number number = new Number();        new Thread(()-&gt;&#123;            System.out.println(&quot;Number begin&quot;);            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            number.addTo30();            System.out.println(&quot;修改number=30&quot;);        &#125;, &quot;AAA&quot;).start();        //如果number没有改变就一直死循环        //结果死循环程序未结束，因为主线程复制了number=0到工作空间，之后AAA线程修改了number主线程并不知道        while (number.number == 0)&#123;        &#125;        System.out.println(&quot;Number &quot; + number.number);    &#125;&#125;</code></pre><p><img src="/medias/JUC/%E6%9C%AA%E4%BD%BF%E7%94%A8volatitle.png" alt="未使用volatitle" title="未使用volatitle"></p></li><li><pre><code>class Number&#123;    volatile Integer number = 0;    public void addTo30()&#123;        number = 30;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) &#123;        Number number = new Number();        new Thread(()-&gt;&#123;            System.out.println(&quot;Number begin&quot;);            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            number.addTo30();            System.out.println(&quot;修改number=30&quot;);        &#125;, &quot;AAA&quot;).start();        //如果number没有改变就一直死循环        //结果循环结束，因为number使用了volatile，在线程AAA修改number写回主内存时，        // 主内存通知了main线程，main线程重新读取number值所以循环结束        while (number.number == 0)&#123;        &#125;        System.out.println(&quot;Number &quot; + number.number);    &#125;&#125;</code></pre><p><img src="/medias/JUC/%E4%BD%BF%E7%94%A8volatitle.png" alt="使用volatitle" title="使用volatile"></p></li></ul></li><li><p>不保证原子性</p><ul><li><p>使用volatile的++操作</p><pre><code>class Number&#123;    volatile Integer number = 0;    public void addPlusPlus()&#123;        /*        number++不是原子操作        第一步：取出number数据        第二步：number加一        第三步：写回数据             */        number++;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) throws InterruptedException &#123;         //减少计数JUC辅助工具类        CountDownLatch countDownLatch = new CountDownLatch(20);        Number number = new Number();        for (int i = 1; i &lt;= 20; i++) &#123;            new Thread(()-&gt;&#123;                for (int j = 0; j &lt; 1000; j++) &#123;                    /**                     * 在工作空间volatile虽然会然主内存通知工作空间数据的修改                     * 但是在一个线程写入数据的同时主内存开始通知，其他线程还没被通知到也写入数据到主内存中                     * 产生了写覆盖，所以最后的数值没有到达20000                     */                    number.addPlusPlus();                &#125;                countDownLatch.countDown();            &#125;,&quot;BBB&quot;).start();        &#125;        countDownLatch.await();        System.out.println(&quot;number最终得分：&quot; + number.number);    &#125;&#125;</code></pre><pre><code>result:number最终得分：18167Process finished with exit code 0</code></pre><p>结果表明volatile不保证原子性，虽然使用synchronized可以解决该问题，但是未免有点杀鸡用牛刀，其他解决方法：</p></li><li><p>使用atomicInteger类型可以解决原子性问题：</p><pre><code>class Number&#123;    volatile Integer number = 0;    AtomicInteger atomicInteger = new AtomicInteger();    public void addPlusPlus()&#123;        /*        number++不是原子操作        第一步：取出number数据        第二步：number加一        第三步：写回数据         */        number++;        atomicInteger.getAndIncrement();    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) throws InterruptedException &#123;        //减少计数JUC辅助工具类        CountDownLatch countDownLatch = new CountDownLatch(20);        Number number = new Number();        for (int i = 1; i &lt;= 20; i++) &#123;            new Thread(()-&gt;&#123;                for (int j = 0; j &lt; 1000; j++) &#123;                    number.addPlusPlus();                &#125;                countDownLatch.countDown();            &#125;,&quot;BBB&quot;).start();        &#125;        countDownLatch.await();        System.out.println(&quot;number最终得分：&quot; + number.number);        System.out.println(&quot;atomicInteger最终得分：&quot; + number.atomicInteger);    &#125;&#125;</code></pre><pre><code>result:number最终得分：18923atomicInteger最终得分：20000Process finished with exit code 0</code></pre></li></ul></li></ol></li></ul><ol start="3"><li><p>禁止指令重排</p><p><img src="/medias/JUC/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="指令重排序" title="指令重排序"></p><p>加上volatile可以使指令不重排序</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="2020/10/23/da-jian-ge-ren-bo-ke/"/>
      <url>2020/10/23/da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客需要node-js的npm和git环境"><a href="#搭建博客需要node-js的npm和git环境" class="headerlink" title="搭建博客需要node.js的npm和git环境"></a>搭建博客需要node.js的npm和git环境</h1><h2 id="首先下载npm和git"><a href="#首先下载npm和git" class="headerlink" title="首先下载npm和git"></a>首先下载<a href="http://nodejs.cn/download/">npm</a>和<a href="https://git-scm.com/download/">git</a></h2><h2 id="安装hexo运行环境"><a href="#安装hexo运行环境" class="headerlink" title="安装hexo运行环境"></a>安装hexo运行环境</h2><ol><li><p>npm和git安装完成后的检验是 npm -v 和 node -v</p></li><li><p>如图：</p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%A3%80%E9%AA%8Cnpm%E5%92%8Cnode.png" alt="install" title="node"></p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%A3%80%E9%AA%8Cgit.png" alt="git" title="git"> </p></li></ol><h2 id="安装hexo基本框架"><a href="#安装hexo基本框架" class="headerlink" title="安装hexo基本框架"></a>安装hexo基本框架</h2><ol><li><p>新建一个文件夹给自己的博客找个小窝</p></li><li><p>然后进入新建的文件夹，右击Git Bash Here</p></li><li><pre><code>//第一条   这是安装hexo的基础框架 , npm安装到全局，熟悉的话可以安装局部npm install -g hexo//第二条   这是初始化hexo框架 这个可能会比较慢(要有耐心)hexo init//第三条 安装所需要的组件npm install//第四条 编译生成静态页面hexo g//第五条 启动本地服务hexo s</code></pre></li></ol><ol start="4"><li><p>启动后的结果<img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%BF%90%E8%A1%8C.png" alt="yans" title="演示结果"></p></li><li><p>然后访问 <a href="http://localhost:4000/">http://localhost:4000/</a> <img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%BC%94%E7%A4%BA.png" alt="result" title="页面"></p></li></ol><h1 id="hexo命令大全："><a href="#hexo命令大全：" class="headerlink" title="hexo命令大全："></a>hexo命令大全：</h1><pre><code>hexo n &quot;博客名字&quot; #执行成功后会在根目录下\source\_posts生成一个同名的md文件 #编写这个文件就可 然后执行 hexo clean hexo g  hexo d 部署到github上去hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g  #生成静态网页hexo s  #启动服务预览hexo d  #开始部署hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署</code></pre><h1 id="github配置个人博客免域名"><a href="#github配置个人博客免域名" class="headerlink" title="github配置个人博客免域名"></a>github配置个人博客免域名</h1><ol><li><p>注册一个github账户，用邮箱就行<img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/github%E5%88%9B%E5%BB%BArepositories.png" alt="github" title="github配置"></p></li><li><p>然后点击new </p></li><li><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/github.png" alt="github" title="gitthub"></p></li><li><p>我的因为创建过了所以报错</p></li><li><p>创建repository的名字一定要是 用户名.github.io,不然访问不到</p></li><li><p>之后将code哪里http的git连接复制粘贴到 安装好的hexo的 <code>_config.yml</code> 中</p><pre><code>deploy:  type: git  repo: https://github.com/xu196/xu196.github.io.git  branch: master</code></pre><p>里面 , 运行下面代码在根目录的命令行界面</p><pre><code>hexo cleanhexo ghexo d</code></pre><ul><li>如果上面repo配置的是http的路径<code>hexo d</code> 之后需要输入github的用户名和密码</li><li>要是想要无密码push就需要配置ssh的路径，这里不做过多说明，需要自行百度</li><li><code>hexo d</code> 成功页面</li><li><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/push%E6%88%90%E5%8A%9F.png" alt="push" title="push to github"></li><li>接下来就可以访问博客了， 就是之前设置的<code>repository</code>名字，我的是<code>xly-star.github.io</code></li><li>接下来就可以尽情的开发自己的博客了</li><li>美化博客请看接下来的后续博客！</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
