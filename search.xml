<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>旅游规划与开发复习</title>
      <link href="2020/12/22/lu-you-gui-hua-yu-kai-fa-fu-xi/"/>
      <url>2020/12/22/lu-you-gui-hua-yu-kai-fa-fu-xi/</url>
      
        <content type="html"><![CDATA[<p> 9:53:54</p><h1 id="项目一"><a href="#项目一" class="headerlink" title="项目一"></a>项目一</h1><ul><li>旅游规划的定义是对某一区域内未来旅游系统的发展目标和实现方式的整体部署过程，旅游规划经政府相关部门的批准后，是该区域进行旅游开发建设的依据。</li><li>根据旅游规划的性质分类，分为一旅游发展战略规划。二概念性旅游规划。（王建军认为，概念性旅游规划是指编制旅游规划前期的一种研讨性规划手段，是一种在理想状态下对旅游开发地旅游业发展未来的前瞻性把握和创造性构思内容，以结构上整体上的概要性谋划为主）三旅游建设规划。</li><li>根据旅游发展的阶段性分类<ul><li>开发性旅游规划</li><li>发展性旅游规划</li><li>调整性旅游规划</li></ul></li><li>旅游开发的概念，旅游开发一般是指为发挥提升旅游资源对游客的吸引，使得潜在的旅游资源优势转化成为现实的经济效益，并使旅游活动得以实现的技术经济行为。</li><li>生态旅游是指通过利用未受人类开发的自然生态资源开展的旅游活动。<br>生态旅游规划的原则，<ul><li>整体优化原则</li><li>特色化原则</li><li>可持续发展原则。</li></ul></li></ul><h1 id="项目二"><a href="#项目二" class="headerlink" title="项目二"></a>项目二</h1><ul><li>旅游发展规划是指根据旅游业的历史，现状和市场要素的变化所制定的目标体系，以及为实现目标体在特定的发展条件下对旅游发展的要素所作的安排。</li><li>旅游发展规划的任务<br>明确旅游业在国民经济和社会发展中的地位与作用，提出旅游业发展目标，优化旅游业发展的要素结构与空间布局，安排旅游业发展优先项目，促进旅游业持续，健康，稳定发展。</li><li>概念性旅游规划的编制方法：<br>（三）人工再造法<br>人工再造法首先要进行区域还原，在结构上与整体上将规划区域的大致样貌进行恢复，保留可利用资源，并按照整体规划进行改造。其次进入原貌加工或场景再现阶段，辅以投影，音响等现代先进技术，而后进行景观重建。<br>人工再造法主要是两个方面，一是利用人工与科技，恢复曾经的自然，人文或历史景观，或建设人造奇景，是一个从无到有的过程，这类规划通常在现存旅游资源相对缺乏的区域。二是对原功能丧失的区域，改建开发特色旅游。</li><li>旅游区规划<br>旅游区规划是指为了保护，开发，利用和经营管理旅游区，使其发挥多种功能和作用而进行的各项旅游要素的统筹部署和具体安排。</li><li>旅游区总体规划的主要内容<br>旅游区开发建设之前，原则上应编制总体规划。小型旅游区可直接编制控制性详细规划，旅游区总体规划的期限一般为10到20年。<ol><li>旅游区客源市场的分析与预测</li><li>界定旅游区范围进行现状调查和分析，对旅游资源进行科学评价</li><li>确定旅游区的性质和主题形象</li><li>确定旅游区的功能分区和土地利用，测算规划期内的旅游容量</li><li>旅游交通规划</li><li>景观系统和绿地系统的总体布局</li><li>旅游基础设施，服务设施和附属设施规划</li><li>防灾系统和安全系统规划</li><li>研究并确定旅游区资源的保护范围和保护措施</li><li>旅游区的环境卫生系统布局，提出防止和治理污染的措施</li><li>提出旅游区近期建设规划，进行重点项目策划</li><li>提出总体规划的实施步骤，措施和方法，以及规划，建设，运营中的管理意见</li><li>对旅游区开发建设进行总体投资分析</li></ol></li><li>旅游区控制性详细规划概念<br>旅游区控制性详细规划是在旅游区总体规划的基础和框架下，对特定旅游区内的建设开发用地进行深入的控制性规划设计。</li></ul><h1 id="项目三"><a href="#项目三" class="headerlink" title="项目三"></a>项目三</h1><ul><li>旅游发展中存在的问题<ol><li>旅游管理体制</li><li>旅游发展政策</li><li>旅游发展思路</li><li>旅游产品开发</li><li>旅游产业布局</li><li>旅游形象塑造</li><li>旅游市场开拓</li><li>旅游资金来源</li><li>旅游基础设施</li><li>旅游配套设施</li><li>旅游产业体系</li><li>旅游人力资源</li><li>旅游环境保护</li><li>旅游发展效应</li></ol></li><li>旅游发展问题诊断的基本原则<ol><li>分清主次抓重点</li><li>透过现象看本质</li></ol></li><li>旅游发展问题诊断的主要方法<ol><li>实地观察法</li><li>统计资料分析法</li><li>理论分析法</li><li>经典调查法</li><li>游客调查法</li><li>比较法</li><li>假设法</li></ol></li><li>旅游发展的目标体系<br>按目标的时间远近不同划分<br>按目标的时间远近不同划分规划目标可分为近期目标，中期目标与远期目标。</li></ul><h1 id="项目四旅游资源调查与评价"><a href="#项目四旅游资源调查与评价" class="headerlink" title="项目四旅游资源调查与评价"></a>项目四旅游资源调查与评价</h1><ul><li><p>明确旅游资源的分类原则</p><ol><li>相似性与差异性原则</li><li>与概念一致原则</li><li>系统性原则<br>旅游资源是由各种不同的资源个体组成的一个系统，因此，在对旅游资源进行分类时，必须遵循系统性原则，包含逻辑对应，逐级划分，相互独立，三层含义。</li><li>可操作性原则</li></ol></li><li><p>确定旅游资源的分类依据</p><ol><li>成因</li><li>属性</li><li>功能</li><li>时间</li><li>其他</li></ol></li><li><p>明确旅游资源评价的内容</p><ol><li>旅游资源自身评价<ol><li>资源的性质</li><li>旅游资源的价值</li><li>旅游资源的功能</li><li>旅游资源的特色</li><li>旅游资源的密度</li><li>旅游资源的组合度</li><li>旅游资源容量</li></ol></li><li>资源开发评价<ol><li>区位环境</li><li>自然环境</li><li>人文环境</li><li>客源环境</li><li>政治环境与投资环境</li><li>施工环境</li></ol></li></ol></li><li><p>旅游资源单体评价得分决定该旅游资源的评价等级84页</p></li><li><p>应用旅游资源定性评价法</p><ol><li>“三三六”评价法<br>是指对旅游地的评价，应从旅游资源具有的三大价值，开发后产生的三大效益和开发中所涉及的六大条件，几个方面去进行系统评价。<br>三大价值是指旅游资源本身所具有的历史文化价值，艺术观赏价值和科学考察价值。历史文化价值属于人文旅游资源范畴。<br>三大效益是指经济效益，社会效益和环境效益<br>六大条件是指景区的地理环位置和交通条件，景物或景类的地域组合条件，景区旅游容量条件，施工难易条件，投资能力条件，旅游客源市场条件。</li><li>“六字七标准”评价法<br>主要从两个方面对旅游资源进行评价，一是旅游资源本身，二是旅游资源所处的环境。</li><li>指数评价法<br>旅游资源的指数评价法分为三步<br>一调查分析旅游资源的开发利用现状，吸引力及外部区域环境要求有准确的定量统计资料<br>二调查分析旅游需求，主要内容有旅游客数量，旅游者构成，逗留时间，旅游花费趋向，需求结构及节律性等。<br>三拟定总体评价式，建立表达旅游资源特质，旅游需求与旅游资源之间关系的若干量化模型。</li></ol></li></ul><h1 id="项目五"><a href="#项目五" class="headerlink" title="项目五"></a>项目五</h1><ul><li>明确调查类型<ol><li>按调查的目的分类<br>按调查的目的可以分为探索性调查，描述性调查和因果性调查。</li><li>按选择对象的方法分类<br>按选择对象的方法，可分为全面调查，典型调查和抽样调查。</li><li>按资料的来源分类<br>按资料的来源可分为第二手资料调查，第一手资料调查和观察调查。</li><li>按交流的方式分类<br>询问调查可以分为面谈法，电话询问法，邮寄调查法，留置问卷法，新闻媒介调查法，网络调查法等</li></ol></li><li>问卷的结构<br>一份完整的问卷，应当由标题，说明，被调查者的基本信息，调查主体内容，编码等部分组成。</li><li>抽样步骤的设计<ol><li>确定调查总体</li><li>调查个体编号</li><li>确定样本容量</li><li>选择抽样方式，进行样本调查</li><li>推算调查总体结果</li></ol></li><li>有效的目标市场应遵循的原则<ol><li>目标市场应具有可测量性</li><li>目标市场应具有可进入性</li><li>目标市场应具有可盈利性</li><li>目标市场应具有可操作性</li></ol></li></ul><h1 id="项目六"><a href="#项目六" class="headerlink" title="项目六"></a>项目六</h1><ul><li><p>明确政策分类<br>政府的政策方针按性质来分，可以分为国家政策，区域政策，产业政策三种</p></li><li><p>按照旅游发展目标的属性分类</p><p>按照旅游发展目标的属性分类，可分为经济水平目标，社会效益目标，环境保护目标和文化发展目标。<br>旅游发展的经济水平目标是反映其最终产业规模和经济收益状况的系列指标，包括境内外旅游者人数，旅游总收入与创汇，地方居民收入水平，占GDP的比重，投资回收期，乘数效应等。<br>旅游发展的社会效应目标主要涉及特定时期下旅游的发展将会产生怎样的社会效果。包括提供的就业机会，地方居民的支持率，社会风气，旅游者的满意度，从业人员服务质量等指标。<br>旅游发展的环境保护目标直接关系到旅游可持续发展的问题，主要包括自然风景资源保护，历史文化资源保护，环境综合整治指标绿色覆盖率，水资源环境大气，资源环境等内容。<br>旅游发展的文化发展目标需要体现旅游发展对当地文化的影响和与文化互动的预期，结果包括当地文化的完整性，文化个性，文化整合的程度，交叉文化的吸引力等指标。</p></li><li><p>旅游区旅游规划战略目标的制定主要遵循以下四个原则</p><ol><li>旅游业的发展速度适当高于国民经济的增长速度</li><li>国内旅游的增长速度适当高于入境旅游的增长速度</li><li>旅游收入的增长率适当高于旅游接待人次的增长率</li><li>旅游人数和旅游收入的增长考虑不同的旅游业发展态势</li></ol></li><li><p>经济目标的预测主要包括以下内容：旅游人次预测，旅游消费预测，旅游收入预测饭店床位数预测，景区发展质量的预测等</p></li><li><p>明确定位类型<br>旅游规划的战略地位是指导区域旅游产业发展的重要依据，它为旅游产业设定愿景，制定发展战略是旅游规划的灵魂。<br>按照定位内容的划分，旅游区的战略定位主要包括以下内容，主题定位，功能定位，形象定位，产业定位，产品定位。</p><ul><li>主题定位<br>是旅游目的地发展的核心，旅游产业的功能要凸显主题，旅游吸引物的布局要围绕主题展开。主题定位的确立一般有三个来源，即旅游发展目标，发展功能和旅游形象。</li><li>产业定位<br>产业定位是指对旅游产业未来发展方向与目标的定位。产业定位主要考虑三个因素，<br>第一个是旅游产业目前在目的地国民经济发展中的地位<br>第二个是未来旅游产业可能在国民经济中占有什么地位。<br>第三个是参照本省或国家对旅游产业的定位</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 旅游规划与开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统</title>
      <link href="2020/12/13/ji-suan-ji-cao-zuo-xi-tong/"/>
      <url>2020/12/13/ji-suan-ji-cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.icourse163.org/course/ZCIB-1002149003">慕课课程笔记</a></p><h1 id="操作系统的目标与作用"><a href="#操作系统的目标与作用" class="headerlink" title="操作系统的目标与作用"></a>操作系统的目标与作用</h1><h2 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h2><ul><li>操作系统(Operating System，OS)是**<em>管理计算机硬件和软件资源、合理调度作业运行、方便用户使用的程序集合**</em>。</li><li>操作系统既是程序集合，也是唯一跟硬件通信的系统软件。</li><li>管理硬件资源<ul><li>如:配置0S后，可以方便地保存文件，不必了解内存和磁盘的结构</li><li>如:可以方便地打印文件，不必了解打印机的工作原理</li></ul></li><li>管理软件资源<br>可以方便地操作文件、查看目录，而不必了解文件的存储结构、以及存取方式。</li><li>合理调度作业<br>当多道作业同时运行时，OS可以通过合理地分配CPU、内存、外部设备，调度多个作业在同一时间段内，同时运行。</li><li>方便用户<br>可以通过命令、程序、图形等方式，调用0S提供的服务。</li></ul><h2 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h2><ol><li><p>有效性</p><p>管理软硬件资源，合理地组织计算机的工作流程</p></li><li><p>方便性</p><p>提供良好的、一致的用户接口，屏蔽硬件系统的类型和数量差别</p><p>如:不管磁盘型号是什么，用户读写文件的read、write操作是一致的。</p></li><li><p>开放性</p><p>0S遵循统一的标准进行规范的软件开发，彼此兼容，方便互联</p></li><li><p>可扩充性</p><p>因为符合标准，所以在规范的结构下，易于实现多个系统之间的资源共享和互操作，易于功能扩充、和系统升级</p></li></ol><h2 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h2><p>(1) 用户观点。</p><p>操作系统是用户与硬件系统的接口。</p><p>(2) 系统观点。</p><p>操作系统是资源管理者(CPU管理，存储器管理，设备管理，文件管理)</p><p>(3) 功能扩充的观点。</p><p>操作系统用作扩充机。<br>如:多道程序设计技术<br>如:虚拟存储器技术</p><p>如: SPLOOLING技术通常把覆盖了软件的机器，称为扩充器，或虚拟机。OS将诸多功能覆盖到机器上，扩充成了功能强大的计算机</p><h2 id="操作系统发展的主要动力"><a href="#操作系统发展的主要动力" class="headerlink" title="操作系统发展的主要动力"></a>操作系统发展的主要动力</h2><ol><li>不断提高计算机资源利用率的需求</li><li>方便用户</li><li>硬件的不断更新换代。从8位机，到16位-32位-64位， 摩尔定律不断地发挥作用，促使0S不断升级</li><li>计算机体系结构的不断发展。从单处理器，到多处理机、网络0S、云服务平台，促使0S功能越来越强大</li></ol><h1 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h1><h2 id="无操作系统的计算机系统"><a href="#无操作系统的计算机系统" class="headerlink" title="无操作系统的计算机系统"></a>无操作系统的计算机系统</h2><ol><li><p>人工操作方式 </p><p>从第一台计算机诞生(1945年)到50年代中期的计算机，是利用成千上 万个真空管做成的，属于第一代计算机, 体积大，运行速度慢。  用户采用人工方式操作计算机硬件系统。 </p><p>程序员将事先已穿孔的纸带装入卡片输入机，再启动它们，将程序和数据输入计算机； </p><p>当计算机运行到程序结束，用户卸下纸带、取走运行结果后，才允许下一个用户上机。</p><p>具有以下两方面的缺点： (1) 用户独占全机。 (2) CPU等待人工操作。</p><p>随着CPU与I/O设备速度不匹配的矛盾日益突出，在 20世纪50年代末期又引入了**<em>脱机输入输出技术**</em>。 </p></li><li><p><strong><em>脱机输入输出技术</em></strong></p><p>事先将装有用户程序和数据的纸带装入纸带输入机，在一台**<em>处围机**</em>的控制下，将纸带上的程序和数据输入到磁盘上；当计算机需要读取这些程序和数据时，可以从磁盘将其高速地调 入内存。</p><p>与人工操作相比，脱机I/O (1)减少了CPU的空闲时间。 (2) 提高I/O速度。</p></li></ol><h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><ol><li><p>20世纪50年代末到60年代初期，用晶体管制作计算机， 称为第二代计算机，体积减小，功耗降低。 </p><p>为提高计算机的利用率，利用磁盘（或者磁带）把若干个作业分类，编成一批作业序列，每个批作业由一个专门的监督程序自动依次处理，形成单道批处理系统。</p></li><li><p>系统处理流程</p><p>将一批作业以脱机方式输入到磁盘上。首先，监督程序将磁盘上的第一个作业装入内存，并将运行控制权交给该作业，当作业处理完 成后，将控制权还给监督程序； 接下来，监督程序将磁盘上的第二个作业装入内存，这样，控制 一批作业一个接一个的连续处理， 直到磁盘上的作业全部完成。</p></li><li><p>特征： </p><p>自动性 顺序性 单道性</p></li></ol><h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><ol><li><p>多道批处理系统的产生</p><p>用户所提交的作业先存放在外存上，排成一个 “后备队列”；由调度程序按一定的算法，从后备队列中选择<font color='red'>若干个作业</font>调入内存，共享系统各种资源，形成多道批处理系统。</p></li><li><p>多道程序设计技术</p><p>单道批系统中，内存只放一道作业，按照先进先出的原则顺序执行。 在多道批处理系统中，内存中存放若干道程序，可交替执行。如果正在运行的程序，因I/O而暂停执行时，系统可调度另一个程序，使得CPU与设备同时处于忙碌状态，从而提高了系统资源利用率。</p></li><li><p>多道批处理系统的特征</p><p>（1）多道性：内存中同时存放几个作业，并发执行； </p><p>（2）调度性：当前运行的作业需作I/O处理时，CPU转而执行另一个作业。 </p><p>（3）无序性：由于作业调度，各作业可交替使用CPU，造成程序走走停停，没有确定的执行顺序。</p></li><li><p>周转时间： 指作业从提交到完成所用的时间 </p></li><li><p>多道批处理系统的优缺点</p><p>(1) 资源利用率高</p><p>(2) 系统吞吐量大 </p><p>(3) 平均周转时间长 </p><p>(4) 无交互能力</p></li><li><p>多道批处理系统需要解决的问题</p><p>一个系统的优点，一定伴随着代价。 多道批处理系统拥有好的性能，但软件的复杂度较高，需要解决以下问题：</p><p>(1) 处理机并发问题。 (2) 内存分配问题。 (3) I/O设备管理问题。 (4) 文件管理问题。 (5) 作业管理问题。</p></li></ol><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><ol><li><p>分时系统的产生</p><p>多道批处理系统提高了资源利用率和系统吞吐量， 但无交互能力； 分时系统产生的主要动力：用户的需求。</p></li><li><p>分时系统：指在一台主机上连接了多个带有显示器和键盘的终端，同时，允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p></li><li><p>关键问题</p><p>（1）及时接受</p><p>（2）及时处理</p></li><li><p>关键技术</p><p>（1）多路卡</p><p>（2）时间片轮转技术</p></li><li><p>配置多路卡</p><p>当用户在自己的终端上键入命令时，系统利 用多路卡（可连接多个用户），能够及时接收各用户从终端输入的数据。</p></li><li><p>分时系统的特征</p><p>(1)多路性。 (2)独立性。 (3)及时性。 (4)交互性。</p></li><li><p>分时系统的技术指标</p><p>响应时间：从用户向系统发出请求，到系统响应为止的时间</p></li></ol><h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><ol><li><p>实时系统是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该 事件的处理，并控制所有实时任务协调一致地运行。</p></li><li><p>应用需求</p><p>(1) 实时控制，如：卫星发射，称为硬实时任务。 </p><p>(2) 实时信息处理，如：售票系统，称为软实时任务。</p></li><li><p>按任务执行时是否呈现周期性来划分</p><p>(1) 周期性实时任务，指任务在固定的周期内执行。 (2) 非周期性实时任务，指任务在截止时间内执行。 </p></li><li><p>实时系统的技术指标</p><p>为保证系统可靠性，其技术指标为：截止时间。 ① 开始截止时间：任务在某时间以前必须开始执行； ② 完成截止时间：任务在某时间以前必须完成。</p></li><li><p>实时系统与分时系统的比较</p><p>(1) 多路性 (2) 独立性 (3) 及时性 (4) 交互性 (5) <strong><em>可靠性</em></strong></p></li></ol><h2 id="微机操作系统的发展"><a href="#微机操作系统的发展" class="headerlink" title="微机操作系统的发展"></a>微机操作系统的发展</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>多道批处理系统：系统内可同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。 工作原理：用户所提交的作业先存放在外存上，排成一个“后备队列”，有调度程序按一定的算法，从后备队列选择若干个作业调入内存，共享系统各种资源。 技术指标：周转时间（指作业从提交到完成所用的时间）优缺点：（1）资源利用率高；（2）系统吞吐量大；（3）平均周转时间长；（4）无交互能力。 </li><li>分时系统：分时系统与多道批处理系统之间有着截然不同的性能差别，它能很好地将一台计算机提供给多个用户同时使用，提高计算机的利用率。分时系统是指，在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。 特征： （1）多路性：允许在一台主机上同时联接多台联机终端，系统按分时原则为每个用户服务。 （2）独立性：每个用户各占一个终端，彼此独立操作，互不干扰。 （3）及时性：用户的请求能在很短的时间获得响应。 （4）交互性：用户可通过终端与系统进行广泛的人机对话。 </li><li>实时系统：所谓“实时”，是表示“及时”，而实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。其应用需求主要在实时控制和实时信息处理。 优缺点：（1）同时性独立性；（2）及时性；（3）交互性；（4）可靠性。</li></ul><h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><ul><li>并发</li><li>共享</li><li>虚拟性</li><li>异步性</li></ul><ol><li><p>并发：指在单处理机系统中，两个或多个事件在<font color='red'>同一时间间隔内</font>发生。 （宏观上有多个程序在同时运行，微观上每一时刻仅能有一 道程序执行，这些程序只能是交替执行。）</p></li><li><p> 并行：在多处理器环境下，两个或多个事件在在<font color='red'>同一时刻发生</font>。</p></li><li><p>共享：是指系统中的资源可供多个并发执行的进程共同 使用。 由于资源属性的不同，进程对资源共享的方式也不同，目前主要有以下两种资源共享方式：</p><p>互斥共享方式：如打印机、缓冲区； 同时访问方式：如内存、磁盘等。</p></li><li><p>虚拟性</p><ul><li><p>虚拟，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。 </p><p>（1）如虚拟打印机。采用时分复用技术，将物理实体变成若干逻辑对应物 ； </p><p>（2）如虚拟存储器。采用空分复用技术实现将小的内存变成大的虚拟内存。</p></li></ul></li><li><p>异步性</p><p>也称不确定性。因为进程的并发执行，在调度过程中，进程的执行顺序、完成时间都不确定，进程走走停停，按不可预知的速度向前推进，称为异步性。</p></li></ol><h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><h3 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h3><p>完成处理机资源的分配调度等。</p><ul><li> 进程控制：创建、撤销、挂起、改变运行优先级等；</li><li> 进程同步：协调并发进程之间的推进步骤，以协调资源共享；</li><li> 进程通信：进程之间传送数据，以协调进程间的协作； </li><li> 进程调度：作业和进程的运行切换，以充分利用处理机资源和提高系统性能。</li></ul><h3 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h3><p>管理目标：提高内存利用率、提供足够的存储空间、方便进程并发运行。 </p><ul><li>存储分配与回收； </li><li> 存储保护：保证进程间互不干扰、相互保密； </li><li> 地址变换：进程逻辑地址到内存物理地址的映射； </li><li> 虚拟存储器：提高内存利用率、扩大进程的内存空间。</li></ul><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>设备管理的目标是：方便的设备使用、提高CPU与I/O设备利用率； </p><ul><li>设备操作：利用设备驱动程序完成对设备的操作；</li><li>缓冲区管理：匹配CPU和外设的速度，提高两者的利用率； </li><li>设备独立性：提供统一的I/O设备接口，使应用程序独立于物理设备；</li><li>虚拟设备：通过<code>SPLOOLING</code>技术使1个独占设备变成多个共享设备。</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li>解决软件资源的存储、共享、保密和保护。</li><li>文件存储空间管理：解决如何存放信息，以提高空间利用率和读写性能；</li><li>目录管理：解决信息检索问题； </li><li>文件的读写管理和存取控制。</li></ul><h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><p>目标：提供一个友好的、用户访问操作系统的接口。 </p><ul><li> 命令接口：利用命令等，供用户控制自己的作业运行。 </li><li> 程序接口：提供库函数、系统调用，供用户调用操作系统功能。</li></ul><h1 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h1><h2 id="整体或无结构"><a href="#整体或无结构" class="headerlink" title="整体或无结构"></a>整体或无结构</h2><p>在最早期开发操作系统时，规模很小，只有几十K字节，较容易实现。设计者的精力主要放在功能的高效实现上，这种结构思想来源于服务功能观点，忽略了软件工程的设计思想。那 时的操作系统是一组过程的集合，过程之间相互调用，是无结构的，也叫整体结构。</p><p>缺点： 因为缺乏清晰的程序结构，所以错误多，调试难，阅读理解难，增加了维护的难度。</p><h2 id="模块化结构"><a href="#模块化结构" class="headerlink" title="模块化结构"></a>模块化结构</h2><ul><li><p>随着新技术的不断发展，OS的功能越来越强，现代OS的代码量已超过几十万行，需要数百人参与，分工合作，共同 设计。 为克服结构不清晰的缺点，提出模块化结构。</p></li><li><p>操作系统不再由众多的过程直接组成，而是分成若干个具有一定独立性和大小的模块，如：进程管理模块、内存管理模块、设备管理模块、 文件管理模块等。</p></li><li><p>优点： </p><p>（1）模块的开发齐头并进，提高了开发效率，加速了OS的开发过程。 </p><p>（2）提高了OS的可理解性,可维护性。</p></li><li><p>缺点： 当模块数目增加时，每个模块的规模将减小，开发单个模块需要的成本减少了；但是，随着模块数目增加，设计模块间接口所需要的工作量也将增加。 </p><p>（1）系统设计时，模块划分和接口定义不够精确，很难满足实际需求。 </p><p>（2）各模块设计齐头并进，很难做到“每一步都建立在可靠的基础上”， 造成模块间依赖关系复杂。</p></li></ul><h2 id="分层式结构"><a href="#分层式结构" class="headerlink" title="分层式结构"></a>分层式结构</h2><ul><li>所谓有序分层，是指每一步设计都是建立在可靠的基础上。可以从物理机器A1开始，添加一层具有一 定功能的软件A2，在精心设计及测试后，可以 认为A2是正确的；以此类推，如此，一层一层自底向上增添软件层，每一层实现若干功能， 最后，构成一个能够满足要求的操作系统。</li></ul><h2 id="操作系统设计的分层原则"><a href="#操作系统设计的分层原则" class="headerlink" title="操作系统设计的分层原则"></a>操作系统设计的分层原则</h2><p>​    被调用功能在低层。 </p><p>​    与机器特点紧密相关的软件放在最低层。如：如缓冲区队列、堆栈操作、 时钟管理等 </p><p>​    存储器管理放在次低层。如：利用虚拟存储功能。 </p><p>​    资源分配策略放在最外层，如信息管理等，便于修改或适应不同环境。</p><p>优点： 功能明确，调用关系清晰（高层对低层单向依赖）， 有利于保证设计和实现的正确性。 低层和高层可分别实现（便于扩充）；高层错误不会 影响到低层；避免递归调用。</p><p> 缺点：在每执行一个功能，通常要自上而下地穿越多个层次， 降低了运行效率。</p><h2 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h2><ul><li>微内核OS结构是建立在模块化、分层式的基础上， 采用了客户/服务器技术、面向对象技术的现代操作系统结构。 </li><li>在单处理器下，微内核OS结构通常分为两大部分: </li><li>微内核 + 多个服务器</li><li>最基本的核心功能放在内核， 微内核是指精心设计的、能实现现代OS核心功能的小型内核，如线程通信、中断处理等；它运行于核心态，常驻内存。 绝大部分功能放在微内核外面的一组服务器中实现，如进程服务器、存储服务器、设备服务器等。服务器工作在用户态。</li><li>微内核OS结构采用了面向对象技术。利用抽象、 封装、继承、多态等技术，将计算机中的实体作为对 象来处理，将数据和操作封装在稳定的对象中，具有可修改性，可扩充性的特点。</li><li>优点：  可扩充性：只需添加支持新功能的服务进程即可； 可靠性好：调用关系明确，执行转移不易混乱； 可移植性：操作系统的服务器均与硬件无关；  便于网络服务，实现分布式处理。 </li><li>缺点：  消息传递比直接调用效率要低一些。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>模块化结构： 优点：（1）模块的开发齐头并进，提高了开发效率，加速了OS的开发过程。（2）提高了OS的可理解性,可维护性。 缺点：当模块数目增加时，每个模块的规模将减小，需要的成本减少了，但是随着模块数目增加，设计模块间接口所需要的工作量也将增加。 分层式结构： 优点：（1）功能明确，调试关系清晰 （高对低单向依赖），有利于保证设计和实现的正确性。（2）便于扩充，高层错误不会影响低层，避免递归调用。 缺点：降低了运行效率。 微内核结构： 优点：可扩充性，可靠性好，可移植性，便于网络服务，实现分布或处理。 缺点：<font color='red'>消息传递比直接调用效率要低一些</font>。</p><h1 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h1><h3 id="程序的顺序执行及其特征"><a href="#程序的顺序执行及其特征" class="headerlink" title="程序的顺序执行及其特征"></a>程序的顺序执行及其特征</h3><ol><li>在未配置OS的系统中，程序是顺序执行的。 通常把应用程序分成若干程序段，在各程序段之间，按照某种先后顺序执行。</li><li>程序顺序执行时的特征<ul><li>程序执行的顺序性。</li><li>程序环境的封闭性。 </li><li>程序结果的可再现性。</li></ul></li></ol><h3 id="程序的并发执行及其特征"><a href="#程序的并发执行及其特征" class="headerlink" title="程序的并发执行及其特征"></a>程序的并发执行及其特征</h3><ol><li><p>程序的并发执行</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218191446043.png" alt="image-20201218191446043"></p></li><li><p>程序并发执行的例子</p><p>例如，有两个循环程序A和B，它们共享一个变量N。 </p><ul><li>程序A每执行一次时，都要做N∶=N+1操作；</li><li>程序B每执行一次时，都要执行Print(N)操作，然后再将N 置成“0”。 </li><li>程序A和B以不同的速度运行。</li></ul></li><li><p>程序的并发执行结果</p><p>在第1讲中多个买票线程的并发执行实验，出现异步性的执行结果。 如果语句的执行顺序不同，可能出现不同的执行结果。</p><p> (1) N∶=N+1在Print(N)和N∶=0之前，N的值分别为n+1, n+1, 0。</p><p> (2) N∶=N+1在Print(N)和N∶=0之后，N的值分别为n, 0, 1。</p><p> (3) N∶=N+1在Print(N)和N∶=0之间，N的值分别为n, n+1, 0。</p></li><li><p>程序并发执行时的特征</p><p>（1）间断性。多个程序的相互制约，在并发执行时，具有“执行—暂停—执行” 的间断性 。</p><p>（2）失去封闭性。多个程序共享系统资源，其它程序可以改变一个程序环境中资源的状态，失去了封闭性 。</p><p>（3）不可再现性。由于失去封闭性，导致并发执行的程序出现不可再现性。</p></li></ol><h3 id="进程的特征与状态"><a href="#进程的特征与状态" class="headerlink" title="进程的特征与状态"></a>进程的特征与状态</h3><ol><li><p>为什么引入进程</p><p>在多道程序系统中，<font color='red'>程序的并发执行失去封闭性，具有不可再现性的特征</font>，这样，程序的并发执行已失去了意义。 </p><p>并发性是OS的基本特征，是提高系统呑吐量、资源利用率的条件，故引入进程的概念。</p></li><li><p>进程的特征</p><p>（1）结构特征 </p><p>​    进程=程序段+数据段+进程控制块PCB ， PCB相当于列车时刻表，是一个大的记录型数据结构，以保留进程现场和进程控制信息。</p><p>（2）动态性 </p><p>​    进程是程序的一次执行过程，由创建而产生，因调度而执行， 因阻塞而暂停，因撤消而消亡。</p><p>（3）并发性 </p><p>​    由于PCB记录着进程所有的信息，OS可以根据PCB对并发执行的进程进行控制和调度，故多个进程可以在一段时间内同时运行。</p><p>（4）独立性 </p><p>​    <font color='red'>进程是独立的调度单位，资源分配单位</font>。</p><p>（5）异步性</p><p>​    进程按各自独立的，不可预知的速度向前推进。</p></li><li><p>进程的定义</p><p>(1) 进程是程序的一次执行。</p><p>(2) 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p><p>(3) 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p></li><li><p>进程的三种基本状态</p><p>（1）就绪状态 （2）执行状态 （3）阻塞状态</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218192515883.png" alt="image-20201218192515883"></p></li></ol><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><ol><li><p>进程控制块中的作用</p><p>PCB是重要的数据结构，位于系统区，存放OS所需的，用于描述进程标识、控制信息、调度信息等所需的全部信息。</p><p>PCB是进程存在的唯一标志，系统根据<font color='red'>PCB而感知相应进程的存在</font>，OS是根据PCB来对并发执行的进程进行控制和管理的。</p></li><li><p>进程控制块中的信息</p><ol><li><p>进程标识符 ：①内部标识符。 ②外部标识符。</p></li><li><p>处理机状态 ： ① 通用寄存器，② 指令计数器，③ 程序状态字PSW，④ 用户栈指针 </p></li><li><p>进程调度信息包括： ① 进程状态，② 进程优先级，③ 进程调度所需的其它信息，④ 事件。 </p></li><li><p>进程控制信息包括：① 程序和数据的地址， ② 进程同步和通信机制，③ 资源清单，④ 链接指针。</p></li></ol><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218192856989.png" alt="image-20201218192856989"></p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218192912836.png" alt="image-20201218192912836"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>1.程序是静态的，进程是动态的，进程是程序的一次执行。 2.进程是短暂的，当进程完成它的使命后，就会被撤销掉，而程序是一直都存在的。 3.进程是可并发的。 一个进程可以执行一个或多个程序，一个程序也可能由一个或多个进程组成</p></li></ol><h1 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a>进程图</h1><p>进程之间的关系有三种含义：</p><ol><li>子进程可继承父进程所拥有的资源</li><li>子进程撤销时应将其从父进程获得的资源归还给父进程</li><li>父进程撤销时必须同时撤下其所有子进程</li></ol><h1 id="引起进程创建的事件"><a href="#引起进程创建的事件" class="headerlink" title="引起进程创建的事件"></a>引起进程创建的事件</h1><ol><li>用户登录</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ol><h1 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h1><p>（Create原语按照下列步骤创建一个新进程）</p><ol><li>申请空白PCB。</li><li>为新进程分配资源。</li><li>初始化PCB。</li><li>将新进程插入就绪队列。</li></ol><p>调用者（或者父进程）提供一组参数，在新建PCB中，会存放进程的调度信息等。</p><h1 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a>引起进程终止的事件</h1><ol><li><p>正常结束</p></li><li><p>异常结束</p><p>在进程运行期间，由于出现某些错误和故障而迫使进程终止。</p><p>如：越界错误，非法指令等。</p></li><li><p>外界干预</p><p>外界干预使进程应外界请求而终止进程运行。</p><p>如：操作系统干预，父进程请求。</p></li></ol><h1 id="进程终止过程（进程终止原语）"><a href="#进程终止过程（进程终止原语）" class="headerlink" title="进程终止过程（进程终止原语）"></a>进程终止过程（进程终止原语）</h1><ol><li>根据被终止的进程标识符，从PCB集合中检索出该进程的PCB，从中读取该进程的状态。</li><li>若其终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志位真，用于指示该进程被终止后，应重新进行调度。</li><li>若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防成为不可控进程。</li><li>将被终止的进程所拥有的全部资源，或者归还其父进程，或者归还给系统。</li><li>将被终止进程的PCB，从所在队列（或者链表）中移出。</li></ol><h1 id="引起进程阻塞和唤醒的事件"><a href="#引起进程阻塞和唤醒的事件" class="headerlink" title="引起进程阻塞和唤醒的事件"></a>引起进程阻塞和唤醒的事件</h1><ol><li>请求系统服务</li><li>启动某种IO操作</li><li>新数据尚未到达</li><li>无新工作可做</li></ol><h1 id="进程阻塞的过程（block的原语）"><a href="#进程阻塞的过程（block的原语）" class="headerlink" title="进程阻塞的过程（block的原语）"></a>进程阻塞的过程（block的原语）</h1><p>​    进程阻塞是进程自身的一种主动行为</p><ol><li>进入block过程后，将现行状态由‘执行’改为阻塞，并将PCB插入阻塞队列</li><li>调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换。</li><li>保留被阻塞进程的处理机状态，在按照新进程的PCB中的处理机状态设置CPU的环境</li></ol><h1 id="进程唤醒过程（wakeup的原语）"><a href="#进程唤醒过程（wakeup的原语）" class="headerlink" title="进程唤醒过程（wakeup的原语）"></a>进程唤醒过程（wakeup的原语）</h1><p>​    调用唤醒原语wakeup（）的过程是：</p><pre><code> 1. 首先把被阻塞的进程从等待该事件的阻塞队列移出。 2. 将其PCB中的现行状态由阻塞改为就绪。 3. 然后再将该PCB插入到就绪队列中。</code></pre><h1 id="进程挂起原因"><a href="#进程挂起原因" class="headerlink" title="进程挂起原因"></a>进程挂起原因</h1><ol><li>终端用户的请求。</li><li>父进程的请求。</li><li>负荷调节的需要。</li><li>操作系统的需要。</li></ol><h1 id="挂起原语的执行过程"><a href="#挂起原语的执行过程" class="headerlink" title="挂起原语的执行过程"></a>挂起原语的执行过程</h1><p>首先检查被挂起进程的状态，</p><p>​         若处于活动就绪状态，便改为静止就绪态</p><p>​         若处于活动阻塞状态，便改为静止阻塞态</p><h1 id="进程的激活过程（激活原语active）"><a href="#进程的激活过程（激活原语active）" class="headerlink" title="进程的激活过程（激活原语active）"></a>进程的激活过程（激活原语active）</h1><p>​    激活原语先将进程从外存调入内存，检查该进程的现行状态：</p><p>​                 若处于静止就绪态，便改为活动就绪状态</p><p>​                 若处于静止阻塞态，便改为活动阻塞状态</p><ol><li>就绪→执行：处于就绪状态的进程，当进程调度程序为之**<em>分配了处理机**</em>后就转变成执行状态。 </li><li>执行→就绪：处于执行状态的进程因分配给它的时间片用完而不得不让处理机就会转变成就绪状态。 </li><li>执行→阻塞：正在执行的进程因等待某种事件发生而无法继续执行时便从执行状态变成阻塞状态。 </li><li>阻塞→就绪：处于阻塞状态的进程，若**<em>其等待的事件已经发生**</em>，于是进程由阻塞状态转变为就绪状态。 </li><li>活动就绪→静止就绪：活动就绪执行挂起静止就绪 。 </li><li>活动阻塞→静止阻塞： 活动阻塞挂起静止阻塞，静止阻塞激活活动就绪 。 </li><li>静止就绪→活动就绪： 静止就绪激活活动就绪。 </li><li>静止阻塞→活动阻塞：静止阻塞释放静止就绪，静止就绪激活活动就绪，活动就绪执行挂起静止就绪，并且执行请求I/O活动阻塞。</li></ol><h2 id="进-程-同-步"><a href="#进-程-同-步" class="headerlink" title="进 程 同 步"></a>进 程 同 步</h2><h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3><ol><li><p>两种形式的制约关系多道程序环境中,并发进程之间存在资源共享，进程间存在制约关系 </p><p>（1）间接相互制约关系，称为进程互斥。 例如：A、B两个进程同时申请一台打印机</p><p>（2）直接相互制约关系，称为进程同步。 例如：<strong>输入进程与计算进程之间</strong></p></li><li><p>临界资源 临界资源是指在一段时间内，只允许一个进程访问的资源。</p></li><li><p>同步机制应遵循的规则</p><p>空闲则入：其他进程均不处于临界区；</p><p>忙则等待：已有进程处于其临界区；</p><p>有限等待：等待进入临界区的进程不能”死等” ； </p><p>让权等待：不能进入临界区的进程，应释放CPU。</p></li></ol><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ol><li><p>整型信号量 </p><p>最初由Dijkstra把整型信号量定义为一个整型量，除初始化外，仅 能通过两个标准的原子操作wait(S)和signal(S)来访问。这两个操作一 直被分别称为P、V操作。</p><p>利用整形信号量机制，解决进程互斥的传统设计步骤：</p><p>（1）找到临界资源，画出临界区。 </p><p>（2）为每个临界资源设置一个信号量mutex，初值为1。 </p><p>（3）在临界区前加上wait（mutex），作为进入区； </p><p>（4）在临界区后加上signal（mutex），作为退出区； </p><p> Wait和signal成对出现在同一个进程中。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218193708459.png" alt="image-20201218193708459"></p></li><li><p>记录型信号量 </p><p>记录型信号量定义为一个记录型结构，它所包含的上述两个数据项可描述为：</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218193737786.png" alt="image-20201218193737786"></p><p>当S.value＜0时，表示该类资源已分配完毕，此时S.value的绝对值表示在该信号量链表中已阻塞进程的数目。 如果S.value的初值为1，表示只允许一个进程访问临界资源， 此时的信号量转化为互斥信号量。</p></li><li><p>AND型信号量 </p><p>AND同步机制的基本思想是： </p><p>(1)将进程在整个运行过程中需要的所有资源， 一次性全部地分配给进程，待进程使用完后再一起释放。 </p><p>(2)要么全部分配到进程，要么一个也不分配。</p><p>swait原语的实现</p><p>只有进程所需的资源， 全都满足时，执行 Si∶=Si-1操作； 只要发现有第Si个资源不满足，将进程阻塞在第Si的队列中。</p><p>ssignal原语的实现</p><p>针对所有的资源，执行 Si∶=Si+1操作； 将Si队列中的阻塞进程移出，进入就绪队列。</p></li><li><p>信号量集</p><ul><li><p>基本思想：</p><p>（1）前面讲的信号量操作，每次施以加1、减1操作，当进程一次需 要N个某类资源时，便要执行N次wait（S）操作，显然是低效的。 </p><p>（2）有些情况下，当资源低于某个下限值时，便不予以分配。 基于以上两点，信号量集机制对AND信号量加以扩充，在每次分配前，都必须测试资源的数量，看其是否大于其下限值，并可按要求 一次性分配多个资源。</p></li><li><p>信号量机制的描述</p><p>一般化的信号量集机制描述： S为信号量，d为需求值，t为下限值。 </p><p>（1）如果Si &gt;= ti，可分配；反之，表示资源数量低于ti时，便不予分配。 </p><p>（2）每次分配值为di，用于信号量的增减， 即Si = Si - di和Si = Si + di</p></li><li><p>swait原语的实现</p><p>只有进程所需的资源，全都满足Si≥ti时， 执行Si∶=Si-di操作； 只要发现有第Si个资源不满足，将进程阻塞在第Si的队列中。</p></li><li><p>ssignal原语的实现</p><p>针对所有的资源，执行 Si∶=Si+di操作； 将Si队列中的阻塞进程移 出，进入就绪队列。</p></li><li><p>一般信号量集的几种特殊情况</p><p>(1) Swait(S, d, d)。 此时在信号量集中只有 一个信号量S， 但允许它每次申请d个资源，当现 有资源数少于d时，不予分配。</p><p>(2) Swait(S, 1, 1)。 此时的信号量集已蜕 化为一般的记录型信号量(S＞1时)或互斥信号量 (S=1时)。</p><p>(3) Swait(S, 1, 0)。这是一种很特殊且很用的 信号量操作。当S≥1时，允许多个进程进入某特定 区；当S变为0后，将阻止任何进程进入特定区。 换言之，它相当于一个可控开关。</p></li></ul></li></ol><h1 id="进程的前趋关系及同步机制"><a href="#进程的前趋关系及同步机制" class="headerlink" title="进程的前趋关系及同步机制"></a>进程的前趋关系及同步机制</h1><h2 id="进程之间的前趋关系"><a href="#进程之间的前趋关系" class="headerlink" title="进程之间的前趋关系"></a>进程之间的前趋关系</h2><p>在多道程序环境下，进程之间存在两种制约关系： （1）间接相互制约关系，称为进程互斥。 （2）直接相互制约关系，称为进程同步。例如：输入进程与计算进程之间， 计算进程与输出进程之间，存在着前趋关系。 进程之间的直接相互制约关系，通常用前趋图表示。</p><h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><h1 id="多线程OS中的进程有以下属性"><a href="#多线程OS中的进程有以下属性" class="headerlink" title="多线程OS中的进程有以下属性"></a>多线程OS中的进程有以下属性</h1><ol><li><p>作为系统资源分配的单位。</p></li><li><p>可包括多个线程。</p></li><li><p>进程不是一个可执行的实体。</p><p>在多线程OS中，进程是作为**<em>拥有操作系统资源**</em>的基本单位，通常的进程都包括多个线程并为他们提供资源，此时的进程就<font color='red'>不再作为一个执行的实体</font>。</p><p>所谓进程处于执行状态，实际上是该进程中的线程正在执行。</p></li></ol><h1 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h1><p>系统在内核空间还为每一个内核支持线程设置了一个线程控制块，内核是根据**<em>该控制块而感知某线程的存在的**</em>，对其加以控制。    </p><ol><li><p>内核维护线程的切换；</p></li><li><p>一个线程发起系统调用而阻塞，不会影响其他线程的运行，CPU会调度其他线程运行。内核线程只拥有很少的资源，相对于进程，<font color='red'>其切换开销小。但相对于用户级线程，系统开销大。</font></p></li></ol><h1 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h1><p>用户级线程仅存在于用户空间中。对于这种线程的创建，撤销，线程之间的同步与通信等功能，都无需利用系统调用来实现。</p><ol><li>内核不了解用户线程的存在；</li><li>用户线程的维护由应用进程完成；</li><li>用户线程切换不需要内核特权。</li></ol><p>如： 进程A包括1个用户级线程，进程B包括100个用户级线程，由于内核不了解用户级线程的存在，为进程A和进程B分配相同的资源，A中线程的运行速度将是B的100倍。</p><ol><li>线程是*<strong>调度和分派**<em>的基本单位，进程是</em></strong>拥有资源***的基本单位。 </li><li>不同进程可并发，一个进程中的线程之间也可以并发执行。 </li><li>线程仅拥有少量资源，还可以访问其隶属进程的资源。 </li><li>在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。 </li><li>进程创建、撤消、切换的开销远远大于线程切换的开销。 </li><li>单线程进程，只能运行在一个处理机上。多线程进程，就可以将一个进程中的多个线程分配到多个处理机上。</li><li>联系： <ol><li>线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源； </li><li>线程是进程中执行运算的最小单位； </li><li>进程和线程都是由操作系统所体会的程序运行的基本单元。</li></ol></li></ol><p>简单来说，*<strong>处理机指的是硬件**<em>，它包含在内，而</em></strong>内核是操作系统中的概念*<strong>，是操作系统的核心，是属于**<em>软件部分。</em></strong></p><ol><li>处理机包括中央处理器，主存储器，输入-输出接口，加接外围设备就构成完整的计算机系统。处理机是处理计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。程序是描述处理机完成某项任务的指令序列。指令则是处理机能直接解释、执行的信息单位。</li><li>中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。</li><li>内核是操作系统最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并且内核决定一个程序在什么时候对某部分硬件操作多长时间。内核，是一个操作系统的核心。是基于硬件的第一层软件扩充，提供操作系统的最基本的功能，是操作系统工作的基础，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。</li></ol><h1 id="处理机调度的基本概念"><a href="#处理机调度的基本概念" class="headerlink" title="处理机调度的基本概念"></a>处理机调度的基本概念</h1><h2 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h2><h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><ul><li>调度对象：作业</li><li>主要功能：决定将外存上的那些作业调入内存。<ul><li>在每次执行作业调度时，都必须做以下决定：<ul><li>接纳多少条作业</li><li>接纳那些作业</li></ul></li></ul></li><li><strong><em>只用于批处理系统</em></strong>。</li><li>作业调度运行频率低，几分钟一次。</li></ul><h3 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h3><ul><li>调度对象：进程。</li><li>主要功能：决定就绪队列中的那个进程获得处理机。</li><li>是最基本的调度。</li><li>进程调度运行频率高，几十毫秒一次，算法不能太复杂。</li></ul><h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><ul><li>内外存信息对换<ul><li>内存–&gt;外存（挂起状态）</li><li>外存–&gt;内存（内存有空间，进程又具备运行条件）</li></ul></li><li>目的：便于内存管理扩充；提高内存利用率和系统吞吐量。</li><li>中级调度的运行频率介于高级、低级调度之间。</li></ul><h2 id="调度队列模型"><a href="#调度队列模型" class="headerlink" title="调度队列模型"></a>调度队列模型</h2><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B.png" alt="调度队列模型" title="调度队列模型"></p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B2.png" alt="调度队列模型" title="调度队列模型"></p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%973.png" alt="调度队列模型" title="调度队列模型"></p><h2 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h2><ol><li><p>处理机调度算法的共同目标</p><ol><li><p>资源利用率。</p><p>CPU资源利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)</p></li><li><p>公平性。</p></li><li><p>平衡性。</p></li><li><p>策略强制执行。</p></li></ol></li><li><p>批处理系统的目标</p><ol><li>平均周转时间短。<ul><li> 周转时间是指从作业被提交系统（外存）开始，到作业完成为止的这段时间间隔。</li></ul></li><li>系统吞吐量高。<ol><li>吞吐量是指在单位时间内系统完成的作业数。</li></ol></li><li>处理机利用率高。</li></ol></li><li><p>周转时间包括四个部分：</p><ol><li><p>等待作业调度时间</p></li><li><p>等待进程调度时间</p></li><li><p>进程在CPU上执行的时间</p></li><li><p>进程等待IO操作完成的时间（有阻塞）</p><p>平均周转时间：从作业被提交系统（外存）开始，到作业完成为止的这段时间间隔除以作业个数。</p><p>带权周转时间：周转时间除以服务时间。</p><p>平均带权周转时间：带权周转时间除以作业个数。</p></li></ol></li><li><p>分时系统的目标</p><ol><li>响应时间快。<ul><li><font color='red'>响应时间</font>是从用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间。</li></ul></li><li>均衡性。<ul><li><font color='red'>均衡性</font>是指系统响应时间的快慢应与用户所请求服务的复杂性相适应。</li></ul></li></ol></li><li><p>实时系统的目标。</p><ol><li>截止时间的保证。<ul><li>截止时间是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。</li></ul></li><li>可预测性。</li></ol></li></ol><h1 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h1><h2 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h2><p>适用于作业调度</p><ul><li>从后备作业队列中选中**<em>一个或者多个最先进入**</em>的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。</li></ul><p>适用于进程调度</p><ul><li>从就绪进程队列中选中**<em>一个最先进入**</em>的进程，为之分配处理机，使之投入运行；直到运行完成或者阻塞，才会让出处理机。</li></ul><h2 id="短作业-进程优先算法"><a href="#短作业-进程优先算法" class="headerlink" title="短作业/进程优先算法"></a>短作业/进程优先算法</h2><p>短作业优先（SJF）</p><ul><li>从后备队列中选择一个或者多个**<em>估计**</em>运行时间最短的作业调入内存。（运行时间的估计不一定准确）</li></ul><p>短进程优先（SPF）</p><ul><li>从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行。</li></ul><h2 id="优先级调度算法（数字越小优先权越大）"><a href="#优先级调度算法（数字越小优先权越大）" class="headerlink" title="优先级调度算法（数字越小优先权越大）"></a>优先级调度算法（数字越小优先权越大）</h2><p>适用于作业调度</p><ul><li>从后备队列中选择若干个优先权最高的作业装入内存。</li></ul><p>适用于进程调度</p><ul><li>根据进程的紧迫程度赋予每个进程一个优先权，选择就绪队列中一个优先权最高的进程投入执行。</li></ul><ol><li>优先级调度算法的类型<ol><li>非抢占式优先权调度算法<ul><li>把CPU分配给优先权最高的进程后，运行直至完成或发生某事件而阻塞时，才将CPU分配给其他进程。</li></ul></li><li>抢占式优先权调度算法<ul><li>在执行期间出现了优先权更高的进程，系统将暂停当前进程，并将CPU分配给新出现的优先权最高的进程。</li><li>抢占的原则有：<ul><li>优先权原则</li><li>短作业（进程优先原则）</li><li>时间片原则</li></ul></li></ul></li></ol></li><li>优先权的类型<ol><li>静态优先权<ul><li>是在创建进程时确定的，且在进程的整个运行期间保持不变。</li></ul></li><li>动态优先权<ul><li>优先权可以随进程的推进或等待时间的增加而改变。</li></ul></li></ol></li></ol><h2 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h2><p>思想:优先级随着等待时间的增加而提高。<br>优先级的变化规律为:<br>响应比=（等待时间+服务时间）/服务时间<br>优点:照顾短作业(进程) ;考虑到达次序;兼顾长作业(进程)</p><h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><p>基本原理.</p><ul><li>所有就绪进程按<code>FCFS</code>原则进行调度，每次执行一个时间片。当时间片用完而进程未完，则插入就绪队列末尾。</li></ul><p>特点:简单易行、平均响应时间短，不利于处理紧急任务。</p><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><ol><li>调度机制</li></ol><ul><li>设置多个就绪队列，赋予不同的优先级和不同长度的时间片(优先级越高时间片越短)。</li><li>每个队列都采用<code>FCFS</code>算法。</li><li>按队列优先级调度。</li></ul><ol start="2"><li>性能<br>该算法能较好地满足各种类型用户(进程)的需要。</li></ol><ul><li>终端(交互)型作业用户。</li><li>短批处理作业用户。</li><li>长批处理作业用户。</li></ul><h1 id="实时调度算法"><a href="#实时调度算法" class="headerlink" title="实时调度算法"></a>实时调度算法</h1><h2 id="实现实时调度算法的基本条件"><a href="#实现实时调度算法的基本条件" class="headerlink" title="实现实时调度算法的基本条件"></a>实现实时调度算法的基本条件</h2><ul><li>提供详细的调度信息</li><li>系统处理能力强</li><li>具有快速切换机制</li><li> 采用抢占式调度机制</li></ul><h2 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h2><ul><li>非抢占式轮转调度算法</li><li>非抢占式优先调度算法</li><li> 基于时钟中断抢占式优先级调度算法</li><li>立即抢占的优先级调度算法</li></ul><h2 id="最早截止时间优先算法"><a href="#最早截止时间优先算法" class="headerlink" title="最早截止时间优先算法"></a>最早截止时间优先算法</h2><ul><li>思想:根据任务的开始截止时间来确定任务的优先级，即任务的开始截止时间越早，其优先级越高。</li><li>可采用非抢占调度方式，也可采用抢占调度方式。</li></ul><h2 id="最低松弛度优先算法"><a href="#最低松弛度优先算法" class="headerlink" title="最低松弛度优先算法"></a>最低松弛度优先算法</h2><ul><li>思想:根据实时任务的<font color='red'>松弛度来确定任务的优先级</font>。松弛度越低，其优先权越高。<ul><li>松弛度=任务必须完成的时间-任务本身的运行时间-当前时间</li></ul></li><li>实现时按松弛度排序的实时任务就绪队列(<strong><em>松弛度为0时立即抢占资源</em></strong>)。</li><li>当一任务的最低松弛度为0时，立即抢占CPU。</li></ul><ol><li>多道批处理系统的调度算法：短作业优先、优先权、高响应比优先、多级反馈队列调度算法。</li><li>分时系统的调度算法：时间片轮转法。</li><li>实时系统调度算法：最早截至时间优先即EDF、最低松弛度优先即LLF算法。</li></ol><h1 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><p>死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，若无外力作用，它们都将无法再向前推进。</p><h2 id="产生死锁的原因和必要条件"><a href="#产生死锁的原因和必要条件" class="headerlink" title="产生死锁的原因和必要条件"></a>产生死锁的原因和必要条件</h2><p>1.产生死锁的原因<br>    (1)竞争资源</p><ul><li>消耗性资源(如:消息)</li><li>不可抢占性资源(如:打印机)</li></ul><p>​    (2)进程推进顺序不当</p><p>2.产生死锁的必要条件</p><ul><li>互斥条件</li><li>请求与保护条件</li><li>不剥夺条件</li><li>环路等待条件</li></ul><h2 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h2><ul><li>预防死锁</li><li>避免死锁</li><li>检测死锁</li><li>解除死锁</li></ul><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><ul><li>通过设置某些限制条件，破坏导致死锁的四个必要条件之一。</li><li>“互斥条件”一由资源的性质决定，不可破坏且要保证。</li></ul><ol><li><p>破坏“请求和保持”条件<br>目标:防止“保持时请求、请求时保持”<br>(1)第一种协议</p><ul><li>方法:在进程开始运行前，一次性分配给它所需的“全部”资源。</li><li>优点:简单易实现，安全性高。</li><li>缺点:资源浪费;经常发生饥饿现象。</li></ul><p>(2)第二种协议</p><ul><li>方法:允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。</li><li>优点:资源利用率高，减少了饥饿现象。</li></ul></li><li><p>破坏“不可抢占”条件</p><ul><li>目标:变不可剥夺为可剥夺</li><li>方法:在进程运行中，若新的资源请求得不到满足，必须释放已占有的所有资源，待以后重新申请。</li><li>缺点:实现起来比较复杂，代价高。</li></ul></li><li><p>破坏“循环等待”条件</p><ul><li>目标:避免出现请求环</li><li>方法:资源按类型排序，进程按照资源序号递增的次序提出资源申请。(有序资源分配法)</li><li>优点:资源利用率高和系统吞吐量大。</li><li>缺点:必须按顺序申请，限制新设备的增加和程序员的自主编程。</li></ul></li></ol><h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><h2 id="安全状态与不安全状态"><a href="#安全状态与不安全状态" class="headerlink" title="安全状态与不安全状态"></a>安全状态与不安全状态</h2><ul><li>安全状态:系统能按某种进程推进顺序，如&lt;P, P….. P.&gt;为每个进程分配所需资源，直到最大需求，使每个进程都可顺利完成。这样的序列&lt;P, P….. P。&gt;称为安全序列。</li><li>不安全状态:不存在安全序列。</li></ul><h2 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h2><ol><li><p>Work[0…m]=Available[0.. .m];<br>Finish[0…n]=false;</p></li><li><p>从进程集合中寻找满足下列条件的进程Pi:<br>①Finish[i]=false;<br>②Need[i,j]≤Work[i,j];<br>若找到，转(3)；否则，转(4)</p></li><li><p>进程Pi可获取资源，然后执行完毕，并释放资源:<br>Work[j]=Work[i]+Allocation[i,j];<br>Finish[i] =true.<br>转(2)</p></li><li><p>判断:若对所有Pi， Finish[i]=true</p><p>则系统处于安全状态，否则处于不安全状态</p></li></ol><h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><ul><li>避免死锁的方法:允许进程动态地提出资源请求，在系统进行资源分配之前，先判断此次资源分配的安全性。</li><li>①若资源分配后，系统处于安全状态，则表明此次资源分配可行，实施资源分配;</li><li>②若资源分配后，系统处于不安全状态，则表明此次资源分配不可行，进程需等待。</li></ul><p>2.银行家算法</p><ul><li>当进程P;做出资源请求时，如Request;[j]= k表示进程P;所需要的资源类型R，的请求数量为k。系统按下述步骤进行检查:</li><li>(1) 如果Request i[j]≤Need[i,j] 转到(2);否则，认为出错，因为它所请求的资源数量已超过它所宣布的最大值。</li><li>(2)如果Request i[j]≤Available[j]，则转到(3); 否则，表示尚无足够资源，进程须等待。</li><li>(3) 系统试探着把资源分配给进程Pi，并按下面公式修改数据结构中的值:<ul><li>Available[j] = Available[j] - Request i[j] ;</li><li>Allocation[i,j] = Allocation[i,j] + Request i[j];</li><li>Need[i,j] = Need[i,j]- Request i[j];</li></ul></li><li>(4) 系统执行安全性算法。检查此次分配后系统是否处于安全状态。<ul><li>若安全，正式将资源分配给进程P;</li><li>若不安全，将本次试探分配作废，恢复到原先资源分配状态，让进程Pi等待。</li></ul></li></ul><h2 id="银行家算法和安全性算法的关系"><a href="#银行家算法和安全性算法的关系" class="headerlink" title="银行家算法和安全性算法的关系"></a>银行家算法和安全性算法的关系</h2><p>银行家算法的基本思想是允许进程动态地申请资源，在资源分配之前，通过相应的算法确定本次资源分配后系统是否安全（不会产生死锁），若是，则进行分配，否则，让进程处于等待状态。银行家算法在避免死锁的方法中，所施加的限制条件较弱，有可能获得令人满意的系统性能。在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可以避免发生死锁。</p><h1 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h1><ol><li><p>主存储器（简称内存）</p><p>作用：保证进程运行时的程序和数据。</p></li><li><p>寄存器和高速缓存</p><p>作用：缓和内存访问速度和CPU指令执行速度不匹配的矛盾。</p></li><li><p>磁盘缓存</p><p>作用：缓和磁盘IO速度和内存的访问速度不匹配的矛盾。</p></li></ol><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><ul><li>几个重要概念:<br>(1)物理地址(绝对地址):计算机内存单元的真实地址。<br>(2)内存空间:物理内存是各程序共享的物质基础，由0~(m-1)个物理地址组成<br>(3)逻辑地址(相对地址):用户的程序地址。<br>(4)逻辑空间:程序地址均从“0”开始。</li></ul><h2 id="程序的装入方式"><a href="#程序的装入方式" class="headerlink" title="程序的装入方式"></a>程序的装入方式</h2><h3 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h3><p>装入模块被装入内存后，程序中的逻辑地址与实际物理地址完全相同。</p><ul><li><p>缺点:</p><p>只适用于单道系统;要求程序员熟悉内存的使用情况等。</p></li><li><p>问题:<br>多道程序环境下，逻辑空间中的逻辑地址和内存空间中的物理地址不一致，如何解决?</p></li><li><p>解决方案:<br>借助于地址映射功能进行转换。对地址部分的调整过程，称为重定位。</p></li></ul><h3 id="可重定位装入方式和动态运行时装入方式"><a href="#可重定位装入方式和动态运行时装入方式" class="headerlink" title="可重定位装入方式和动态运行时装入方式"></a>可重定位装入方式和动态运行时装入方式</h3><ul><li><p>重定位的类型</p><table><thead><tr><th align="center">类型</th><th align="left">映射时间</th><th align="left">特点</th></tr></thead><tbody><tr><td align="center">静态重定位</td><td align="left">装入内存时，地址映射一次完成</td><td align="left">(1)运行过程中不可移动位置<br/>(2)内存利用率低</td></tr><tr><td align="center">动态重定位</td><td align="left">执行期间，地址映射由“硬件地址变位置换机构”动态完成</td><td align="left">(1)运行过程中可移动<br/>(2)需附加硬件支持</td></tr></tbody></table></li></ul><h2 id="程序的连接"><a href="#程序的连接" class="headerlink" title="程序的连接"></a>程序的连接</h2><h3 id="静态连接方式"><a href="#静态连接方式" class="headerlink" title="静态连接方式"></a>静态连接方式</h3><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5.png" alt="静态连接" title="静态连接"></p><h3 id="装入时动态连接"><a href="#装入时动态连接" class="headerlink" title="装入时动态连接"></a>装入时动态连接</h3><ul><li>将几个目标模块装入内存时边装入边链接。</li><li>优点:<br>(1)便于修改和更新。<br>(2) 便于实现对目标模块的共享。</li></ul><h3 id="运行时动态连接"><a href="#运行时动态连接" class="headerlink" title="运行时动态连接"></a>运行时动态连接</h3><ul><li>将某些目标模块的链接，推迟到执行时才进行。</li><li>优点:<br>(1) 加快程序的装入过程。<br>(2)节省内存空间。</li></ul><h2 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><ul><li>基本思想:<ul><li>内存划分为:系统区和用户区</li><li>只能用于单用户、单任务的操作系统中</li></ul></li><li>特点:<ul><li>方法简单，易于实现</li><li>单道程序:内存和CPU利用率低，难于实现共享</li></ul></li></ul><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><ul><li><p>基本思想:</p><ul><li><p>把内存用户空间划分为若干个固定大小的分区;</p></li><li><p>每个分区中只装入一道作业。</p></li></ul></li><li><p>划分分区的方法:</p><ul><li>分区大小相等</li><li>分区大小不等</li></ul></li><li><p>具体实现:</p><ul><li>将分区按大小排队</li><li>建立分区使用表<br>表项包括:  ①分区号        ②分区起始地址<pre><code>               ③分区大小    ④分区状态</code></pre></li><li>当程序装入时，由内存分配程序检索分区使用表</li><li>若找到符合要求的分区，则完成内存分配，并进行标记;</li><li>若未找到，则拒绝内存分配。</li></ul></li><li><p>缺点：内碎片问题；限制了并发执行的程序数目。</p></li></ul><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ul><li><p>基本思想:</p><p>作业装入时，根据实际需要和内存空间的使用情况进行动态分配。</p></li><li><p>特点:</p><p>分区个数、分区大小不固定。</p></li><li><p>分区分配中的数据结构:</p><ul><li>空闲分区表、已分配分区表、空闲分区链</li></ul></li></ul><h4 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法:"></a>分区分配算法:</h4><h5 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h5><p>算法思想:空闲分区表或空闲分区链按照分区起址递增的次序排序。顺序查找，若找到第一个大小满足要求的空闲分区，则从中划出一块内存空间分配给作业;若未能找到，则此次内存分配失败。</p><h5 id="循环首次适应算法"><a href="#循环首次适应算法" class="headerlink" title="循环首次适应算法"></a>循环首次适应算法</h5><p>算法思想:从上次分配的空闲区位置之后开始查找。若找到一个满足要求的空闲分区，则从中划出一块内存空间分配给作业。若最后一-个<br>空闲分区大小仍不能满足要求，则返回到第一个空闲分区继续查找。</p><h5 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h5><p>算法思想:从满足要求的、最小的空闲分区中划出一块空间分配给作业。要求空闲分区表或空闲分区链按照分区容量递增的次序排序，顺<br>序查找第一个满足要求的空闲分区。</p><h5 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h5><p>算法思想:从满足要求的、最大的空闲分区中划出一块空间分配给作业。要求空闲分区表或空闲分区链按照分区容量递减的次序排序。<br>优点:查找速度快，分配后剩下的可用空间较大。<br>缺点:一段时间后会缺乏较大空闲区。</p><h5 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h5><p>算法思想:将空闲分区按照进程常用的空间大小进行分类。分配时,根据进程长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配。<br>优点:查找效率高<br>缺点:分区归还主存时算法复杂</p><h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><ul><li><p>分配内存</p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5.png"></p></li><li><p>回收内存</p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%8C%BA%E5%9B%9E%E6%94%B6%E6%83%85%E5%86%B5.png"></p></li></ul><h3 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h3><p>由于经过紧凑后的用户程序在内存中的位置发生了变化，所以必须对发生移动的程序和数据进行重定位。</p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><h3 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h3><ul><li>目的:解决内存不足的问题</li><li>对换:是指把内存中暂时不能运行的进程或暂时不用的程序和数据调出到外存,以腾出空间把已具备运行条件的进程或程序数据调入内存。</li></ul><ol><li><p>对换(Swapping) 的引入:</p><ul><li>两种形式:<br>(1)整体对换:以进程为单位的对换，用于分时系统。<br>(2)部分对换:以“页”或“段”为单位的对换，支持虚拟存储系统。</li></ul></li><li><p>对换空间的管理:</p><ul><li>外存划分:<br>(1) 文件区:存放文件，采用<strong>离散</strong>分配方式，管理目标是*<strong>提高文件存储空间的利用率*<strong>。<br>(2) 对换区:存放从内存换出的进程，采用</strong>连续*<em>分配方式，目标是</em></strong>提高进程换入和换出的速度***。</li></ul></li><li><p>进程的换出与换入:</p><ul><li>进程的换出:<br>选择处于阻塞状态且优先级最低的进程;启动磁盘，将该进程的程序和数据传送到磁盘的对换区;回收进程内存空间，修改PCB。</li><li>进程的换入:<br>系统定时查看所有进程的状态;找出“就绪”状态但已换出的进程;将其中换出时间最久的进程换入内存。</li></ul></li></ol><h2 id="离散分配方式概述"><a href="#离散分配方式概述" class="headerlink" title="离散分配方式概述"></a>离散分配方式概述</h2><ul><li>基本思想:一个用户程序(进程)直接分散地装入到很多不相邻接的分区中。</li><li>两种形式:<br>分页存储管理方式(离散基本单位:页)<br>分段存储管理方式(离散基本单位:段)</li></ul><h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><h3 id="页面与页表"><a href="#页面与页表" class="headerlink" title="页面与页表"></a>页面与页表</h3><p>1.页面:</p><ul><li><strong><em>等分</em></strong>内存空间:每等份称为物理块，编号: 0 1 2 3 4 ……</li><li><strong><em>等分</em></strong>逻辑空间:划分为与物理块大小相同的页，面，编号为0 1 2 3 4 …..</li><li>页面大小: 2n Bytes，大小适中、通常为512B~8KB地址变换机构</li></ul><p>2.页表:</p><ul><li>系统为**<em>每个进程**</em>建立一张页表。</li><li>作用:实现从页号到物理块号的地址映射。</li><li>在页表中，每页均对应一页表项，记录页号、块号的对应关系，及存取控制字段。</li></ul><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><ul><li>基本任务:<br>实现从逻辑地址到物理地址的映射。</li><li>两种形式:<br>1.基本的地址变换机构<br>2.具有快表的地址变换机构</li></ul><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%9C%BA%E6%9E%84.png"></p><ul><li><p>问题:<br>由于页表存放在内存中，CPU每取得一个数据，均需要两次访问内存。<br>第一次:访问页表，形成物理地址;<br>第二次:从物理地址中获得数据</p></li><li><p>具有快表的地址变换机构:<br>增设一个具有并行查询能力的高速缓冲寄存器<br>快表(联想寄存器)<br>空间大小:几K到几百K， 只含有部分页表项(16^ 512个)</p></li></ul><h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><ul><li>问题:<br>每个进程仅页表项就占1MB的连续内存空间</li><li>解决思路:<br>将大页表进行分页，每个页面离散的存放在不同物理块中。</li><li>为内存中离散分配的页表在建立一张外层页表，每个页表项记录页表分页的物理块号。</li></ul><h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><ul><li>为满足用户和程序员的下述需求：<ul><li>方便编程</li><li>信息共享</li><li>信息保护</li><li>动态增长</li><li>动态链接</li></ul></li></ul><h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3><ol><li><p>分段：</p><ul><li>逻辑地址空间分段，各段长度不等。</li><li>每个段均有段名和段号，且从0开始编址。</li></ul></li><li><p>分配原则：为每个段分配一个连续的分区，各分区不必相邻接。</p></li><li><p>段表：</p><ul><li>系统为**<em>每个进程建立一张段表**</em>。</li><li>作用：实现从逻辑段到物理内存区的映射。</li><li>在段表中，每段对应一个段表项，记录段号，段长、段基址等。</li></ul></li><li><p>分页和分段的对比:</p><ul><li><p>相似之处:<br>都采用离散分配方式</p><p>地址变换都要通过地址映射机构来实现</p></li><li><p>主要区别:</p><p>存储单位划分原则不同</p><p>存储单位特征不同</p><p>逻辑地址性质不同</p></li></ul></li></ol><h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><p>段式存储共享信息比页式存储实现起来高效，因为段式的数据大小不一致不需要那么多个段表项。</p><h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><ol><li>基本原理:<br>将用户程序分成若干个段，每段一个段名;<br>再将每个段分成若干个页。</li><li>优点:<br>分散存储，内存利用率较高;<br>易于实现信息共享，支持动态链接。</li><li>缺点:<br>为获取一条指令或数据必须三次访问内存(段表、页表、取指令)，导致访问效率下降。</li></ol><h2 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h2><h3 id="虚拟存储器的引入"><a href="#虚拟存储器的引入" class="headerlink" title="虚拟存储器的引入"></a>虚拟存储器的引入</h3><ol><li>常规存储器管理方式的特征:<ul><li>一次性、驻留性</li><li>情况一:内存空间装不下的大作业无法运行</li><li>情况二:作业量大时，无法允许更多的作业并发</li><li>扩充内存容量的方法:物理上、逻辑上</li></ul></li><li>局部性原理:<ul><li>程序在执行时常呈现局部性规律，并表现在两个方面:<br>(1)时间局限性<br>(2)空间局限性</li></ul></li><li>虚拟存储器的概念:<ul><li>逻辑上扩充内存容量的方案:<br>(1)允许作业部分装入，其他页(段)在运行中需要访问时再调入—增加请求调入功能<br>(2) 若内存已满，将某些暂时不用的页(段)调出内存—增加置换功能</li><li>定义:虚拟存储器是指具有请求调入功能和置换功能,能从逻辑_上对内存容量加以扩充的一种存储器系统。<br>实质:物理上不存在，利用海量外存进行内存“空间”的扩展。<br>逻辑容量:取决于内存容量和外存容量之和。<font color='red'>虚存容量 = min (2^计算机位数[CPU位数]， 内存＋外存);</font></li></ul></li></ol><h3 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h3><p>必须基于“离散分配的内存管理技术’</p><ol><li>请求分页系统(页式虚拟存储系统)<ul><li>=基本分页系统+请求调页功能+页面置换功能</li><li>硬件支持:请求分页的页表机制、缺页中断机构、地址变换机构。</li><li>软件支持:请求分页、页面置换</li></ul></li><li>请求分段系统(段式虚拟存储系统)<ul><li>=基本分段系统+请求调段功能+分段置换功能</li><li>硬件支持:请求分段的段表机制、缺段中断机构、地址变换机构。</li><li>软件支持:请求分段、段的置换</li></ul></li></ol><h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><ol><li>离散性:在内存分配时采用离散分配方式;</li><li>多次性:一个作业被分成多次调入内存运行;</li><li>对换性:允许在作业的运行过程中进行换进、换出;</li><li>虚拟性:能从逻辑上扩充内存容量，使用户看到”的内存容量远大于实际大小。</li></ol><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3><ol><li><p>页表机制:</p><ul><li><p>基本作用:地址转换</p></li><li><p>增加页表字段,供程序在换入换出时参考</p><table><thead><tr><th>页号</th><th>物理块号</th><th>状态位P</th><th>访问字段A</th><th>修改位M</th><th>外存地址</th></tr></thead><tbody><tr><td>页面号</td><td>指示该页在内存上的地址</td><td>用于指示该页是否已调入内存</td><td>记录本页在一段时间内被访问的次数</td><td>该页在调入内存后是否被修改过</td><td>指示该页在外存上的地址(物理块号)</td></tr></tbody></table></li></ul></li></ol><h3 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h3><ol><li>最小物理块数的确定:<ul><li>保证进程正常运行所需的最小物理块数;</li><li>与硬件结构有关，取决于指令的格式、功能和寻址方式。</li></ul></li><li>物理块的分配策略:<ul><li>两种内存分配策略:<br>固定分配:为进程分配的物理块数固定不变。<br>可变分配:先为每个进程分配一定数目的物理块，若发生缺页中断，再增加物理块数。</li><li>两种置换策略:<br>局部置换:只能将自己的某个内存页换出。<br>全局置换:可将系统中任一进程的内存页换出。</li><li>组合出以下三种适用策略:<br>(1) 固定分配局部置换<br>(2) 可变分配全局置换<br>(3) 可变分配局部置换</li></ul></li><li>物理块分配算法:<ul><li>(1)平均分配算法</li><li>(2)按比例分配算法:根据进程大小按比例分配(si/s)*m(m:物理块总数，S:各进程页面总数)</li><li>(3)考虑优先权的分配算法:一部分按比例分配;另一部分为优先权高的进程增加分配份额</li></ul></li></ol><h3 id="调页策略"><a href="#调页策略" class="headerlink" title="调页策略"></a>调页策略</h3><ol><li><p>调入页面的时机:<br>预调页策略:进程首次调入内存时，由程序员指出应该先调入哪些页。<br>请求调页策略:进程运行中发生缺页时，提出请求，由OS将其所需页面调入内存。</p></li><li><p>确定从何处调入页面:</p><ul><li>请求分页系统将外存分为两部分:<br>文件区(离散分配)、对换区(连续分配)</li><li>发生缺页请求时，有以下三种情况:<br>系统拥有足够的对换区空间<br>系统缺少足够的对换区空间<br>UNIX方式</li></ul></li><li><p>页面调入过程:<br>①若发生缺页，便向CPU发出缺页中断<br>②中断处理程序保存CPU环境，转中断处理程序<br>③该程序查找页表,得到该页在外存中的块号<br>④若内存未满，启动磁盘I/O调入页面;若内存已满，先置换再调入<br>⑤修改页表项内容，并写入快表。</p></li></ol><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h3><ol><li>基本思想:<br>淘汰以后永不使用的或未来最长时间内不再被访问的页面。</li><li>特点:<br>理论上:缺页率低、性能最佳;<br>实际上:无法预知，实现困难;通常用于评价其他算法的优劣。</li></ol><h3 id="先进先出-FIFO-算法"><a href="#先进先出-FIFO-算法" class="headerlink" title="先进先出(FIFO)算法"></a>先进先出(FIFO)算法</h3><ol><li><p>基本思想:<br>淘汰最先进入内存的页面，即驻留内存时间最长的页面。</p></li><li><p>特点:<br>实现简单</p><p>与进程实际运行的规律不相适应:有些页面经常被访问，如:含有全局变量、常用函数的页面。</p></li></ol><h3 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h3><h3 id="最近最久未使用置换-LRU-算法"><a href="#最近最久未使用置换-LRU-算法" class="headerlink" title="最近最久未使用置换(LRU)算法"></a>最近最久未使用置换(LRU)算法</h3><ol><li>基本思想:<br>淘汰在最近一段时间最久未被使用(访问)的页面。</li><li>特点:<br>性能较好<br>实现较为复杂:设置访问字段;需要硬件支持(<strong><em>配置寄存器或栈</em></strong>)</li><li>LRU置换算法的硬件支持:<br>(1)寄存器<br>为每个在内存中的页面配置一个移位寄存器，表示为:R=Rn-1Rn-2…R1R0。<br>当进程访问某物理块时，将R-1位置1。定时信号每隔一定时间将寄存器右移一位，并将最高位补0。具有最小数值的寄存器所对应的页面就是最近最久未使用的页面。<br>(2)栈<br>利用栈保存当前使用的各个页面的页面号。栈顶是最新被访问页面的页面号，栈底是最近最久未使用页面的页面号。</li></ol><h3 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h3><ul><li>算法思想:<br>为每页设置一位访问位;将内存中所有页面链接成一个循环队列，并增设替换指针;<br>由页面管理软件周期性地将所有访问位置0。当某页被访问时，将其访问位置“1“。</li></ul><h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><h3 id="请求分段中的硬件支持"><a href="#请求分段中的硬件支持" class="headerlink" title="请求分段中的硬件支持"></a>请求分段中的硬件支持</h3><ol><li><p>段表机制:<br>基本作用:地址转换</p><p>增加段表字段，供程序在换入换出时参考</p><table><thead><tr><th>段名(号)</th><th>段长</th><th>段的基址</th><th>访问字段A</th><th>修改位M</th><th>存在位P</th><th>存取方式</th><th>增补位</th><th>外存始址</th></tr></thead><tbody><tr><td>段名</td><td>段长度</td><td>段的物理地址</td><td>记录该段被访问的频繁程度</td><td>该段在进入内存后是否被修改过</td><td>指示本段是否已调入内存</td><td>标识存取属性只执行、只读或允许读/写</td><td>表示本段在运行过程中是否做过动态增长</td><td>本段在外存中的起始地址，即起始盘块号</td></tr></tbody></table></li></ol><h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><ol><li><p>共享段的分配与回收:<br>(1) 共享段的分配<br>对第一个请求使用该共享段的进程:由系统为该共享段分配一物理区，并将共享段调入;将该区始址填入请求进程的段表的相应项中;在共享段表中增加一表项，填写有关数据，并置count值为1。</p><p> 对其他调用该共享段的进程:在调用进程的段表中增加一表项，填入该共享段的物理地址;在共享段表的对应表项中填入调用进程的相关信息，并执行count=count+1。</p><p>(2)共享段的回收<br>当进程不再需要共享段时:撤消共享段的表项;执行count=count-1。仅当count=0时，由系统回收共享段的物理内存。</p></li><li><p>分段保护:<br>(1) 越界检查<br>比较:段号与段表长度、段内地址与段长;若越界，则发出越界中断信号。<br>(2)存取控制检查<br>存取控制字段只读、只执行、读/写</p><p>(3)环保护机构：低编号的环具有高优先权</p></li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>虚拟存储器，是在逻辑上扩充内存容量，使得应用程序认为它有一个连续完整的地址空间，被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。 特点主要有：<ol><li>离散性：在内存分配时采用离散分配方式。</li><li>多次性：一个作业被分成多次调入内存运行。</li><li>兑换性：允许在作业运行过程中进行换进、换出。</li><li>虚拟性：能从逻辑上扩充内存容量，使用户“看到”的内存容量远大于实际大小。</li></ol></li></ul><h1 id="设备管理-1"><a href="#设备管理-1" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="I-O控制系统"><a href="#I-O控制系统" class="headerlink" title="I/O控制系统"></a>I/O控制系统</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><ul><li><p>I/0设备分类的重要指标:<br>(1)设备使用特性<br>(2)数据传输速率<br>(3)数据传输单位<br>(4)设备共享属性</p></li><li><p>设备与控制器间的接口<br>由于设备与CPU的速度不匹配，设备并不直接与CPU通信，而是与设备控制器通信，因此，I/0设备中应含有与设备控制器间的接口，在接口中，有三种类型的信号，各对应一个信号线：数据信号线，控制信号线，状态信号线。</p><ul><li><p>数据信号线:用于在设备和设备控制器之间传送数据信号。</p><p>对于输入设备，由外界输入的信号经转换器转换后所形成的数据，先送入缓冲器中，当数据量达到一定的字符数后，再从缓冲器通过一组数据信号线传送给设备控制器。<br>对于输出设备，将从设备控制器，经过数据信号线传送来的一批数据，先暂存于缓冲器中，经转换器适当转换后，再逐个字符地<br>输出。</p></li><li><p>控制信号线:作为由设备控制器向I/0设备发送控制信号时的通路。<br>规定了设备将要执行的操作，如:读操作:指由设备向控制器传送数据;写操作:从控制器接收数据。</p></li><li><p>状态信号线：用于传送指示设备当前状态信号。如：正在读、读完成等等。</p></li></ul></li></ul><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><ul><li>设备控制器是**<em>CPU与I/0设备之间的接口**</em>，接收从CPU发来的命令，去控制I/0设备工作，使CPU从繁杂的设备控制事务中解脱出来。<br>设备控制器是一个可编址的设备，可连接多个设备，使每个设备地址对应一个设备。<br>设备控制器通常做成电路卡形式，称为接口卡。如打印卡、显卡等。</li><li>设备控制器与处理机的接口<br>共有3类信号线:数据线、地址线、控制线。<br>数据线通常与两类寄存器相连，<br>(1)数据寄存器:用于存放从设备送来的数据(输入)、或者从CPU送来的数据(输出)。<br>(2)控制/状态寄存器用于存放从CPU送来的控制信息，或者设备状态信息。</li><li>设备控制器的基本功能.<br>1)接收和识别命令<br>2)数据交换<br>3)标识和报告设备的状态<br>4)地址识别<ol start="5"><li>数据缓冲</li><li>差错控制</li></ol></li></ul><h3 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I/O通道"></a>I/O通道</h3><ol><li><p>I/0通道的引入<br>I/0通道是一种特殊的处理机。它具有执行I/O指令的能力，并通过执行通道(I/O)程序来控制I/0操作。</p></li><li><p>I/0通道又与一般的处理机不同:<br> (1)其指令类型单一，这是由于通道硬件比较简单，所能执行的命令，主要局限于与I/0操作有关的指令;<br> (2)通道没有自己的内存，通道所执行的通道程序是放在主机的内存中的，通道与CPU共享内存。</p></li><li><p>I/0通道类型</p><ul><li><p>字节多路通道</p><p>字节多路通道是一种按字节交叉方式工作的通道。它包含许多非分配型子通道，每个通道连接并控制一台I/0设备，这些子通道按照时间片轮转方式，共享主通道。</p></li><li><p>数组选择通道</p><p>数组选择通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序，控制一台设备进行数据传送，致使当某台设备占用了该通道后，便一直由它独占，即使它无数据传送，通道被闲置，也不允许其它设备使用该通道，直至该设备传送完毕释放该通道。</p></li><li><p>数组多路通道</p><p>数组多路通道是将数组选择通道传输速率高和字节多路通道能使各子通道(设备)分时并行操作的优点相结合而形成的一种新通道。被广泛地用于连接多台高、中速的外围设备。</p></li></ul></li></ol><h3 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h3><p>计算机系统中的各部件，如CPU、 主存、I/0设备之间的联系，都是通过总线实现的。总线性能是用总线的时钟频率、带宽、传输速率等指标来衡量的。</p><p>局部总线，是指将多媒体卡、高速LAN网卡、高性能图形板等，从ISA总线 上卸下来，再通过局部总线控制器，直接连接到CPU总线上，使之与高速CPU总线相匹配，而打印机、传真机、CDROM等仍挂在ISA总线_上。</p><h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><h3 id="程序I-O方式"><a href="#程序I-O方式" class="headerlink" title="程序I/O方式"></a>程序I/O方式</h3><p>在处理机向控制器发出一条I/O指令启动输入设备输入数据时,读出状态寄存器的设备状态,将busy标志位置为1 ;然后,需要不停测试busy标志位，如果busy标志位=1，表示输入未完成,处理机继续测试，直到busy标志位=0 ,表明输入数据已进入控制器的数据寄存器中;处理机将数据寄存器中的数据取出，送入指定内存单元中。</p><p>在程序I/0方式中，从终端输入一个字符的时间约为100 ms，而将字符送入终端缓冲区的时间小于0. 1 ms。若采用程序I/0方式，CPU约有99. 9ms的时间处于忙一等待中。<br>由于CPU的高速性和I/0设备的低速性，致使CPU的绝大部分时间都处于等待I/0设备完成数据I/O的循环测试中，造成对CPU的极大浪费。</p><h3 id="中断驱动I-O控制方式"><a href="#中断驱动I-O控制方式" class="headerlink" title="中断驱动I/O控制方式"></a>中断驱动I/O控制方式</h3><p>在输入数据时，当设备控制器收到CPU发来的读命令后，便去控制输入设备读数据。当输入数据已进入控制器的数据寄存器时，控制器便通过控制线向CPU发送一个中断信号，CPU检查输入过程中是否出错，若无错，便向控制器发送取走数据的信号，再通过控制器与数据线将数据写入指定内存单元中。</p><p>例如，从终端输入一个字符的时间约为100 ms，而将字符送入终端缓冲区的时间小于0. 1 ms。若采用中断驱动方式后，CPU可利用这99.9ms的时间去做其它事情，而仅用0.1ms的时间来处理由控制器发来的中断请求。<br>在I/0设备输入每个数据的过程中，由于无须CPU干预，因而可使CPU与I/0设备并行工作，提高了整个系统的资源利用率及吞吐量。</p><h3 id="直接存储器访问DMA控制方式"><a href="#直接存储器访问DMA控制方式" class="headerlink" title="直接存储器访问DMA控制方式"></a>直接存储器访问DMA控制方式</h3><p>①数据传输的基本单位是数据块，即在CPU与I/0设备之间，每次传送至少一个数据块;</p><p>②所传送的数据是从设备直接送入内存的，或者相反;<br>③仅在传送一个或多个数据块的开始和结束时,才需CPU干预，整块数据的传送是在控制器的控制下完成的。</p><p>为了实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中设置如下四类寄存器:<br>(1) 命令/状态寄存器CR。用于接收从CPU发来的I/0命令或有关控制信息，或设备的状态。<br>(2) 内存地址寄存器MAR。在输入时，它存放把数据从设备传送到内存的起始目标地址;在输出时，它存放由内存到设备的内存源地址。<br>(3) 数据寄存器DR。 用于暂存从设备到内存，或从内存到设备的数据。<br>(4) 数据计数器DC。存放本次CPU要读或写的字(节)数。</p><ul><li>DMA工作过程<br>当CPU从磁盘读入一数据块时，向磁盘控制器发送一条读命令。该命令被送到其中的命令寄存器(CR)中;同时，发送本次要将数据读入的内存起始目标地址，该地址被送入内存地址寄存器中(MAR) ;本次要读的字节数送入数据计数器中(DC);将磁盘的源地址直接送DMA控制器的I0控制逻辑上。然后，启动DMA控制器进行数据传送，CPU可处理其它任务。</li><li>整个数据传送过程由DMA控制器进行控制。当从磁盘读入一个字节的数据，并送入数据寄存器后，再挪用一个存储周期，将字节送到内存地址寄存器中(MAR) 所指示的内存单元中;接着，对内存地址寄存器MAR内容加1;将数据计数器DC内容减1。若减1后，数据计数器内容不为0，表示传送未完，便继续传送下一个字节;否则，由DMA控制器发出中断请求。由CPU完成一个完整数据块的数据读入。</li></ul><h3 id="I-O通道控制方式"><a href="#I-O通道控制方式" class="headerlink" title="I/O通道控制方式"></a>I/O通道控制方式</h3><p>I/0通道方式是DMA方式的发展，它可进一步减少CPU的干预，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预。</p><p>例如，当CPU要完成一组相关的读(或写)操作及有关控制时，只需向I/0通道发送一条I/0指令，以给出其所要执行的通道程序的首址和要访问的I/0设备，通道接到该指令后，通过执行通道程序便可完成CPU指定的I/0任务。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ol><li>程序I/O控制方式:适用于结构简单，只需少量硬件的电路。 </li><li>中断驱动I/O控制方式：适用于高效场合。 </li><li>直接存储访问DMA I/O控制方式：适用于无须CPU介入的控制器来控制内存与外设之间的数据交流的场合。 </li><li>I/O通道控制方式：适用于以字节为单位的干预，同时实现CPU，通道和I/O设备三者并行操作的场合。</li></ol><h2 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h2><h3 id="缓存的引入"><a href="#缓存的引入" class="headerlink" title="缓存的引入"></a>缓存的引入</h3><p>(1)缓和CPU与I/0设备间速度不匹配的矛盾。<br>(2)减少对CPU的中断频率，放宽对CPU中断响应时间的限制。<br>(3)提高CPU和I/0设备之间的并行性。</p><h3 id="单缓存和双缓存"><a href="#单缓存和双缓存" class="headerlink" title="单缓存和双缓存"></a>单缓存和双缓存</h3><p>在单缓冲情况下，每当用户进程发出一个I/0请求时，OS便在主存中为之分配一个缓冲区。<br>例如:在块设备输入时，假定从磁盘把块数据输入到缓冲区的时间为T;将该缓冲区的数据传送到用户区的时间为M;CPU对这块数据的处理时间为C;由于T与C是可以并行的，可以把系统对每一块数据的处理时间表示为<code>max(C, T)+M</code>.</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218084540968.png" alt="image-20201218084540968"></p><p>引入双缓冲后，在设备输入时，先将数据送入第一个缓冲区，装满后便转向第2个缓冲区;这时，OS可从第一个缓冲区中移出数据，送入用户进程;由CPU对数据进行计算。<br>例如:采用行输入方式时，双缓冲能消除用户的等待时间，即用户在输入完成第1行之后，在CPU执行第1行的命令时，用户可继续输入第2行的数据。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218084719309.png" alt="image-20201218084719309"></p><h3 id="循环缓存"><a href="#循环缓存" class="headerlink" title="循环缓存"></a>循环缓存</h3><p>(1)缓冲区。缓冲区大小相同，分为三种类型:</p><p>用于装入输入数据的空缓冲区R、</p><p>已装满数据的缓冲区G、</p><p>现行工作区C .<br>(2)指针。用于指示计算进程下一个可用缓冲区G的指针<code>nextg</code>、指示输入进程下次可用的空缓冲区<code>nexti</code>、指示计算进程正在使用的缓冲区C的指针<code>current</code></p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218084858088.png" alt="image-20201218084858088"></p><ul><li>循环缓冲区的使用<br>(1) Getbuf过程 。<br>计算进程要使用缓冲区数据时，将由指针nextg所指示的缓冲区，提供给进程;将其改为现行工作区，令current 指针指向该缓冲区的第一个单元，同时，将nextg移向下一个G缓冲区。<br>(2) Releasebuf过程。<br>当计算进程把C缓冲区中的数据提取完毕时，调用Releasebuf过程，释放C;将该缓冲区C改为空缓冲区R。类似的，输入进程使用空缓冲区装入数据时，应调用Getbuf过程。当输入进程把缓冲区填满时，应调用Releasebuf过程。</li><li>进程同步<br>(1) Nexti指针追 赶上Nextg指针。<br>说明输入进程的速度大于计算进程的速度，全部空缓冲区装满数据。此时，输入进程阻塞，称为系统受计算所限。<br>(2) Nextg指针追赶上Next i指针。<br>说明计算进程的速度大于输入进程的速度，全部数据缓冲区取空。此时，计算进程阻塞，称为系统受IO所限。</li></ul><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><ol><li><p>缓冲池的组成<br>公用缓冲池，含有以下三种类型的缓冲区:<br>(1)空(闲)缓冲区;<br>(2)装满输入数据的缓冲区;<br>(3)装满输出数据的缓冲区。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218085322372.png" alt="image-20201218085322372"></p><p>除了上述3个队列外，还具有4种工作缓冲区:<br>(1)用于收容输入数据的工作缓冲区hin;<br>(2) 用于提取输入数据的工作缓冲区sin;<br>(3)用于收容输出数据的工作缓冲区hout;<br>(4)用于提取输出数据的工作缓冲区sout。</p></li><li><p>缓冲区工作方式</p><p>(1)收容输入。当输入进程需要输入数据时，调用Getbuf (emq) 过程，从空缓冲队列emq的队首，摘下一个空缓冲区，作为收容输入工作缓冲区hin。把数据输入其中，装满后再调用putbuf (inq,hin) 过程，将该缓冲区挂在输入队列inq上。</p><p>(2)提取输入。当计算进程需要数据时，调用Getbuf (inq)过程，从输入数据队列inq的队首，取得一个缓冲区，作为提取输入工作缓冲区sin,计算进程从中取数据。计算进程用完数据后，再调用putbuf (emq, sin)过程，将该缓冲区挂在空队列emq上。</p><p>(3)收容输出。当计算进程需要输出数据时，调用Getbuf(emp)过程，从空缓冲队列emp的队首，摘下一个空缓冲区，作为收容输出工作缓冲区hout。把输出数据装满后，再调用putbuf (outq, hout) 过程，将该缓冲区挂在输出队列outq末尾。</p><p>(4)提取输出。输出进程Getbuf (outq) 过程，从输出队列outq的队首，取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区sout。在数据提取完成后，再调用putbuf (emq， sout) 过程，将该缓冲区挂在空队列emq末尾。</p></li></ol><h2 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I/O软件"></a>I/O软件</h2><h3 id="I-O软件的设计目标和原则"><a href="#I-O软件的设计目标和原则" class="headerlink" title="I/O软件的设计目标和原则"></a>I/O软件的设计目标和原则</h3><p>(1)与具体设备无关<br>(2)统一命名<br>(3)错误处理<br>(4)缓冲技术<br>(5)设备的分配和释放<br>(6)I/O控制方式</p><ul><li><p>I/O软件的分层设计结构</p><ol><li><p>用户层软件。是用户交互的接口，可以直接调用与/O操作相关的库函数。</p></li><li><p>设备独立性软件。实现与设备驱动器的统一接口、 设备保护、设备分配。</p><p>设备独立性的基本含义是:应用程序独立于具体使用的物理设备。<br>为了实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中，使用逻辑设备名称来请求使用某类设备;而系统在实际执行时，还必须使用物理设备名称。因此，系统须具有将**<em>逻辑设备名称转换为某物理设备名称**</em>的功能。</p><ol><li><p>执行所有设备的公有操作</p><pre><code>①对独立设备的分配与回收;   ②将逻辑设备名映射为物理设备名;   ③对设备进行保护，禁止用户直接访问设备   ④缓冲管理;   ⑤差错控制;   ⑥提供独立于设备的逻辑块。</code></pre></li><li><p>向用户层软件提供统一接口</p><p>无论何种设备，它们向用户所提供的接口应该是相同的。例如，对各种设备的读操作，在应用程序中都使用read;而对各种设备的写操作，也都使用write。</p></li></ol></li><li><p>设备驱动程序。与硬件直接相关，负责实现系统对设备发出的操作指令，驱动I/O设备工作。</p><ol><li><p>驱动程序主要是指在请求I/0的进程与设备控制器之间的一个通信和转换程序。</p></li><li><p>驱动程序与设备控制器和I/0设备的硬件特性紧密相关，因而对不同类型的设备应配置不同的驱动程序。</p></li><li><p>驱动程序与I/0设备所采用的I/0控制方式紧密相关。</p></li><li><p>由于驱动程序与硬件紧密相关。</p></li><li><p>设备驱动程序的处理过程</p><ol><li><p>将抽象要求转换为具体要求。如:将抽象要求中的盘块号转换为磁盘的盘面、磁道、扇区，在0S中，只有设备驱动程序同时了解抽象要求、和设备控制器中的寄存器情况，知道命令、数据、参数分别送到哪个寄存器。</p></li><li><p>检查I/0请求的合法性。</p></li><li><p>读出和检查设备的状态。</p></li><li><p>传送必要的参数。如:在启动磁盘读写前，应将本次要传送的字节数、数据的主存始址，送到控制器的相应寄存器中。</p></li><li><p>工作方式的设置。</p></li><li><p>启动I/0设备。驱动程序发出I/0命令后，由设备控制器控制基本的I0操作。此时，驱动进程阻塞，直到中断到来时将它唤醒。</p></li></ol></li></ol></li><li><p>中断处理程序。保存被中断进程的CPU环境，转入相应的中断处理程序，恢复被中断进程的现场后返回到被中断进程。</p><ol><li>唤醒被阻塞的驱动进程.</li><li>保存被中断进程的CPU环境。将处理机状态字、程序计数器，保存在中断保留区中。</li><li>分析中断原因，转入相应的中断处理程序。</li><li>中断处理。对于不同设备，有不同的中断处理程序，如打印、数据输入等，根据设备控制器的状态，结束中断。</li><li>恢复被中断进程的现场后返回到被中断进程。</li></ol></li><li><p>硬件。执行IO操作。</p></li></ol></li><li><p>当一个进程从文件中读一个数据块时，需要通过系统调用取得0S服务来完成;设备独立性软件接收到I/0请求后，首先在高速缓存中查找相应的页面，如果没有，则调用设备驱动程序向硬件发出一个请求，由驱动程序负责从磁盘读取目标数据块。当磁盘操作完成后，由硬件产生一个中断，并转入中断处理程序，检查中断原因，提取设备状态，转入相应的设备驱动程序，唤醒用户进程，结束此次I/0请求，继续用户进程的运行。</p></li><li><p>为实现设备的独立性，系统必须设置一张逻辑设备表，用于将应用程序中所使用的逻辑设备名映射为物理设备名。当进程使用逻辑设备名请求分配I/O设备时，系统在逻辑设备表中建立一个表目，填入应用程序中使用的逻辑设备名、系统分配的物理设备名、以及设备驱动程序的入口地址。</p></li><li><p>逻辑设备表的设置方式<br>第一种是在整个系统中只设置一张逻辑设备表，这要求所有用户不能使用相同的逻辑设备名。</p><p>第二种方式是为每个用户设置一张逻辑设备表。将逻辑设备表放入用户进程的PCB中，这样，不同用户可以使用相同的逻辑设备访问物理设备。</p></li><li><p>设备独立性的优点<br>(1)设备分配时的灵活性。当进程使用物理设备名请求设备时，如果设备忙碌，进程会阻塞。当进程使用逻辑设备名请求某类设备时，系统可将任一台空闲的设备分配给进程，仅当所有设备全忙碌时，进程才会阻塞。<br>(2)易于实现I/0重定向。I/0重定向，指用于I/0操作的设备可以更换，而不必改变应用程序。例如:当调试程序时，可将程序的所有输出送往屏幕显示;如果将输出结果打印时，不必修改应用程序，只须将I/0重定向的逻辑设备表中的显示端，改为打印机。</p></li></ul><h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><h3 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h3><ol><li><p>设备控制表DCT</p><p>系统为每个设备设置一-张设备控制表，用于记录该设备的情况。在设备控制表中，包含:<br>(1)设备类型<br>(2)设备标识符<br>(3)设备队列的队首指针(队列中存放请求设备未被满足的PCB)<br>(4)设备状态<br>(5)与设备相连的控制器表指针<br>(6)重复执行次数。系统规定在设备工作中发生错误时可重复执行次数。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218092248978.png" alt="image-20201218092248978"></p></li><li><p>控制器控制表</p><p>系统为每个设备控制器设置一张设备控制器表，用于记录该设备控制器的情况。包含:</p><p>(1)设备控制器标识符<br>(2)设备控制器状态<br>(3)与设备控制器相连的通道表指针<br>(4)控制器队列的队首指针<br>(5)控制器队列的队尾指针</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218092354998.png" alt="image-20201218092354998"></p></li><li><p>通道控制表</p><p>系统为每个通道配有一-张通道表，用于记录该通道的情况。包含:<br>(1)通道标识符<br>(2)通道状态<br>(3)与通道连接的设备控制器表首址<br>(4)通道队列的队首指针<br>(5)通道队列的队尾指针</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218092453900.png" alt="image-20201218092453900"></p></li><li><p>系统设备表</p><p>系统设备表是个系统范围的数据结构，记录了系统中全部设备的情况。每个设备占一个表目，其中包括:<br>(1)设备类型<br>(2)设备标识符<br>(3)设备控制表<br>(4)设备驱动程序的入口</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218092831185.png" alt="image-20201218092831185"></p></li></ol><h3 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h3><ol><li>设备的固有属性<br>(1) 独享设备。采取独占分配策略<br>(2) 共享设备。可以通过某种调度方式，分配给多个进程使用。<br>(3) 虚拟设备。指通过采用虚拟技术，使一台物理设备可变成多台逻辑上的共享设备。可以分配给多个进程使用。</li><li>设备分配算法<br>(1) 先来先服务<br>当多个进程对同一设备提出I/0请求时，该算法根据进程提出请求的先后次序，排成一个设备请求队列，总是将设备分配给队首进程。<br>(2) 优先级高者优先<br>在这种算法中，总是优先权高的进程优先获得资源。对于优先权相同的进程，按照先来先服务的原则排队。</li><li>设备分配中的安全性<br>(1) 安全分配方式<br>当进程请求资源时，便进入阻塞状态，直到I/0操作完成才被唤醒。但进程的并发度低，资源的利用率低。<br>(2)不安全分配方式<br>当进程请求资源时，仍继续运行，需要时又发出第2个I/0请求，第3个I/0请求等，按照安全性算法进行计算，仅当状态安全时，才分配。这种方式稍复杂，但进程的并发度高。</li></ol><h3 id="独占设备的分配程序"><a href="#独占设备的分配程序" class="headerlink" title="独占设备的分配程序"></a>独占设备的分配程序</h3><ol><li><p>基本的设备分配程序<br>当进程提出I/0请求后，按下列3个步骤进行分配。<br>(1) 分配设备</p><p>首先，根据I/0请求中的物理设备名，查找SDT， 找出该设备的设备控制表DCT，根据DCT中的设备状态字段，可知设备是否正忙。若忙，将该进程的PCB挂在设备的等待队列中;若不忙，按照一-定的算法计算设备分配的安全性，来分配设备。</p><p>(2) 分配控制器</p><p>在系统将设备分配给请求进程后，从DCT中找到与该设备相连的控制器的COCT，根据COCT中的状态字段，可知该设备控制器是否正忙。若忙，将该进程的PCB挂在设备控制器的等待队列中;若不忙，将设备控制器分配给进程。</p><p>(3) 分配通道</p><p>在系统将设备控制器分配给请求进程后，从控制器控制表COCT中找到与该控制器相连的通道的通道控制表CHCT，根据CHCT中的状态字段，可知该通道是否正忙。若忙，将该进程的PCB挂在通道的等待队列中;若不忙，将通道分配给进程。</p></li><li><p>设备分配程序的改进<br>(1) 增加设备的独立性<br>进程利用逻辑设备名请求I/0。系统首先从系统设备表SDT中找出第一个该类设备的设备控制表DCT，若设备忙，再查找第2个该类设备的DCT;仅当所有该类设备都忙时，才将该进程的PCB挂在该类设备的等待队列中。<br>(2)考虑多通路情况<br>可以按照多通路情况进行改进。例如，若设备连接的第一个控制器忙碌时，应查看第2个控制器，仅当所有该类设备控制器都忙时，才将该进程的PCB挂在该类设备控制器的等待队列中。<br>同理，通道分配也是一样的。</p></li></ol><h3 id="SPOOLing技术"><a href="#SPOOLing技术" class="headerlink" title="SPOOLing技术"></a>SPOOLing技术</h3><ol><li><p>什么是SPOOLing<br>当系统中引入了多道程序技术后，可以利用其中的一道程序，来模拟脱机输入时的外围控制机功能，把低速I/0设备，上的数据传送到高速磁盘上;再用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。<br>这样，便可在主机的直接控制下，实现脱机输入、输出功能。此时的外围操作与CPU对数据的处理同时进行，把这种在联机情况下实现的同时外围操作称为SPOOLing，或称为假脱机操作。</p></li><li><p>SPOOLing系统的组成</p><p>(1) 输入井、输出井这是在磁盘上开辟的两大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存I/0设备输入的数据;输出井是模拟脱机输出时的磁盘设备，用于暂存用户程序的输出数据。</p><p>(2) 输入缓冲区、输出缓冲区为缓和CPU与磁盘之间速度不匹配的矛盾，在内存中开辟输入缓冲区、输出缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井;输出缓冲区用于暂存由输出井送来的数据，以后再传送到输出设备。</p><p>(3) 输入进程、输出进程两个进程用于模拟脱机IO时的外围控制机。输入进程用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备、通过输入缓冲区、再送到输入井，当CPU需要数据时，直接从输入井读入内存;输出进程用于模拟脱机输出时的外围控制机，将用户要求输出的数据，先从内存送到输出井，待输出设备空闲时，再将输出井中的数据，通过输出缓冲区、送到输出设备上。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218093846748.png" alt="image-20201218093846748"></p></li><li><p>共享打印机<br>当用户进程请求打印输出时，SPO0Ling 系统同意为它打印输出，但并不立即把打印机分配给该用户进程，只为它做两件事:<br>①由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中;<br>②输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该 表挂到请求打印队列上。</p><p>如果还有进程请求打印，系统仍为之做上述两件事情。<br>当打印机空闲时，输出进程从请求打印队列的队首，取出一张请求打印表，根据表中的要求，将要打印的数据，从输出井传送到内存缓冲区，进行打印;直到所有请求响应完成，输出进程阻塞;仅当再有打印请求时，才被唤醒。</p></li><li><p>SPOOLing系统的特点<br> (1)提高了I/O的速度。<br>(2)将独占设备改造为共享设备。</p><p>(3)实现了虚拟设备功能。</p></li></ol><h2 id="磁盘存储器管理"><a href="#磁盘存储器管理" class="headerlink" title="磁盘存储器管理"></a>磁盘存储器管理</h2><h3 id="磁盘性能简述"><a href="#磁盘性能简述" class="headerlink" title="磁盘性能简述"></a>磁盘性能简述</h3><ol><li><p>数据的组织和格式<br>磁盘设备可包括一到多个物理盘片，每个磁盘片分一个或者两个存储面;<br>每个磁盘面被组织成若干个同心环，称为磁道，各磁道之间留有必要的间隙。<br>每条磁道存储相同数目的二进制位，磁盘密度指每英寸中所存储的位数，内层磁道的密度比外层高。<br>每个磁道逻辑上划分成若干个扇区，一个扇区称为一个盘块，各扇区之间保留一定的间隙。</p></li><li><p>磁盘在使用前，一定要低级格式化。磁盘格式化后，要对磁盘分区。</p></li><li><p>在真正使用磁盘前，还要进行一次高级格式化，即设置一个引导块、空闲存储管理、根目录、和一个空文件系统。<br>常用的分区格式有: FAT32、NTFS等</p></li><li><p>磁盘的类型<br>(1)固定头磁盘<br>这种磁盘在每条磁道上都有一读/写磁头，所有的磁头都被装在一刚性磁臂中。通过这些磁头可访问所有各磁道，进行并行读/写，有效地提高了磁盘的I/0速度。这种结构的磁盘主要用于大容量磁盘上。<br>(2)移动头磁盘<br>每一个盘面仅配有一个磁头，也被装入磁臂中。为能访问该盘面上的所有磁道，该磁头必须移动以进行寻道。可见，移动磁头仅能以串行方式读/写，致使其I/0速度较慢;但由于其结构简单，故仍广泛应用于中小型磁盘设备中。</p></li><li><p>磁盘访问时间<br>(1)寻道时间Ts<br>指把磁臂(磁头)移动到指定磁道上所经历的时间。该时间是启动磁臂的时间s与磁头移动n条磁道所花费的时间之和，即<br><code>Ts=m*n+s</code><br>其中，m是一常数，与磁盘驱动器的速度有关，对一般磁盘，m=0.2; 对高速磁盘，m≤0.1，磁臂的启动时间约为2ms。</p></li><li><p>磁盘访问时间<br>(2)旋转延迟时间T π<br>指定扇区移动到磁头下面所经历的时间。<br>对于硬盘，典型的旋转速度大多为5400 r/min，每转需时11.1ms，平均旋转延迟时间Tπ为5.55ms;对于软盘，其旋转速度为300<br>r/min或600 r/min，这样，平均T τ为50~ 100 ms。</p></li><li><p>磁盘访问时间<br>(3)传输时间Tt<br>指把数据从磁盘读出或向磁盘写入数据所经历的时间。Tt的大小与每次所读/写的字节数b和旋转速度有关。<br><code>Tt=b/rN</code><br>其中，r为磁盘每秒钟的转数; N为一条磁道上的字节数，当一-次读/写的字节数相当于半条磁道上的字节数时，Tt与T τ相同。</p></li><li><p>磁盘访问时间<br>访问时间Ta表示为: </p><p><code>Ta=Ts+1/2r+b/rN</code><br>可见，数据存放集中，有利于提高传输效率。</p></li></ol><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><ol><li><p>先来先服务FCFS<br>(1)根据进程请求访问磁盘的先后次序，进行调度。<br>(2)举例说明<br>按照先来先服务的调度方法，得到平均寻道时间为55.3.<br>(3)简单，适合于请求磁盘I/O进程数目较少的场合。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218095531159.png" alt="image-20201218095531159"></p></li><li><p>最短寻道时间优先(SSTF)<br>(1)该算法优先选择这样的进程:该进程要求访问的磁道与当前磁头所在磁道的距离最近，以使每次的寻道时间最短。<br>(2)举例说明<br>按照最短寻道时间优先的调度方法，得到平均寻道时间为27.5.<br>(3)较之先来先服务的调度方法，有更好的寻道性能。</p><p>SSTF算法虽然能获得较好的寻道性能，却可能导致某个进程发生“饥饿”(Starvation)现象。因为只要不断有新进程的请求到达，且其所要访问的磁道、与磁头当前所在磁道的距离较近，这种新进程的I/0请求必须优先满足，老进程出现“饥饿”现象。对SSTF算法略加修改后，形成SCAN算法。</p></li><li><p>扫描SCAN算法<br>(1)该算法优先考虑的是磁头当前的移动方向，再考虑进程欲访问的磁道与当前磁道的距离最近。<br>(2)例如:</p><p>从磁道100#开始，向外移动方向;利<br>用扫描SCAN算法，得到磁道号次序为: 100， 150, 160，184， 90，58， 55，39， 38，18;平均寻道时间为27.8<br>(3) SCAN算法似电梯的运行，称电梯调度算法。SCAN算法具有较好的寻道性能，能够防止“饥饿’现象，应用于大、中、小型机器中。</p></li></ol><h3 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h3><ol><li>磁盘高速缓存的形式<br>指利用内存中的存储空间，来暂存从磁盘中读出的一系列盘块中的信息。高速缓存是一组在逻辑上属于磁盘，物理上是驻留在内存中的盘块。<br>高速缓存在内存中可分成两种形式。<br>(1)在内存中开辟一个单独的存储空间来作为磁盘高速缓存，其大小是固定的，不会受应用程序多少的影响;<br>(2)把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘I/O时(作为磁盘高速缓存)共享。当磁盘I/O的频繁程度较高时，该缓冲池可能包含更多的内存空间;而在应用程序运行得较多时，该缓冲池可能只剩下较少的内存空间。</li><li>数据交付方式<br>系统可以采取两种方式，将数据交付给请求进程:<br>(1)数据交付。直接将高速缓存中的数据，传送到请求者进程的内存工作区中。<br>(2)指针交付。只将指向高速缓存中某区域的指针，交付给请求者进程。后一种方式由于所传送的数据量少，节省了数据从磁盘高速缓存存储空间到进程的内存工作区的时间。</li><li>置换算法<br>由于请求调页中的联想存储器与高速缓存的工作情况不同，因而使得在置换算法中所应考虑的问题也有所差异。现在不少系统在设计其高速缓存的置换算法时，除了考虑到最近最久未使用这一原则外，还考虑了以下几点:<br>(1) 访问频率。<br>(2) 可预见性。<br>(3) 数据的一致性。</li><li>周期性地写回磁盘<br>在UNIX系统中专门增设了一个修改程序，在后台运行，该程序周期性地调用一个系统调用SYNC，其主要功能是强制性地将所有在高速缓存中已修改的盘块数据写回磁盘，一般是把两次调用SYNC的时间间隔定为30s。这样，因系统故障所造成的工作损失不会超过30s的劳动量。</li></ol><h3 id="提高磁盘I-O速度的其它方法"><a href="#提高磁盘I-O速度的其它方法" class="headerlink" title="提高磁盘I/O速度的其它方法"></a>提高磁盘I/O速度的其它方法</h3><ol><li>提前读。对于顺序文件的访问，可以采用预告读文件的方式，将下一个盘块的数据也读入缓冲区。</li><li>延迟写。如:在缓冲区A中的数据，不马上写回磁盘，只挂在空闲区的末尾。当进程使用缓冲区快到A时，再将A中的数据写入磁盘后，把缓冲区分配出去。</li><li>优化物理块的分布。一个文件的多个物理块安排的分散，会增加磁头的移动时间，寻道时间增大。可以将同一个磁道上的若干个盘块组成一个簇，如一个簇包含4个盘块，以簇为单位进行分配，提高访问速度。</li><li>虚拟盘。指利用内存空间去仿真磁盘，称为RAM盘。当创建虚拟盘后，其操作与硬盘一样;但虚拟盘是易失性存储器，当关机或重新启动计算机时，虚拟盘上的信息将被丢失，所以在关机或重新启动计算机前，一定要及时把在虚拟盘上的重要的数据存放到真正的硬盘中。</li></ol><h3 id="廉价磁盘冗余阵列"><a href="#廉价磁盘冗余阵列" class="headerlink" title="廉价磁盘冗余阵列"></a>廉价磁盘冗余阵列</h3><ol><li>并行交叉存取</li></ol><p>​    在系统中，有多台磁盘驱动器，系统将每一个盘块中的数据分为若千个子盘块数据，再把每一个子盘块的数据分别存储到各个不同磁盘中的相同位置上;当把数据传送到内存时，可采用并行传输方式，将各盘块中的子盘块数据，同时向内存中传输，大大减少传输时间。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218100348051.png" alt="image-20201218100348051"></p><p>例如:在存放一个文件时，可将该文件中的第1个数据子块放在第1个磁盘驱动器上;将该文件中的第2个数据子块放在第2个磁盘驱动器上;<br>…..将该文件中的第N个数据子块放在第N个磁盘驱动器上。在读取数据时，可采用并行传输方式，同时从1-N个数据 子块读出数据，将磁盘I/0的速度提高了N-1倍。</p><ol start="2"><li>RAID的分级<br>(1) RAID 0级。采用了并行交叉存取技术，提高了I/0速度。但无冗余校验功能，可靠性不好。<br>(2) RAID 1级。具有磁盘镜像功能。如:当磁盘阵列中具有8个盘时，利用4个作为数据盘，4个作为镜像盘，当读写数据时，同时写入数据盘和镜像盘。其可靠性较好，但磁盘利用率只有50%。<br>(3)RAID 3级。具有并行传输功能的磁盘阵列。它利用一台奇偶校验盘来完成数据的校验功能。如:当阵列中有7个盘时，利用6个作为数据盘，1 个作为校验盘，其磁盘利用率为6/7;常用于科学计算、图像处理等。</li></ol><p>(4) RAID 5级。是一种具有独立传送功能的磁盘阵列。每个驱动器都有各自独立的数据通路，独立地进行读写，无专门的校验盘;其校验信息，是以螺旋的方式，散布在所有数据盘上，故可靠性好。其磁盘利用率高;常用于I/0较频繁的事务处理中。<br>(5) RAID 6级和RAID 7级。在RAID6中，设置了1个专用的、可快速访问的异步校验盘; RAID7 是RAID6的改进;所有磁盘都具有较高的传输速率、优异的性能，但价格昂贵。</p><ol start="3"><li><p>RAID的优点<br> (1)可靠性高。<br>(2)磁盘I/O速度高。<br>(3)性能/价格比高。</p></li><li><p>磁盘访问时间由寻道时间 Ts、旋转延迟时间 Tr、传输时间 Tt 这三部分组成。 </p><p>（1）Ts 是启动磁臂时间 s 与磁头移动 n 条磁道的时间和，即 Ts = m × n + s。 </p><p>（2） Tr 是指定扇区移动到磁头下面所经历的时间。 硬盘 15000r/min 时 Tr 为 2ms;软盘 300 或 600r/min 时 Tr 为 50~100ms。</p><p>（3）Tt 是指数据从磁盘读出或向磁盘写入经历的时间。Tt 的大小与每次读/写的字节 数 b 和旋转速度有关：Tt = b/rN。</p></li></ol><h1 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h1><h2 id="文件、记录和数据项"><a href="#文件、记录和数据项" class="headerlink" title="文件、记录和数据项"></a>文件、记录和数据项</h2><p>文件:具有文件名的一组相关元素的集合<br>记录:一组有意义的数据项的集合<br>数据项:描述一个对象在某方面的属性</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101203114.png" alt="image-20201218101203114"></p><p>文件除了文件名之外，还包括:文件类型、文件长度、物理位置、建立时间等主要属性。</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101300199.png" alt="image-20201218101300199"></p><h2 id="文件系统模型"><a href="#文件系统模型" class="headerlink" title="文件系统模型"></a>文件系统模型</h2><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101315444.png" alt="image-20201218101315444"></p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101326902.png" alt="image-20201218101326902"></p><h1 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h1><h2 id="文件逻辑结构的类型"><a href="#文件逻辑结构的类型" class="headerlink" title="文件逻辑结构的类型"></a>文件逻辑结构的类型</h2><p>通常，将文件的逻辑结构分为两大类:<br>1.有结构文件.</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101510849.png" alt="image-20201218101510849"></p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101531847.png" alt="image-20201218101531847"></p><p>2.无结构文件</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101553779.png" alt="image-20201218101553779"></p><h2 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h2><ol><li><p>逻辑记录的排序</p><table><thead><tr><th>排序类型</th><th>顺序</th><th>查找算法</th></tr></thead><tbody><tr><td>串结构</td><td>存入时间有序</td><td>顺序查找</td></tr><tr><td>顺序结构</td><td>关键字有序(如字母顺序等)</td><td>高效算法(折半,插值,跳步)</td></tr></tbody></table></li><li><p>对顺序文件的读/写操作<br>对于定长记录(记录长L)的文件，在读一个文件时，可设置一个指针Rptr为当前记录的逻辑地址的首地址，通过Rptr+=L,确定下一条记录的逻辑地址。同样，在写文件时，通过Wptr+=L, 确定下一条记录的逻辑地址。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218101953069.png" alt="image-20201218101953069"></p></li><li><p>顺序文件的优缺点<br>优点:<br>在对记录进行批量存取时，效率最高。<br>缺点:<br>在交互应用时，如果增加或删除一个记录时，性能较差。</p></li></ol><h2 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h2><p>对于变长记录的顺序文件，可设置一个读写指针，加上每条记录的长度，确定下一条记录的逻辑地址。针对变长记录的顺序文件，由于记录长度不同，只能顺序读取，故引入索引文件。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218102128191.png" alt="image-20201218102128191"></p><p>组织方法:<br>为变长记录文件建立索引表，包括每个记录的索引号、长度、及指向该记录的指针。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218102214393.png" alt="image-20201218102214393"></p><p>(1) 优点:在对索引文件检索时，首先检索索引表。由于索引表本身是一个定长记录的顺序文件，可利用折半查找法去检索索引表，从中找到相应的表项，通过表项指针，方便地对主文件中的记录实现直接存取。<br>(2)缺点:索引文件除了主文件外，还须配置一个索引表，在索引表中，每个记录都要有一个索引项，因此提高了存储费用。</p><h2 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h2><p>索引顺序文件，是顺序文件、索引文件上述两种文件构成方式的结合。<br>其所有记录按顺序方式组织，首先，将所有记录分为若干个组;然后，为主文件建立一张索引表，在索引表中为每组中的第一个记录建立一个索引项。</p><p>在索引顺序文件进行检索时，首先根据提供的关键字，检索索引表，找到该记录所在记录组中、第一个记录的表项，从而得到该记录组第一个记录在主文件中的位置;然后，再利用顺序查找法，去查找主文件，从中找到所要求的记录。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218103634556.png" alt="image-20201218103634556"></p><h2 id="直接文件和哈希文件"><a href="#直接文件和哈希文件" class="headerlink" title="直接文件和哈希文件"></a>直接文件和哈希文件</h2><ol><li>直接文件<br>根据给定的记录键值直接获得指定记录的物理地址，称为键值转换。</li><li>哈希文件<br>利用Hash函数，将记录键值转换为相应记录的地址。</li></ol><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218103741370.png" alt="image-20201218103741370"></p><h1 id="外存分配方式"><a href="#外存分配方式" class="headerlink" title="外存分配方式"></a>外存分配方式</h1><h2 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h2><ol><li>连续分配方式要求为每一个文件分配一组相邻接的盘块,将逻辑文件中的记录，顺序地存储到邻接的物理盘块中，这样形成的文件称为顺序文件结构。<br>在文件目录中，需要记录文件第一个记录所在盘块号、及文件长度。<br>文件空间的分配与回收算法，与内存的动态分区分配算法相似。</li><li>连续分配方式的优缺点<br>优点:<br>顺序访问速度快。<br>缺点:<br>(1)要求有连续的存储空间;<br>(2)必须事先知道文件的长度;<br>(3)不能灵活地删除和插入记录。</li></ol><h2 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h2><ul><li><p>连接文件:为文件<font color='red'>分配多个不连续的盘块</font>,在通过每个盘块上的链接指针,将同属于一个文件的多个离散盘块,链接成一个链表.</p><ul><li>(1)采用离散分配方式,消除了外部碎片;</li><li>(2)能满足文件的动态增长的需要,无需事先知道文件的大小;</li><li>(3)对插入,删除和修改记录比较容易.</li></ul></li><li><p>隐式链接</p><ul><li><p>在文件目录的每个目录项中,都必须含有指向链接文件的第一个盘块和最后一个盘块的指针.</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218110559712.png" alt="image-20201218110559712"></p></li><li><p>隐式链接的分配方式提高了外存的利用率,但存在以下问题:</p><p>(1)只适合于顺序访问,不适合随机访问:例如:但访问文件所在的第i个盘块时,必须先读出文件的第一个盘块第二个盘块…就这样顺序的查找.直到第i个盘块.</p><p>(2)可靠性差.只要有一个指针出现问题,就会导致整个链断开.</p></li></ul></li><li><p>显式连接</p><ul><li><p>把用于连接文件的各物理块的指针,显式地存放在内存的文件分配表中.</p></li><li><p>在整个磁盘中,仅设置一张文件分配表FAT,表的序号是物理块号,从0开始,每个文件的物理地址,即文件存放的第一个盘块,可指向文件分配表相对应的盘块号.</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218111246819.png" alt="image-20201218111246819"></p></li></ul></li></ul><h2 id="FAT和NTFS技术"><a href="#FAT和NTFS技术" class="headerlink" title="FAT和NTFS技术"></a>FAT和NTFS技术</h2><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218111303009.png" alt="image-20201218111303009"></p><ul><li>早期的MS-DOS，采用FAT12文件系统:<br>(1) FAT表占用的存储空间。对于1.2MB软盘， 每个盘块大小为512B，FAT中共有2.4K个表项(1.2MB/512B) ; 每个表项占12位(1.5B) ，故FAT表占用3.6KB的存储空间(<code>2.4K*1.5B</code>) 。<br>(2)最大磁盘容量。FAT表最多允许212=4096个表项，假设每个盘块为512B,则每个磁盘分区的容量为2MB(4096*512B)。一个物理磁盘支持4个逻辑分区,磁盘的最大容量为8MB。<br>(3)簇是一组连续的扇区，在盘块分配时，当不以盘块为单位、以簇为基本单位时，可适应大容量磁盘的需要。假设一个簇包含两个扇区时，磁盘的最大容量为16MB;当一个簇包含8个扇区时，磁盘的最大容量为64MB。随着磁盘容量的增加，簇内碎片成倍增加。<br>(4)只能支持8+3格式的文件名。</li></ul><h2 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h2><ol><li><p>单级索引分配<br>为**<em>每个文件分配一个索引块**</em>，再把分配给该文件的所有盘块号都记录在该索引块中。</p><p>在文件的目录项中包含指向该索引块的指针。</p></li></ol><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218115916162.png" alt="image-20201218115916162"></p><ul><li>优点:单级索引分配方式支持直接访问。如:当读文件的第i个盘块时，可以方便地从索引块中找到第i个盘块号。</li><li>缺点:当文件只需要1-2个盘块时，仍需为之分配一个索引块，索引块的利用率很低。</li></ul><ol start="2"><li>多级索引分配<ul><li>大文件需占据多个索引块，通过链指针将各索引块按序链接起来。</li><li>索引块较多时，可继续为索引块建立索引。即系统再分配一个索引块，将一级索引的索引块，如第一块、第二块…等索引块的盘块号填入到此索引表中，形成两级索引方式。</li></ul></li></ol><p>(1)如果每个盘块大小为4KB，每个盘块号占4B大小，则一个索引块可放1K个盘块号，单级索引所允许的文件大小为4MB。<br>(2)这样，两级索引可包含的盘块号总数1K* 1K=1M个盘块号，所允许的文件长度为4GB。</p><ol start="3"><li>混合索引分配<br>将多种索引分配方式相结合而形成的一种分配方式<br>(1)直接地址<br>(2)一次间接地址<br>(3)多次间接地址</li></ol><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218120457660.png" alt="image-20201218120457660"></p><h1 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h1><h2 id="文件控制块和索引结点"><a href="#文件控制块和索引结点" class="headerlink" title="文件控制块和索引结点"></a>文件控制块和索引结点</h2><ol><li><p>文件控制块FCB<br>定义:是操作系统用来描述和控制文件的数据结构。</p><ul><li>每一个文件都有一个文件控制块，文件控制块的有序集合称为文件目录。FCB包含三类信息:<br>(1)基本信息<br>(2)存取控制信息<br>(3)使用信息</li></ul></li><li><p>索引结点<br>UNIX系统中，把文件名和文件描述信息分开，由文件描述信息单独构成索引结点(简称i结点)</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218151931794.png" alt="image-20201218151931794"></p></li><li><p>磁盘索引结点</p><ul><li>文件主标识符</li><li>文件类型</li><li>文件存取权限</li><li>文件物理地址</li><li>文件长度</li><li>文件连接计数</li><li>文件存取时间</li></ul></li><li><p>内存索引结点</p><ul><li>索引结点编号</li><li>状态</li><li>访问计数</li><li>文件系统的逻辑设备号</li><li>链接指针</li></ul></li></ol><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h2 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218153351448.png" alt="image-20201218153351448"></p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218153404934.png" alt="image-20201218153404934"></p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218153433550.png" alt="image-20201218153433550"></p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218153450747.png" alt="image-20201218153450747"></p><h2 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h2><p>当用户要访问一个文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件的索引结点;然后，根据索引结点中所记录的盘块号，换算出文件在磁盘上的物理位置;最后，通过磁盘驱动程序，将所需文件读入内存。目录查询方式主要有两种:</p><p>(1)线性检索法(2) hash方法</p><ol><li><p>线性检索法<br>在树形目录中，用户提供的文件名是由多个文件分量名组成的路径名，此时需对多级目录进行查找。例如:查找usr/ast/mbox文件的过程。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218153810887.png" alt="image-20201218153810887"></p></li><li><p>Hash方法<br>若建立了一张Hash索引文件目录，系统利用用户提供的文件名，并将它变换为文件目录的索引值，再利用该索引值到目录中去查找。</p></li></ol><h1 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h1><h2 id="空闲表法和空闲链表法"><a href="#空闲表法和空闲链表法" class="headerlink" title="空闲表法和空闲链表法"></a>空闲表法和空闲链表法</h2><ol><li><p>空闲表法<br>(1)空闲表的组织属于连续分配方式，为所有空闲区，建立一张空闲表，每个空闲区对应一个空闲表项，再将所有空闲区按，其起始盘块号递增的次序排列。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218154254156.png" alt="image-20201218154254156"><br>(2)存储空间的分配与回收<br>分配过程:可采用**<em>首次适应算法或最佳适应算法**</em>，顺序地检索空闲表的各表项，直至找到第一个其大小能满足要求的空闲区，再将该盘区分配给用户(进程)，同时修改空闲表。<br>回收过程:同内存回收的方法。<br>(3)特点:属连续分配方式，可减少访问磁盘的I/O频率，适应于文件较小的场合或对换区管理中。</p></li><li><p>空闲链表法<br>(1) 空闲盘块链<br>将磁盘上的所有空闲区以*<strong>盘块**<em>为单位拉成一条链，其中的每一个盘块都有指向后继盘块的指针。当用户因创建文件请求分配存储空间时，系统从空闲盘块链首开始，依次摘下适当数目的空闲盘块分配给用户。<br>当删除文件时，系统将回收的盘块依次插入到空闲盘块链的末尾。这种方式简单，但</em></strong>磁盘操作次数重复多次***。</p><p>(2) 空闲盘区链<br>将磁盘上的所有空闲盘区(<strong>每个盘区可包含若干个盘块</strong>)拉成一条链。在每个盘区上除含有指示下一个空闲盘区的指针外，还有指明本空闲盘区的盘块数。其分配、回收算法与内存的动态分区方式相似，通常采用首次适应算法。</p></li></ol><h2 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h2><ol><li><p>位示图<br>将磁盘_上的所有盘块，都有一个二进制位与之对应，可用M*N个位数构成位示图，<code>M*N</code>等 于磁盘的总块数。利用二进制的一位“0”、或者“1”来表示磁盘中一个盘块的使用情况。</p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218154729556.png" alt="image-20201218154729556"></p><ul><li><p>盘块的分配</p><p>(1)顺序扫描位示图,从中找出一个或一组其值为”0”的二进制位( “0”表示空闲时)。<br>(2)将所找到的一个或一组二 进制位,转换成与之相应的盘块号。公式: <code>b=n(i-1)+j</code></p><p>(3)修改位示图，令map [i,j] =1。</p></li><li><p>盘块的回收<br>(1)将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为: <code>i=(b-1)DIV n+1</code> ;<code> j= (b-1)MOD n+1</code><br>(2)修改位示图。令map [i,j] =0。</p></li></ul></li></ol><h2 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h2><ol><li><p>空闲盘块的组织<br>(1) 空闲盘块号栈，用来存放当前可用的一组空闲盘块的盘块号，以及栈中尚有的空闲盘块数N，N有栈顶指针的作用</p><p>(2) 文件区中的所有空闲盘块被分成若干个组。<br>(3) 将每一组含有的盘块总数N和该组所有的盘块号记入其**<em>前一组**</em>的第一个盘块的S. free(0) ~S. free (99)中。</p><p>(4)将第一组的盘块总数和所有的盘块号记入空闲盘块号栈中，作为当前可供分配的空闲盘块号。</p><p>(5) 最末一组只有99个盘块，其盘块号分别记入其前一组的S. free(1) ~S. free (99)中，而在S. free(0)中则存放‘0”,作为空闲盘块链的结束标志。</p></li></ol><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218155035413.png" alt="image-20201218155035413"></p><ol start="2"><li><p>空闲盘块的分配<br>(1) 检查空闲盘块号栈是否上锁。若未上锁，则从栈顶取出一空闲盘块号将与之对应的盘块分配给用户，然后将栈顶指针下移一格。若该盘块号已是栈底S.free(0)，栈中最后一个可分配的盘块;由于该盘块中记录有下一组可用 的盘块号，须调用磁盘读过程， 将栈底盘块号所对应盘块的内容读入栈中，作为新盘块号栈的内容，并将原栈底对应的盘块分配出去。<br>(2) 然后，分配一相应的缓冲区(作为该盘块的缓冲区)。<br>(3)最后，把栈中的空闲盘块数减1，并返回。</p></li><li><p>空闲盘块的回收<br>(1)将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加1操作。<br>(2)当栈中空闲盘块号数目已达100时，表示栈已满，便将现有栈中的100个盘块号记入新回收的盘块中，再将其盘块号作为新栈底。</p></li></ol><h1 id="文件的共享与保护"><a href="#文件的共享与保护" class="headerlink" title="文件的共享与保护"></a>文件的共享与保护</h1><h2 id="基于索引结点的文件共享"><a href="#基于索引结点的文件共享" class="headerlink" title="基于索引结点的文件共享"></a>基于索引结点的文件共享</h2><ul><li>利用索引结点实现共享<br>利用索引结点，将文件的物理地址、以及其它的文件属性等信息，不再放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。任何用户对文件进行增加、或者修改操作，所引起的相应结点内容的改变，都是其他用户可见的。<br>在索引结点中，还设置一个链接计数count，用于表示链接到本索引结点(即文件)上的用户目录项的数目。</li></ul><h2 id="利用符号链实现文件共享"><a href="#利用符号链实现文件共享" class="headerlink" title="利用符号链实现文件共享"></a>利用符号链实现文件共享</h2><ul><li>思想:允许一个文件或子目录有多个父目录，但其中仅有一个作为主父目录，其它的几个父目录都是通过符号链接方式与之相链接的。</li><li>例如:为使B能共享C的一个文件F，可以由系统创建一个LINK类型的同名新文件F，并把该文件放在B的目录中，该新文件的内容只包含了被链接文件的路径名。这种链接方法称为符号链接，新文件中的路径名被称为符号链，当B去读LINK类型的文件时，将被OS截获，OS根据新文件中的路径名，去读那个文件，从而实现用户B对文件的共享。</li><li>优点:能够链接任何地方的文件，只需提供该文件所在机器的网络地址、以及该机器中的文件路径即可。</li><li>缺点:按路径查找进行访问，可能需要多次的读盘，开销大。允许使用多个不同的名字访问共享文件，因此遍历文件系统时，会重复访问此共享文件。</li></ul><h2 id="磁盘容错技术"><a href="#磁盘容错技术" class="headerlink" title="磁盘容错技术"></a>磁盘容错技术</h2><ol><li>第一级容错技术<br>(1)双份目录和双份文件分配表<br>(2)热修复重定向和写后读校验<ul><li>热修复重定向</li><li>写后读校验方式</li></ul></li></ol><ul><li>热修复重定向区:系统将磁盘容量的一部分(如2%-3%)作为热修复重定向区，用于存放当发现磁盘有缺陷时的待写数据，并对写入该区的数据进行登记，以便以后对数据进行访问。</li><li>写后读校验方式:为保证数据写入到完好的盘块中，应每次从内存缓冲区向磁盘中写入一个数据块后，又立即从磁盘上读出该数据块，并送至另一个缓冲区中，再将该缓冲区内容、与内存缓冲区保留的数据进行比较。若一致，则写入成功;若不一致，再重写;若重写后仍不一致，认为该盘块有缺陷，此时，便将应写入该盘块的数据，写入到热修复重定向区中。</li></ul><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218160729872.png" alt="image-20201218160729872"></p><p><img src="C:\Users\xly\AppData\Roaming\Typora\typora-user-images\image-20201218160743925.png" alt="image-20201218160743925"></p><h1 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h1><h2 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h2><ul><li>用户在终端上键入命令，由终端处理程序接收该命令，并在用户终端屏幕上，以字符方式显示用户输入的命令信息、及命令执行结果。用户在终端 上键入的命令称为命令语言，命令语言以命令为基本单位完成OS特定的功能，可分(1) 为命令行方式、(2)批命令方式。</li><li>命令行方式指以行为单位输入和显示不同的命令，是由一组命令动词和参数组成的，具有规定的词法、语法和语义。<br>一般形式为: command argl arg2 … argn</li><li>其命令执行是串行的、间断的，当一条命令执行完成后，系统发出新的命令输入提示符，用户继续输入下一条命令。</li><li>操作系统支持一种批命令的接口方式，允许用户预先将一系列命令组织在一种称为批命令的文件中，一次建立，多次执行。<br>如: DOS的. BAT文件，UNIX的shell文件等。<br>可减少用户输入命令的次数，节省时间、减少出错概率。</li></ul><h3 id="联机命令的类型"><a href="#联机命令的类型" class="headerlink" title="联机命令的类型"></a>联机命令的类型</h3><h4 id="系统访问类"><a href="#系统访问类" class="headerlink" title="系统访问类"></a>系统访问类</h4><p>注册命令: Login    /提示用户键入自己的注册名<br>                 Password  /提示用户键入自己的口令</p><h4 id="磁盘操作类"><a href="#磁盘操作类" class="headerlink" title="磁盘操作类"></a>磁盘操作类</h4><p>(1)磁盘格式化命令Format<br>(2)复制整个软盘命令Diskcopy。<br>(3)软盘比较命令Diskcomp。<br>(4)备份与恢复命令Backup、Restore</p><h4 id="文件操作类"><a href="#文件操作类" class="headerlink" title="文件操作类"></a>文件操作类</h4><p>(1) 显示文件命令type<br>(2) 拷贝文件命令copy<br>(3)文件比较命令comp<br>(4) 重新命名命令Rename<br>(5) 删除文件命令erase</p><h4 id="目录操作类"><a href="#目录操作类" class="headerlink" title="目录操作类"></a>目录操作类</h4><p>(1) 建立子目录命令mkdir<br>(2) 显示目录命令dir<br>(3) 删除子目录命令rmdir<br>(4) 显示目录结构命令tree<br>(5) 改变当前目录命令chdir</p><h4 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h4><p>(1)输入输出重定向命令<br>(2)管道连接Command1| Command2|…|Commandn<br>(3)过滤命令find/N “erase”</p><p>许多操作系统提供了命令的并发执行方式，UNIX系统提供了这种机制，用户可以在命令后面加上“&amp;”号，将该命令放在后台执行。<br>例如:当文件打印时间较长时，可将其作为后台命令处理，以便用户在前台继续键入其它命令，两条命令可并行处理。</p><h4 id="特殊字符处理"><a href="#特殊字符处理" class="headerlink" title="特殊字符处理"></a>特殊字符处理</h4><p>(1) 中断字符。许多系统中，利用Break或Delete或Ctrl+C键作为中断字符。<br>(2) 停止上卷字符。许多系统中，是利用Ctrl+S键来停止屏幕上卷的。<br>(3) 恢复上卷字符。许多系统中，利用Ctrl+Q键使停止上卷的屏幕恢复上卷。</p><ul><li>在联机操作方式下，终端处理程序把用户键入的信息送到键盘缓冲区中保存，当用户键入回车符，便把控制权交给命令解释程序。命令解释程序在屏幕上给出提示符，请用户键入命令，然后读入该命令、识别命令，再转到相应命令处理程序的入口地址，执行该处理程序，并将处理结果送屏幕上显示。若用户键入的命令有错，而命令解释程序未能予以识别，或在执行中间出现问题时，应显示某一出错信息。</li></ul><h2 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h2><ul><li><p>程序接口，又称应用编程接口API (ApplicationProgramming Interface)， 是应用程序同操作系统之间的接口。<br>程序接口是由操作系统提供的所有系统调用所构成的集合。</p></li><li><p>所谓，系统调用，就是用户在程序中调用操作系统所提供的一些子功能。通过系统调用命令，中断现行程序，转去执行相应的特定系统功能，完成后，又返回到被中断程序，从发出调用命令之后的一条指令继续执行下去。</p></li><li><p>在程序中执行系统调用或过程调用，虽然都是对某种功能或服务的需求，但两者从调用形式到具体实现都有很大区别。<br>(1)调用形式不同</p><p>过程调用使用一般调用指令，其转向地址是固定不变的，包含在跳转语句中;但系统调用中不包含处理程序入口，而仅仅提供功能号，按功能号调用。</p><p>(2)被调用代码的位置不同</p><p>过程调用是一种静态调用，调用者和被调用代码在同一程序内，经过编译链接后作为目标代码的一部分。当过程升级或修改时，必须重新编译连接。系统调用是一种动态调用，系统调用的处理代码在操作系统中，系统调用处理代码升级或修改时，与调用程序无关。而且，调用程序的长度也大大缩短，减少了调用程序占用的存储空间。</p><p>(3)提供方式不同</p><p>过程调用往往由编译系统提供，不同编译系统提供的过程可以不同;系统调用由操作系统提供，一旦操作系统设计好，系统调用的功能、种类与数量便固定不变。</p><p>(4)调用的实现不同</p><p>程序使用一般机器指令(跳转指令)进行过程调用，是在用户态运行的;程序执行系统调用，是通过中断机构来实现，需要从用户态转变到核心态，在管理状态下执行，安全性好。</p></li><li><p>系统调用的类型</p><ol><li><p>进程控制类系统调用</p><p>(1)创建进程(fork)。<br>(2)终止进程(exit)。<br>(3)等待子进程结束(wait)。<br>(4)执行一个文件(exec)。<br>(5)获得进程ID。<br>(6)获得用户ID。<br>(7)进程暂停(pause)。</p></li><li><p>文件操纵类系统调用</p><p>(1)创建文件(creat)。<br>(2)打开文件(open)。<br>(3)关闭文件(close)。<br>(4)读和写文件read和write。<br>(5)连接和去连接(link和unlink)</p></li><li><p>进程通信类系统调用</p><p>(1)消息机制。<br>(2)共享存储器机制。<br>(3) 信号量机制。</p></li></ol></li><li><p>系统调用的实现<br>首先，将处理机状态由用户态转为系统态;由硬件和内核程序进行系统调用的一般性处理，即保护被中断进程的CPU环境，将处理机状态字PSW、程序计数器PC、系统调用号、用户栈指针以及通用寄存器内容等，压入堆栈;将用户定义的参数传送到指定的地方保存起来。其次，分析系统调用类型，转入相应的系统调用处理子程序。最后，在系统调用处理子程序执行完成后，应恢复被中断(或设置新的)进程的CPU现场，使被中断进程( 或新进程)，继续往下执行。</p></li></ul><h2 id="图形接口"><a href="#图形接口" class="headerlink" title="图形接口"></a>图形接口</h2><ul><li><p>图形用户界面GUI (Graphical User Interface) 是指采用图形方式显示的计算机操作界面。20世纪80年代苹果公司将图形用户界面引入微机领域，而后微软公司推出了Windows系统，使得GUI被广泛应用于个人计算机平台。与早期计算机使用的命令行相比，图形界面对于用户来说在视觉上更易于接受，用户使用鼠标等输入设备,操纵屏幕上的图标或菜单选项，不需要死记硬背大量的命令，可以通过窗口、菜单等方式，方便地进行操作。</p></li><li><p>所谓桌面是指整个屏幕空间，即在运行Windows时用户所看到的屏幕。桌面由多个任务共享。<br>桌面上的图标，用于启动应用程序点击图标，可以完成启动程序、显示数据这两个步骤的工作。<br>设置任务栏的目的，是帮助用户快速启动常用的程序，方便地切换当前的程序。</p></li><li><p>窗口是指屏幕，上的一块矩形区域，每个任务都通过各自的窗口,显示其操作和运行情况。应用程序可通过窗口向用户展示出系统所能提供的各种服务及其需要用户输入的信息;用户可通过窗口中的图标去查看和操纵应用程序或文档。</p></li><li><p>对话框是一个只包含标题栏、输入框、按钮的临时窗口，主要用途是实现人机对话，即系统可通过对话框提示用户输入与任务有关的信息。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows快捷键</title>
      <link href="2020/12/06/windows-kuai-jie-jian/"/>
      <url>2020/12/06/windows-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<ol><li><code>Windows+Ctrl+D</code>:创建一个新桌面</li><li><code>Windows+Ctrl+→或者←</code>:切换桌面</li><li><code>Windows+M</code>:全部最小化</li><li><code>Windows+1到9</code>:打开任务栏的应用</li><li><code>Windows+→和←</code>:两个文件半屏查看</li><li><code>Ctrl+Al+Tab</code>:显示当前PC上运行的所有应用</li><li><code>Ctrl+Shift+Esc</code>:打开任务管理器</li><li><code>Windows+E</code>:打开文件管理视图</li><li><code>Windows++或-</code>:打开放大镜</li><li><code>Windows+Print Screen</code>:全屏截图并保存在Image文件目录下</li><li><code>Windows+A</code>:打开通知中心</li><li><code>Windows+I</code>:打开设置</li><li><code>Window+L</code>:锁定用户</li><li><code>Ctrl+Shift+N</code>:新建文件夹</li><li><code>Windows+D</code>:实现桌面和应用切换和最小化不一样可以重新打开</li><li><code>三指下滑回到桌面</code></li><li><code>三指上滑回到应用</code></li><li><code>四指左右滑动切换桌面</code></li><li><code>Windows+R</code>:打开运行</li></ol>]]></content>
      
      
      <categories>
          
          <category> window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring注解(下)</title>
      <link href="2020/12/03/spring-zhu-jie-xia/"/>
      <url>2020/12/03/spring-zhu-jie-xia/</url>
      
        <content type="html"><![CDATA[<p>断点:</p><pre><code>AbstractAdvisorAutoProxyCreator.setBeanFactory()AbstractAdvisorAutoProxyCreator.initBeanFactory()AnnotationAwareAspectJAutoProxyCreator.initBeanFactory()AbstractAutoProxyCreator.setBeanFactory()AbstractAutoProxyCreator.postProcessBeforeInstantiation()AbstractAutoProxyCreator.postProcessAfterInitialization()MainConfigOfAOP.calculator()[需要初始化的被切入点表达式匹配的bean]MainConfigOfAOP.logger()[需要初始化的切面类]</code></pre><pre><code>/** * AOP：【动态代理】 *        指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式； * * 1、导入aop模块；Spring AOP：(spring-aspects) * 2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx） * 3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行； *        通知方法： *           前置通知(@Before)：logStart：在目标方法(div)运行之前运行 *           后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束） *           返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行 *           异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行 *           环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()） * 4、给切面类的目标方法标注何时何地运行（通知注解）； * 5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中; * 6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect) * [7]、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】 *        在Spring中很多的 @EnableXXX; * * 三步： *     1）、将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect） *     2）、在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式） *  3）、开启基于注解的aop模式；@EnableAspectJAutoProxy * * AOP原理：【看给容器中注册了什么组件，这个组件什么时候工作，这个组件的功能是什么？】 *        @EnableAspectJAutoProxy； * 1、@EnableAspectJAutoProxy是什么？ *        @Import(AspectJAutoProxyRegistrar.class)：给容器中导入AspectJAutoProxyRegistrar *           利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion *           internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator * *        给容器中注册一个AnnotationAwareAspectJAutoProxyCreator； * * 2、 AnnotationAwareAspectJAutoProxyCreator： *        AnnotationAwareAspectJAutoProxyCreator *           -&gt;AspectJAwareAdvisorAutoProxyCreator *              -&gt;AbstractAdvisorAutoProxyCreator *                 -&gt;AbstractAutoProxyCreator *                       implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware *                    关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory * * AbstractAutoProxyCreator.setBeanFactory() * AbstractAutoProxyCreator.有后置处理器的逻辑； * * AbstractAdvisorAutoProxyCreator.setBeanFactory()-》initBeanFactory() * * AnnotationAwareAspectJAutoProxyCreator.initBeanFactory() * * * 流程： *        1）、传入配置类，创建ioc容器 *        2）、注册配置类，调用refresh（）刷新容器； *        3）、registerBeanPostProcessors(beanFactory);注册bean的后置处理器来方便拦截bean的创建； *           1）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor *           2）、给容器中加别的BeanPostProcessor *           3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor； *           4）、再给容器中注册实现了Ordered接口的BeanPostProcessor； *           5）、注册没实现优先级接口的BeanPostProcessor； *           6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中； *              创建internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】 *              1）、创建Bean的实例 *              2）、populateBean；给bean的各种属性赋值 *              3）、initializeBean：初始化bean； *                    1）、invokeAwareMethods()：处理Aware接口的方法回调 *                    2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（） *                    3）、invokeInitMethods()；执行自定义的初始化方法 *                    4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）； *              4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；--》aspectJAdvisorsBuilder *           7）、把BeanPostProcessor注册到BeanFactory中； *              beanFactory.addBeanPostProcessor(postProcessor); * =======以上是创建和注册AnnotationAwareAspectJAutoProxyCreator的过程======== *   返回代理对象 *           AnnotationAwareAspectJAutoProxyCreator =&gt; InstantiationAwareBeanPostProcessor *        4）、finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作；创建剩下的单实例bean *           1）、遍历获取容器中所有的Bean，依次创建对象getBean(beanName); *              getBean-&gt;doGetBean()-&gt;getSingleton()-&gt; *           2）、创建bean *              【AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor，会调用postProcessBeforeInstantiation()】 *              1）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建； *                 只要创建好的Bean都会被缓存起来 *              2）、createBean（）;创建bean； *                 AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例 *                 【BeanPostProcessor是在Bean对象创建完成初始化前后调用的】 *                 【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象的】 *                 1）、resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation *                    希望后置处理器在此能返回一个代理对象；如果能返回代理对象就使用，如果不能就继续 *                    1）、后置处理器先尝试返回对象； *                       bean = applyBeanPostProcessorsBeforeInstantiation（）： *                          拿到所有后置处理器，如果是InstantiationAwareBeanPostProcessor; *                          就执行postProcessBeforeInstantiation *                       if (bean != null) &#123;bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);&#125; * *                 2）、doCreateBean(beanName, mbdToUse, args);真正的去创建一个bean实例；和3.6流程一样； *                 3）、尝试创建代理对象失败真正去创建一个对象时的后置处理器的postProcessAfterInitialization把对象封装为代理对象 * * * AnnotationAwareAspectJAutoProxyCreator【InstantiationAwareBeanPostProcessor】 的作用： * 1）、每一个bean创建之前，调用postProcessBeforeInstantiation()； *        关心MathCalculator和LogAspect的创建 *        1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean） *        2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean， *           或者是否是切面（@Aspect） *        3）、是否需要跳过 *           1）、获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】 *              每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor； *              判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true *           2）、永远返回false * * 2）、创建对象 * postProcessAfterInitialization； *        return wrapIfNecessary(bean, beanName, cacheKey);//包装如果需要的情况下 *        1）、获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors *           1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的） *           2、获取到能在bean使用的增强器。 *           3、给增强器排序 *        2）、保存当前bean在advisedBeans中； *        3）、如果当前bean需要增强，创建当前bean的代理对象； *           1）、获取所有增强器（通知方法） *           2）、保存到proxyFactory *           3）、创建代理对象：Spring自动决定 *              JdkDynamicAopProxy(config);jdk动态代理； *              ObjenesisCglibAopProxy(config);cglib的动态代理； *        4）、给容器中返回当前组件使用cglib增强了的代理对象； *        5）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程； * * *     3）、目标方法执行  ； *        容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）； *        1）、CglibAopProxy.intercept();拦截目标方法的执行 *        2）、根据ProxyFactory对象获取将要执行的目标方法拦截器链； *           List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); *           1）、List&lt;Object&gt; interceptorList保存所有拦截器 5 *              一个默认的ExposeInvocationInterceptor 和 4个增强器； *           2）、遍历所有的增强器，将其转为Interceptor； *              registry.getInterceptors(advisor); *           3）、将增强器转为List&lt;MethodInterceptor&gt;； *              如果是MethodInterceptor，直接加入到集合中 *              如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor； *              转换完成返回MethodInterceptor数组； * *        3）、如果没有拦截器链，直接执行目标方法; *           拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制） *        4）、如果有拦截器链，把需要执行的目标对象，目标方法， *           拦截器链等信息传入创建一个 CglibMethodInvocation 对象， *           并调用 Object retVal =  mi.proceed(); *        5）、拦截器链的触发过程; *           1)、如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-1大小一样（指定到了最后一个拦截器）执行目标方法； *           2)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行； *              拦截器链的机制，保证通知方法与目标方法的执行顺序； * *     总结： *        1）、  @EnableAspectJAutoProxy 开启AOP功能 *        2）、 @EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator *        3）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器； *        4）、容器的创建流程： *           1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象 *           2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean *              1）、创建业务逻辑组件和切面组件 *              2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程 *              3）、组件创建完之后，判断组件是否需要增强 *                 是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）； *        5）、执行目标方法： *           1）、代理对象执行目标方法 *           2）、CglibAopProxy.intercept()； *              1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor） *              2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行； *              3）、效果： *                 正常执行：前置通知-》目标方法-》后置通知-》返回通知 *                 出现异常：前置通知-》目标方法-》后置通知-》异常通知 * * * */</code></pre><h1 id="AOP流程"><a href="#AOP流程" class="headerlink" title="AOP流程"></a>AOP流程</h1><p>分为三步</p><ol><li><p>注册<code>internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator</code>后置处理器到<code>BeanFactory</code>中(<code>BeanFactory</code>时ioc容器的顶级接口)</p></li><li><p>创建bean对象的代理对象代替原本的bean对象</p><ol><li><p>创建bean代理对象时有一个<code>resolveBeforeInstantiation(beanName, mbdToUse);</code>解析<code>BeforeInstantiation</code></p><ul><li><p>[<code>BeanPostProcessor</code>是在Bean对象创建完成初始化前后调用的] (<code>xxxInitialization</code>) </p><p>[<code>InstantiationAwareBeanPostProcessor</code>是在创建Bean实例之前先尝试用后置处理器返回对象的] (<code>xxxInstantiation</code>)</p><ul><li><pre><code>                    希望后置处理器在此能返回一个代理对象；如果能返回代理对象就使用，如果不能就继续</code></pre></li><li><pre><code>                    结果返回对象为null,就`doCreateBean(beanName, mbdToUse, args);`真正的去创建一个bean实例；创建对象时有后置处理器处理时`postProcessAfterInitialization.wrapIfNecessary`将对象替换为代理对象,而`postProcessBeforeInitialization`方法直接返回原对象</code></pre></li></ul></li></ul></li></ol></li><li><p>创建拦截器,拦截器进行链式拦截</p><p><img src="/medias/AOP/%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="拦截器链执行过程" title="拦截器链执行过程"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> spring注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring注解AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring注解(上)</title>
      <link href="2020/11/29/spring-zhu-jie-shang/"/>
      <url>2020/11/29/spring-zhu-jie-shang/</url>
      
        <content type="html"><![CDATA[<p>导入ioc jar<code>spring-context</code></p><pre><code>&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;4.3.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="bean注解"><a href="#bean注解" class="headerlink" title="bean注解"></a>bean注解</h1><pre><code>    /**     * @Bean 返回值类型就是class方法名就是id，要是加上value值或者name方法名就不是id     * @Scope 四种类型     *         prototype 多实例，调用时加载     *         singleton 单实例spring容器初始化时加载（默认）     *         request 每一个请求创建一个实例（一般不使用，用request域代替）     *         session 每一个session创建一个实例 （与request一样）     * @return     */    @Bean(value = &quot;person&quot;)    @Scope(value = &quot;prototype&quot;)    public Person person01()&#123;        return new Person(&quot;lisi&quot;,20);    &#125;</code></pre><h1 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h1><p>在singleton时懒加载</p><h1 id="Configuration注解"><a href="#Configuration注解" class="headerlink" title="Configuration注解"></a>Configuration注解</h1><p>告诉spring这是个配置类</p><h1 id="component注解"><a href="#component注解" class="headerlink" title="component注解"></a>component注解</h1><pre><code>@ComponentScan(basePackages = &quot;com.xu&quot;,excludeFilters = &#123;        @ComponentScan.Filter(type = FilterType.CUSTOM,classes = MyTypeFilter.class)&#125;)//@ComponentScan(basePackages = &quot;com.xu&quot;,includeFilters = &#123;//        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = Service.class)//&#125;,useDefaultFilters = false)public class MainConfig &#123;</code></pre><ol><li>component注解是可重复注解</li><li>excludeFilters排除包是一个数组类型</li></ol><h2 id="ComponentScan-Filter"><a href="#ComponentScan-Filter" class="headerlink" title="@ComponentScan.Filter"></a>@ComponentScan.Filter</h2><p>​    排除包的类型或者包含包类型(包含时需要设置<code>useDefaultFilters = false</code>默认扫描包下所有类为false)</p><p>​        FilterType.ANNOTATION 根据注解类型排除</p><p>​        FilterType.ASSIGNABLE_TYPE 根据类类型排除</p><p>​        FilterType.ASPECTJ 根据aspectj规则排除</p><p>​        FilterType.REGEX 根据正则表达式排除</p><p>​        FilterType.CUSTOM 自定义规则</p><h2 id="FilterType-CUSTOM"><a href="#FilterType-CUSTOM" class="headerlink" title="FilterType.CUSTOM"></a>FilterType.CUSTOM</h2><p>需要写一个实现类,实现TypeFilter</p><pre><code>public class MyTypeFilter implements TypeFilter &#123;    /**     *     * @param metadataReader 读取当前正在扫描的类信息     * @param metadataReaderFactory 可以获取其他任何类信息     * @return     * @throws IOException     */    @Override    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;        //获取当前类的注解信息        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();        //获取当前类信息        ClassMetadata classMetadata = metadataReader.getClassMetadata();        //获取当前类的资源（当前类路径）        Resource resource = metadataReader.getResource();        String className = classMetadata.getClassName();        System.out.println(&quot;-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + className);        System.out.println(resource.contentLength());        if (className.contains(&quot;er&quot;))&#123;            return true;//返回true表示匹配成功        &#125;        return false;    &#125;&#125;</code></pre><h1 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h1><ol><li>直接写上Class类</li><li>ImportSelector的实现类返回对象全类名的数组</li><li>ImportBeanDefinitionRegistrar的实现类直接在方法中创建类对象<code>registry.registerBeanDefinition()</code>方法</li></ol><p>在类上</p><pre><code>@Import(&#123;Color.class,MyImportSelector.class,MyImportBeanDefinitionRegistrar.class&#125;)//id是全类名</code></pre><p>MyImportSelector</p><pre><code>public class MyImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        //返回全类名数组        return new String[]&#123;&quot;com.xu.Red&quot;,&quot;com.xu.Blue&quot;&#125;;    &#125;&#125;</code></pre><p>MyImportBeanDefinitionRegistrar</p><pre><code>public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;    @Override    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;        //如果ioc容器中包含id为com.xu.Red和com.xu.Blue的对象就创建一个green bean        if(registry.containsBeanDefinition(&quot;com.xu.Red&quot;)&amp;&amp;registry.containsBeanDefinition(&quot;com.xu.Blue&quot;)) &#123;            RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Green.class);            registry.registerBeanDefinition(&quot;green&quot;, rootBeanDefinition);        &#125;    &#125;&#125;</code></pre><h1 id="Bean使用FactoryBean"><a href="#Bean使用FactoryBean" class="headerlink" title="@Bean使用FactoryBean"></a>@Bean使用FactoryBean</h1><p>返回工厂bean对象在ioc容器中使用id获取的实际上是被工厂创建的bean对象，但是要是获取的名字前加上&amp;就是获取工厂对象</p><pre><code>@Bean(&quot;personFactory&quot;)public PersonFactory personFactory()&#123;    return new PersonFactory();&#125;</code></pre><p>PersonFactory</p><pre><code>public class PersonFactory implements FactoryBean&lt;Person&gt; &#123;    /**     * 获取bean对象     * @return     * @throws Exception     */    @Override    public Person getObject() throws Exception &#123;        return new Person(&quot;wangwu&quot;,50);    &#125;    /**     * 获取bean对象类型     * @return     */    @Override    public Class&lt;?&gt; getObjectType() &#123;        return Person.class;    &#125;    /**     * 是否是单例 默认懒加载     * @return     */    @Override    public boolean isSingleton() &#123;        return true;    &#125;&#125;</code></pre><h1 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h1><p>被加载的bean对象根据条件匹配是否加载</p><p>例子:操作系统为windows是加载bill对象,为linux时加载linus对象</p><pre><code>    @Bean(&quot;linus&quot;)    @Conditional(LinuxCondition.class)    public Person person01()&#123;        return new Person(&quot;Linus&quot;,50);    &#125;    @Bean(&quot;bill&quot;)    @Conditional(MyCondition.class)    public Person person02()&#123;        return new Person(&quot;Bill&quot;,50);    &#125;</code></pre><p><code>os.name获取当前操作系统名字</code>,返回true匹配成功加载对象,false不加载</p><pre><code>public class MyCondition implements Condition &#123;    /**     *     * @param context 上下文对象，可以获取运行环境     * @param metadata     * @return     */    @Override    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;        Environment environment = context.getEnvironment();        String property = environment.getProperty(&quot;os.name&quot;);        if (property.toUpperCase().contains(&quot;WINDOWS&quot;))&#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>在<code>vm option</code>上加上<code>-Dos.name=linux</code>修改操作系统名字为linux</p><pre><code>public class LinuxCondition implements Condition &#123;    @Override    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;        Environment environment = context.getEnvironment();        String property = environment.getProperty(&quot;os.name&quot;);        if (property.toUpperCase().contains(&quot;LINUX&quot;))&#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>将<code>@conditional</code>注解放在类上所有bean注入时都会判断一下,要是不符合所有类都不加载,符合之后会在判断方法上面的<code>@conditional</code>注解假如有的话</p><h1 id="初始化返回和销毁方法的使用"><a href="#初始化返回和销毁方法的使用" class="headerlink" title="初始化返回和销毁方法的使用"></a>初始化返回和销毁方法的使用</h1><ol><li>在@Bean注解上加上initMethod和destroyMethod,该方法在该类中</li></ol><pre><code>@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)    public Car car()&#123;        return new Car();    &#125;</code></pre><ol start="2"><li>在类中实现InitializingBean和DisposableBean</li></ol><pre><code>public class Cat implements InitializingBean, DisposableBean &#123;    public  Cat()&#123;        System.out.println(&quot;Cat ... Constructor...&quot;);    &#125;    @Override    public void destroy() throws Exception &#123;        System.out.println(&quot;Cat ... destroy...&quot;);    &#125;    @Override    public void afterPropertiesSet() throws Exception &#123;        System.out.println(&quot;Cat ... afterPropertiesSet...&quot;);    &#125;&#125;</code></pre><ol start="3"><li>在方法上使用@PostConstruct和@PreDestroy注解表示是初始化方法和销毁方法</li></ol><pre><code>public class Dog &#123;    public Dog() &#123;        System.out.println(&quot;Dog ... Constructor ...&quot;);    &#125;    @PostConstruct    public void init()&#123;        System.out.println(&quot;Dog ... init ...&quot;);    &#125;    @PreDestroy    public void destroy()&#123;        System.out.println(&quot;Dog ... destroy ...&quot;);    &#125;&#125;</code></pre><h1 id="后置处理器"><a href="#后置处理器" class="headerlink" title="后置处理器"></a><font color="red">后置处理器</font></h1><p>实现BeanPostProcessor接口会为所有bean注入后置处理器,在springboot和spring中使用很多</p><pre><code>public class MyHandler implements BeanPostProcessor &#123;    /**     * 初始化方法之后调用     * @param bean     * @param beanName     * @return     * @throws BeansException     */    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;postProcessBeforeInitialization ......&quot;+beanName+&quot;&gt;&gt;&gt;&gt;&quot;+bean);        return bean;    &#125;    /**     * 初始化方法之后调用     * @param bean     * @param beanName     * @return     * @throws BeansException     */    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;postProcessBeforeInitialization ......&quot;+beanName+&quot;&gt;&gt;&gt;&gt;&quot;+bean);        return bean;    &#125;&#125;</code></pre><h1 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h1><p>在属性上注入值需要和<code>@PropertySource(value = &quot;classpath:/Person.properties&quot;)</code>配合使用</p><pre><code>    @Value(value = &quot;zhangsan&quot;)    private String name;    @Value(&quot;#&#123;20-5&#125;&quot;)    private Integer age;    @Value(&quot;$&#123;person.nickName&#125;&quot;)    private String nickName;</code></pre><h1 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h1><p>加载外部配置文件</p><h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><p><code>spring</code>的注解 先按照类型注入,要是找到两个及以上的对象就按照名字查找,名字默认是属性名,要是想指定名字需要@Qualifier(“bookDao”)指定按照名字bookDao查找对象</p><p>在没有@Qualifier的情况下有两个对象可以在一个对象上使用@Primary优先注入该对象</p><ul><li><p>@Autowired可以在属性,方法,构造器,参数上使用</p><p>方法比如在set方法上使用会自动注入</p><pre><code>    @Autowired    public void setCar(Car car) &#123;        this.car = car;    &#125;</code></pre><p>在构造器上使用</p><pre><code>    @Autowired//只有一个构造器可以省略@Autowired自动去ioc容器找Car对象    public Boss( Car car) &#123;        this.car = car;    &#125;</code></pre><p>在参数上使用</p><pre><code>    public Boss(@Autowired Car car) &#123;        this.car = car;    &#125;</code></pre><p>在@Bean注解的参数上使用时可以省略自动去ioc容器中查找对象注入</p><pre><code>    @Bean(&quot;boss2&quot;)    public Boss boss(@Autowired Car car)&#123;        Boss boss = new Boss();        boss.setCar(car);        return boss;    &#125;</code></pre><h1 id="Rsource"><a href="#Rsource" class="headerlink" title="@Rsource"></a>@Rsource</h1><p>该注解是JSR250规范的注解,不支持@Primary,默认按照属性名字查找对象可以在注解后面加上指定名字</p><pre><code>@Resource(name = &quot;bookDao1&quot;)//是java250规范中的不支持spring的@Primary</code></pre><h1 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h1><p>该注解是JSR330规范的注解,支持spring的@Primary与@Autowired的区别就是不支持required,使用需要导入jar包</p><pre class=" language-xml"><code class="language-xml"> <span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/javax.inject/javax.inject --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax.inject<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javax.inject<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h1 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h1><p>aware接口实现了很多子接口可以注入一些属性进入对象中</p><ol><li>ApplicationContextAware:该接口会注入ioc容器的对象ApplicationContext</li><li>EmbeddedValueResolverAware:该接口会注入一个字符串解析器</li><li>EnvironmentAware:该接口会注入一个获取环境变量的对象Environment</li><li>等等</li></ol><pre><code>public class Car implements ApplicationContextAware, EmbeddedValueResolverAware, EnvironmentAware &#123;    private ApplicationContext applicationContext;    public Car()&#123;        System.out.println(&quot;Car Constructor ...&quot;);    &#125;    public void init()&#123;        System.out.println(&quot;Car ... init ...&quot;);    &#125;    public void destroy()&#123;        System.out.println(&quot;Car ... destroy...&quot;);    &#125;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;        this.applicationContext = applicationContext;    &#125;    @Override    public void setEmbeddedValueResolver(StringValueResolver resolver) &#123;        String value = resolver.resolveStringValue(&quot;你好#&#123;20*55&#125; 我是$&#123;os.name&#125; &quot;);//解析成你好1100 我是Windows 10        System.out.println(value);    &#125;    @Override    public void setEnvironment(Environment environment) &#123;        String property = environment.getProperty(&quot;os.name&quot;);//Windows 10        System.out.println(property);    &#125;&#125;</code></pre><p>这些接口对应了一个ApplicationContextAwareProcessor的后置处理器,该后置处理器在初始化前将属性回调注入类中</p><pre><code>private void invokeAwareInterfaces(Object bean) &#123;        if (bean instanceof Aware) &#123;            if (bean instanceof EnvironmentAware) &#123;                ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());            &#125;            if (bean instanceof EmbeddedValueResolverAware) &#123;                ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);            &#125;            if (bean instanceof ResourceLoaderAware) &#123;                ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);            &#125;            if (bean instanceof ApplicationEventPublisherAware) &#123;                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);            &#125;            if (bean instanceof MessageSourceAware) &#123;                ((MessageSourceAware) bean).setMessageSource(this.applicationContext);            &#125;            if (bean instanceof ApplicationContextAware) &#123;                ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);            &#125;        &#125;    &#125;</code></pre></li></ul><h1 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h1><p>该注解会在指定的环境下加载对应的一些对象bean比如需要配置多个数据源在test,dev和proc环境下分别加载不同的数据源,在方法上该方法根据环境加载,要是在类上就是该配置类根据环境加载</p><pre><code>@Configuration@PropertySource(value = &quot;classpath:/db.properties&quot;)public class MainConfigOfDataSource implements EmbeddedValueResolverAware &#123;    @Value(&quot;$&#123;db.username&#125;&quot;)    private String username;    private String drive;    //或者使用EnvironmentAware也行    @Profile(&quot;test&quot;)    @Bean    public DataSource dataSourceTest(@Value(&quot;$&#123;db.password&#125;&quot;) String pwd)&#123;        DruidDataSource dataSource = new DruidDataSource();        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/order&quot;);        dataSource.setPassword(pwd);        dataSource.setUsername(username);        dataSource.setDriverClassName(drive);        return dataSource;    &#125;    @Profile(&quot;dev&quot;)    @Bean    public DataSource dataSourceDev(@Value(&quot;$&#123;db.password&#125;&quot;) String pwd)&#123;        DruidDataSource dataSource = new DruidDataSource();        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/springtest&quot;);        dataSource.setPassword(pwd);        dataSource.setUsername(username);        dataSource.setDriverClassName(drive);        return dataSource;    &#125;    @Profile(&quot;prod&quot;)    @Bean    public DataSource dataSourceProd(@Value(&quot;$&#123;db.password&#125;&quot;) String pwd)&#123;        DruidDataSource dataSource = new DruidDataSource();        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/book&quot;);        dataSource.setPassword(pwd);        dataSource.setUsername(username);        dataSource.setDriverClassName(drive);        return dataSource;    &#125;    @Override    public void setEmbeddedValueResolver(StringValueResolver resolver) &#123;        String drive = resolver.resolveStringValue(&quot;$&#123;db.Drive&#125;&quot;);        this.drive = drive;    &#125;&#125;</code></pre><p>设置配置环境<code>-Dspring.profiles.active=test</code>或者</p><p>使用无惨构造器初始化ioc容器对象在设置环境变量之后注册配置类，在启动ioc容器，不能使用有参构造器因为有参构造器中直接启动了ioc容器，在配置环境变量没有用了</p><pre><code>AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();applicationContext.getEnvironment().setActiveProfiles(&quot;dev&quot;,&quot;test&quot;);applicationContext.register(MainConfigOfDataSource.class);applicationContext.refresh();</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring注解IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis复习</title>
      <link href="2020/11/21/mybatis-fu-xi/"/>
      <url>2020/11/21/mybatis-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="mybatis配置"><a href="#mybatis配置" class="headerlink" title="mybatis配置"></a>mybatis配置</h1><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 数据库连接环境的配置 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/mybatis_1129<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 引入SQL映射文件,Mapper映射文件     --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>EmployeeMapper.xml<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h1 id="mybatis创建sqlsession"><a href="#mybatis创建sqlsession" class="headerlink" title="mybatis创建sqlsession"></a>mybatis创建sqlsession</h1><pre><code>    @Test    public void test() throws Exception &#123;        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory =                     new SqlSessionFactoryBuilder().build(inputStream);        System.out.println(sqlSessionFactory);        SqlSession session  = sqlSessionFactory.openSession();        try &#123;            Employee employee =                     session.selectOne(&quot;suibian.selectEmployee&quot;, 1001);            System.out.println(employee);        &#125; finally &#123;            session.close();        &#125;    &#125;</code></pre><h2 id="获取mapper的代理对象"><a href="#获取mapper的代理对象" class="headerlink" title="获取mapper的代理对象"></a>获取mapper的代理对象</h2><pre><code>    @Test    public void test()  throws Exception&#123;        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream =                 Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory =                 new SqlSessionFactoryBuilder()              .build(inputStream);                SqlSession session =                          sqlSessionFactory.openSession();        try &#123;            //Mapper接口:获取Mapper接口的 代理实现类对象            EmployeeMapper mapper =                 session.getMapper(EmployeeMapper.class);                    Employee employee =                   mapper.getEmployeeById(1006);            System.out.println(employee);        &#125; finally &#123;            session.close();        &#125;    &#125;</code></pre><h1 id="MyBatis全局配置文件"><a href="#MyBatis全局配置文件" class="headerlink" title="MyBatis全局配置文件"></a>MyBatis全局配置文件</h1><ol><li>   The MyBatis configuration contains settings and properties that have a dramatic effect on how MyBatis behaves. </li></ol><p>MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。</p><ol start="2"><li><p>   文件结构如下:</p></li><li><p>configuration 配置 </p><ol><li><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">properties </a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">属性</a></li><li><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">settings </a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">设置</a></li><li><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">typeAliases</a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html"> </a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">类型命名</a></li><li><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">typeHandlers</a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html"> </a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">类型处理器</a></li><li><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">objectFactory</a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html"> </a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">对象工厂</a></li><li><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">plugins </a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">插件</a></li><li><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">environments </a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">环境</a><ol><li>environment 环境变量 <ol><li>transactionManager 事务管理器</li><li>dataSource 数据源</li></ol></li></ol></li><li><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">databaseIdProvider</a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html"> </a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">数据库厂商标识</a></li><li><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">mappers </a><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">映射器</a></li></ol></li></ol><h3 id="获取主键值"><a href="#获取主键值" class="headerlink" title="获取主键值"></a>获取主键值</h3><ol><li>   若数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），则可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上。</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertEmployee<span class="token punctuation">"</span></span>     <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.beans.Employee<span class="token punctuation">"</span></span>              <span class="token attr-name">databaseId</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span>            <span class="token attr-name">useGeneratedKeys</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>            <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into tbl_employee(last_name,email,gender) values(#<span class="token entity" title="&#123;">&amp;#123;</span>lastName<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>email<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>gender<span class="token entity" title="&#125;">&amp;#125;</span>)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></code></pre><ol start="2"><li>   而对于不支持自增型主键的数据库（例如 Oracle），则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertEmployee<span class="token punctuation">"</span></span>         <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.beans.Employee<span class="token punctuation">"</span></span>              <span class="token attr-name">databaseId</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>oracle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selectKey</span> <span class="token attr-name">order</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>BEFORE<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span>                                        <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>integer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            select employee_seq.nextval from dual         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selectKey</span><span class="token punctuation">></span></span>            insert into orcl_employee(id,last_name,email,gender) values(#<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>lastName<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>email<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>gender<span class="token entity" title="&#125;">&amp;#125;</span>)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></code></pre><p>或者</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertEmployee<span class="token punctuation">"</span></span>         <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.beans.Employee<span class="token punctuation">"</span></span>              <span class="token attr-name">databaseId</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>oracle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selectKey</span> <span class="token attr-name">order</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>AFTER<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span>                                          <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>integer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            select employee_seq.currval from dual         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selectKey</span><span class="token punctuation">></span></span>        insert into orcl_employee(id,last_name,email,gender) values(employee_seq.nextval,#<span class="token entity" title="&#123;">&amp;#123;</span>lastName<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>email<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>gender<span class="token entity" title="&#125;">&amp;#125;</span>)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></code></pre><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><ol><li>   单个普通类型参数</li></ol><p>​    可以接受基本类型，包装类型，字符串类型等。这种情况MyBatis可直接使用这个参数，不需要经过任何处理。</p><ol start="2"><li>   多个参数</li></ol><p>​    任意多个参数，都会被MyBatis重新包装成一个Map传入。Map的key是param1，param2，或者0，1…，值就是参数的值</p><ol start="3"><li>   命名参数</li></ol><p>​    为参数使用@Param起一个名字，MyBatis就会将这些参数封装进map中，key就是我们自己指定的名字</p><ol start="4"><li>   POJO</li></ol><p>​    当这些参数属于我们业务POJO时，我们直接传递POJO</p><ol start="5"><li>   Map</li></ol><p>​    我们也可以封装多个参数为map，直接传递</p><ol start="6"><li>   Collection/Array</li></ol><p>​    会被MyBatis封装成一个map传入, Collection对应的key是collection,Array对应的key是array. 如果确定是List集合，key还可以是list.</p><h1 id="resultType自动映射"><a href="#resultType自动映射" class="headerlink" title="resultType自动映射"></a>resultType自动映射</h1><ol><li><p>   autoMappingBehavior默认是PARTIAL，开启自动映射的功能。唯一的要求是结果集列名和javaBean属性名一致</p></li><li><p>   如果autoMappingBehavior设置为null则会取消自动映射</p></li><li><p>   数据库字段命名规范，POJO属性符合驼峰命名法，如A_COLUMN aColumn，我们可以开启自动驼峰命名规则映射功能，mapUnderscoreToCamelCase=true</p></li></ol><h1 id="resultMap自定义映射"><a href="#resultMap自定义映射" class="headerlink" title="resultMap自定义映射"></a>resultMap自定义映射</h1><ol><li><p>   自定义resultMap，实现高级结果集映射</p></li><li><p>   id ：用于完成主键值的映射</p></li><li><p>   result ：用于完成普通列的映射</p></li><li><p>   association ：一个复杂的类型关联;许多结果将包成这种类型</p></li><li><p>   collection ： 复杂类型的集合</p></li></ol><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>empMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.bean.Emp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--        id设置主键映射--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--        result设置其他属性映射--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ename<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ename<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--        设置关联关系 会使用反射创建javaType对象--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.bean.Dept<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dname<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dname<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getEmployeeAndDept<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myEmpAndDept<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>        SELECT e.id eid, e.last_name, e.email,e.gender ,d.id did, d.dept_name FROM tbl_employee e , tbl_dept d   WHERE e.d_id = d.id  AND e.id = #<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.beans.Employee<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myEmpAndDept<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>last_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 级联的方式 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept.id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept.departmentName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--分步--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>empMapStep<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.bean.Emp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ename<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ename<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--        通过column将部门id传入com.xu.mapper.DeptMapper.getDeptById ，查询出来的结果赋值给dept属性            分步查询的id select中             传入的column多个时使用map did为键 did的值为值  查询条件            fetchType="lazy" 懒加载 第二个sql在被调用时加载            fetchType="eager" 不懒加载--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.mapper.DeptMapper.getDeptById<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>&amp;#123;did<span class="token punctuation">=</span>did&amp;#125;<span class="token punctuation">"</span></span> <span class="token attr-name">fetchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>deptMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.bean.Dept<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dname<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dname<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--        collection:查询多对多和一对多的时候使用            ofType:集合中的数据类型--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emps<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.bean.Emp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ename<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ename<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--分步--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getDeptAndEmpsByIdStep<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myDeptAndEmpsStep<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         select id ,dept_name  from tbl_dept where id = #<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.beans.Department<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myDeptAndEmpsStep<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>departmentName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emps<span class="token punctuation">"</span></span>                  <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.dao.EmployeeMapper.getEmpsByDid<span class="token punctuation">"</span></span>                 <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--    分步查询一对多--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>deptMapStep<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.bean.Dept<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dname<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dname<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--        不用写映射，查询后的结果会自动赋值给属性emps--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emps<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.mapper.EmpDeptMapper.getEmpsById<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span></code></pre><h3 id="association-分步查询使用延迟加载"><a href="#association-分步查询使用延迟加载" class="headerlink" title="association 分步查询使用延迟加载"></a>association 分步查询使用延迟加载</h3><ol><li>   在分步查询的基础上，可以使用延迟加载来提升查询的效率，只需要在全局的Settings中进行如下的配置:</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 开启延迟加载 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazyLoadingEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 设置加载的数据是按需还是全部 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aggressiveLazyLoading<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><h2 id="分步查询多列值的传递"><a href="#分步查询多列值的传递" class="headerlink" title="分步查询多列值的传递"></a>分步查询多列值的传递</h2><ol><li><p>   如果分步查询时，需要传递给调用的查询中多个参数，则需要将多个参数封装成Map来进行传递，语法如下: {k1=v1, k2=v2….}</p></li><li><p>   在所调用的查询方，取值时就要参考Map的取值方式，需要严格的按照封装map时所用的key来取值. </p></li></ol><h2 id="association-或-collection的-fetchType属性"><a href="#association-或-collection的-fetchType属性" class="headerlink" title="association 或 collection的 fetchType属性"></a>association 或 collection的 fetchType属性</h2><ol><li><p>   在<code>&lt;association&gt;</code> 和<code>&lt;collection&gt;</code>标签中都可以设置fetchType，指定本次查询是否要使用延迟加载。默认为 fetchType=”lazy” ,如果本次的查询不想使用延迟加载，则可设置为fetchType=”eager”.</p></li><li><p>   fetchType可以灵活的设置查询是否需要使用延迟加载，而不需要因为某个查询不想使用延迟加载将全局的延迟加载设置关闭.</p></li></ol><h1 id="MyBatis-动态SQL"><a href="#MyBatis-动态SQL" class="headerlink" title="MyBatis 动态SQL"></a>MyBatis 动态SQL</h1><h2 id="if-where"><a href="#if-where" class="headerlink" title="if  where"></a>if  where</h2><p>​    1)    If用于完成简单的判断.</p><p>​    2)    Where用于解决SQL语句中where关键字以及条件中<font color="red">第一个and或者or的问题 </font>.</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getEmpByCondition<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.bean.Emp<span class="token punctuation">"</span></span> <span class="token attr-name">useCache</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from emp        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>trim</span> <span class="token attr-name">prefix</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>where<span class="token punctuation">"</span></span> <span class="token attr-name">prefixOverrides</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>and<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eid !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and eid = #<span class="token entity" title="&#123;">&amp;#123;</span>eid<span class="token entity" title="&#125;">&amp;#125;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ename !<span class="token punctuation">=</span> null and ename !<span class="token punctuation">=</span> <span class="token punctuation">'</span><span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and ename = #<span class="token entity" title="&#123;">&amp;#123;</span>ename<span class="token entity" title="&#125;">&amp;#125;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and age = #<span class="token entity" title="&#123;">&amp;#123;</span>age<span class="token entity" title="&#125;">&amp;#125;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex <span class="token punctuation">=</span><span class="token punctuation">=</span> 0 or sex <span class="token punctuation">=</span><span class="token punctuation">=</span> 1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and sex = #<span class="token entity" title="&#123;">&amp;#123;</span>sex<span class="token entity" title="&#125;">&amp;#125;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>trim</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>​    1)    Trim 可以在条件判断完的SQL语句前后 添加或者去掉指定的字符</p><p>​        prefix: 添加前缀</p><p>​        prefixOverrides: 去掉前缀</p><p>​        suffix: 添加后缀</p><p>​        suffixOverrides: 去掉后缀</p><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delete</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>deleteByList<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        delete from emp where        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>trim</span> <span class="token attr-name">suffixOverrides</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>or<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                eid =  #<span class="token entity" title="&#123;">&amp;#123;</span>eid<span class="token entity" title="&#125;">&amp;#125;</span> or            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>trim</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delete</span><span class="token punctuation">></span></span></code></pre><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>​    1)    set 主要是用于解决修改操作中SQL语句中可能多出逗号的问题</p><h2 id="choose-when、otherwise"><a href="#choose-when、otherwise" class="headerlink" title="choose(when、otherwise)"></a>choose(when、otherwise)</h2><p>​    1)    choose 主要是用于分支判断，类似于java中的switch case,<font color="red">只会满足所有分支中的一个</font></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getEmpsByConditionChoose<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.beans.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select id ,last_name, email,gender from tbl_employee        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>choose</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id!<span class="token punctuation">=</span>null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    id = #<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lastName!<span class="token punctuation">=</span>null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    last_name = #<span class="token entity" title="&#123;">&amp;#123;</span>lastName<span class="token entity" title="&#125;">&amp;#125;</span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email!<span class="token punctuation">=</span>null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    email = #<span class="token entity" title="&#123;">&amp;#123;</span>email<span class="token entity" title="&#125;">&amp;#125;</span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>otherwise</span><span class="token punctuation">></span></span>                     gender = 'm'                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>otherwise</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>choose</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>        </code></pre><h2 id="foreachforeach"><a href="#foreachforeach" class="headerlink" title="foreachforeach"></a>foreachforeach</h2><p>​    1)    foreach 主要用于循环迭代</p><p>​        collection: 要迭代的集合</p><p>​        item: 当前从集合中迭代出的元素</p><p>​        open: 开始字符</p><p>​        close:结束字符</p><p>​        separator: 元素与元素之间的分隔符</p><p>​        index:</p><p>​                 <font color="red">迭代的是List集合: index表示的当前元素的下标</font></p><p>​                <font color="red"> 迭代的Map集合: index表示的当前元素的key</font></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getEmpsByConditionForeach<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.beans.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         select id , last_name, email ,gender from tbl_employee where  id in          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ids<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>curr_id<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>                 #<span class="token entity" title="&#123;">&amp;#123;</span>curr_id<span class="token entity" title="&#125;">&amp;#125;</span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><ol><li><p>   sql 标签是用于抽取可重用的sql片段，将相同的，使用频繁的SQL片段抽取出来，单独定义，方便多次引用.</p></li><li><p>   抽取SQL:</p></li></ol><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectSQL<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select id , last_name, email ,gender from tbl_employee<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>   引用SQL:</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectSQL<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span></code></pre><h1 id="MyBatis-声明JdbcType-如-name-jdbcType-VARCHAR"><a href="#MyBatis-声明JdbcType-如-name-jdbcType-VARCHAR" class="headerlink" title="MyBatis 声明JdbcType. 如#{name,jdbcType=VARCHAR}"></a>MyBatis 声明JdbcType. 如#{name,jdbcType=VARCHAR}</h1><p> 在我们结合MyBatis框架使用时，发现如下问题，当SQL语句为insert或者update时，如果其变量含有null值，会报错：</p><p><font color="red">###Cause: java.sql.SQLException: JZ006: Caught IOException: java.io.IOException: JZ0SL: Unsupported SQL type xxx.</font></p><p>是由于MyBatis在进行操作的时，会指定jdbcType类型的参数，如果参数为null 其类型默认设置为jdbcType.OTHER，导致数据库无法识别此格式。</p><p>解决方法：给参数加上jdbcType可解决(注意大小写) 。</p><p>因为MyBatis在执行SQL时会自动通过对象中的属性来去给SQL中参数进行赋值，它会自动将Java类型转换成数据库的类型。如果一旦传入的是参数值是null 程序就无法准确判断这个类型应该是什么（是Integer？是VARCHAR?还是别的？），就有可能将类型转换错误，从而报错。</p><p>加入jdbcType正是为了解决这样的报错，需要针对这些可能为空的字段，手动指定其转换时用到的类型。</p><p>一般情况下，我们只需默认判定所有字段都可为空，即全部手动设置其转换类型即可，而无需去判断其每个字段是否可以为空。</p><p>同时还需在mybatis-config.xml文件中进行如下配置，添加settings配置；</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcTypeForNull<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>NULL<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span></code></pre><h1 id="MyBatis-缓存机制"><a href="#MyBatis-缓存机制" class="headerlink" title="MyBatis 缓存机制"></a>MyBatis 缓存机制</h1><ol><li><p>   MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升查询效率</p></li><li><p>   MyBatis系统中默认定义了两级缓存</p></li></ol><p>​            一级缓存</p><p>​            二级缓存</p><ol start="3"><li><p>   默认情况下，只有一级缓存（**<em>SqlSession**</em>级别的缓存，也称为本地缓存）开启。</p></li><li><p>   二级缓存需要手动开启和配置，他是基于**<em>namespace**</em>级别的缓存。</p></li><li><p>   为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</p></li></ol><h2 id="一级缓存的使用"><a href="#一级缓存的使用" class="headerlink" title="一级缓存的使用"></a>一级缓存的使用</h2><ol><li><p>   一级缓存(local cache), 即本地缓存, 作用域默认为sqlSession。当 Session flush 或 close 后, 该 Session 中的所有 Cache 将被清空。</p></li><li><p>   本地缓存不能被关闭, 但可以调用 clearCache() 来清空本地缓存, 或者改变缓存的作用域.</p></li><li><p>   在mybatis3.1之后, 可以配置本地缓存的作用域. 在 mybatis.xml 中配置</p></li></ol><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E7%BC%93%E5%AD%98.png" alt="缓存" title="缓存" style="zoom:150%;" /><ol start="4"><li>   一级缓存的工作机制</li></ol><p>​        同一次会话期间只要查询过的数据都会保存在当前SqlSession的一个Map中</p><p>​        key: hashCode+查询的SqlId+编写的sql查询语句+参数</p><h2 id="一级缓存失效的几种情况"><a href="#一级缓存失效的几种情况" class="headerlink" title="一级缓存失效的几种情况"></a>一级缓存失效的几种情况</h2><ol><li><p>   不同的SqlSession对应不同的一级缓存</p></li><li><p>   同一个SqlSession但是查询条件不同</p></li><li><p>   同一个SqlSession两次查询期间执行了任何一次增删改操作</p></li><li><p>   同一个SqlSession两次查询期间手动清空了缓存</p></li></ol><h2 id="二级缓存的使用"><a href="#二级缓存的使用" class="headerlink" title="二级缓存的使用"></a>二级缓存的使用</h2><ol><li><p>   二级缓存(second level cache)，全局作用域缓存</p></li><li><p>   二级缓存默认不开启，需要手动配置</p></li><li><p>   MyBatis提供二级缓存的接口以及实现，<font color="red">缓存实现要求POJO实现Serializable接口</font></p></li><li><p>   二级缓存在 SqlSession 关闭或提交之后才会生效</p></li><li><p>   二级缓存使用的步骤:</p></li></ol><p>​        ①  全局配置文件中开启二级缓存<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></p><p>​        ②  需要使用二级缓存的映射文件处使用cache配置缓存<code>&lt;cache /&gt;</code></p><p>​        ③  注意：POJO需要实现Serializable接口</p><ol start="6"><li>   二级缓存相关的属性</li></ol><p>​        ①  eviction=“FIFO”：缓存回收策略：</p><p>​                LRU – 最近最少使用的：移除最长时间不被使用的对象。</p><p>​                FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</p><p>​                SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</p><p>​                WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p><p>​                <font color="red">默认的是 LRU。</font></p><p>​        ②  flushInterval：刷新间隔，单位毫秒</p><p>​                默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</p><p>​        ③  size：引用数目，正整数</p><p>​                代表缓存最多可以存储多少个对象，太大容易导致内存溢出</p><p>​        ④  readOnly：只读，true/false</p><p>​                true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。</p><p>​                false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，<font color="red">因此默认是 false。</font></p><h2 id="缓存的相关属性设置"><a href="#缓存的相关属性设置" class="headerlink" title="缓存的相关属性设置"></a>缓存的相关属性设置</h2><ol><li>   全局setting的cacheEnable：</li></ol><p>​        配置二级缓存的开关，一级缓存一直是打开的。</p><ol start="2"><li>   select标签的useCache属性：</li></ol><p>​        配置这个select是否使用二级缓存。一级缓存一直是使用的</p><ol start="3"><li>   sql标签的flushCache属性：</li></ol><p>​        增删改默认flushCache=true。sql执行以后，会同时清空一级和二级缓存。</p><p>​        查询默认 flushCache=false。</p><ol start="4"><li>   sqlSession.clearCache()：只是用来清除一级缓存。</li></ol><h2 id="整合第三方缓存"><a href="#整合第三方缓存" class="headerlink" title="整合第三方缓存"></a>整合第三方缓存</h2><p>见复习资料</p><h1 id="MyBatis-逆向工程"><a href="#MyBatis-逆向工程" class="headerlink" title="MyBatis 逆向工程"></a>MyBatis 逆向工程</h1><h2 id="逆向工程简介"><a href="#逆向工程简介" class="headerlink" title="逆向工程简介"></a>逆向工程简介</h2><ol><li>   MyBatis Generator: 简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。但是表连接、存储过程等这些复杂sql的定义需要我们手工编写</li></ol><p><a href="http://www.mybatis.org/generator/" title="官方文档地址">官方文档地址</a></p><p><a href="https://github.com/mybatis/generator/releases" title="官方工程地址">官方工程地址</a></p><h2 id="逆向工程的配置"><a href="#逆向工程的配置" class="headerlink" title="逆向工程的配置"></a>逆向工程的配置</h2><ol><li>   导入逆向工程的jar包</li></ol><p>​        mybatis-generator-core-1.3.2.jar</p><ol start="2"><li>   编写MBG的配置文件（重要几处配置）,可参考官方手册</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype">&lt;!DOCTYPE generatorConfiguration  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generatorConfiguration</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--           targetRuntime: 执行生成的逆向工程的版本                  MyBatis3Simple: 生成基本的CRUD                  MyBatis3: 生成带条件的CRUD   --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DB2Tables<span class="token punctuation">"</span></span> <span class="token attr-name">targetRuntime</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyBatis3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdbcConnection</span> <span class="token attr-name">driverClass</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span>        <span class="token attr-name">connectionURL</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/mybatis_1129<span class="token punctuation">"</span></span>        <span class="token attr-name">userId</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span>        <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jdbcConnection</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- javaBean的生成策略--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaModelGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.beans<span class="token punctuation">"</span></span> <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.\src<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>trimStrings<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaModelGenerator</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- SQL映射文件的生成策略 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sqlMapGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.dao<span class="token punctuation">"</span></span>  <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.\conf<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sqlMapGenerator</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- Mapper接口的生成策略 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaClientGenerator</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>XMLMAPPER<span class="token punctuation">"</span></span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mybatis.dao<span class="token punctuation">"</span></span>  <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.\src<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaClientGenerator</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 逆向分析的表 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tbl_dept<span class="token punctuation">"</span></span> <span class="token attr-name">domainObjectName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Department<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tbl_employee<span class="token punctuation">"</span></span> <span class="token attr-name">domainObjectName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generatorConfiguration</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>   运行代码生成器生成代码</li></ol><pre><code>@Testpublic void testMBG() throws Exception &#123;           List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();           boolean overwrite = true;           File configFile = new File(&quot;mbg.xml&quot;);           ConfigurationParser cp = new ConfigurationParser(warnings);           Configuration config = cp.parseConfiguration(configFile);           DefaultShellCallback callback = new DefaultShellCallback(overwrite);           MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,            callback, warnings);           myBatisGenerator.generate(null);&#125;</code></pre><h1 id="扩展-PageHelper分页插件"><a href="#扩展-PageHelper分页插件" class="headerlink" title="扩展-PageHelper分页插件"></a>扩展-PageHelper分页插件</h1><h2 id="PageHelper-分页插件简介"><a href="#PageHelper-分页插件简介" class="headerlink" title="PageHelper 分页插件简介"></a>PageHelper 分页插件简介</h2><ol><li><p>   PageHelper是MyBatis中非常方便的第三方分页插件</p></li><li><p>   <a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md" title="官方文档">官方文档</a></p></li><li><p>   我们可以对照官方文档的说明，快速的使用插件</p></li></ol><h2 id="PageHelper的使用步骤"><a href="#PageHelper的使用步骤" class="headerlink" title="PageHelper的使用步骤"></a>PageHelper的使用步骤</h2><ol><li><p>   导入相关包pagehelper-x.x.x.jar 和 jsqlparser-0.9.5.jar</p></li><li><p>   在MyBatis全局配置文件中配置分页插件</p></li></ol><pre class=" language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>                 &lt;plugin interceptor=*"com.github.pagehelper.PageInterceptor">          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>  </code></pre><ol start="3"><li><p>   使用PageHelper提供的方法进行分页</p></li><li><p>   可以使用更强大的PageInfo封装返回结果</p></li></ol><h2 id="Page对象的使用"><a href="#Page对象的使用" class="headerlink" title="Page对象的使用"></a>Page对象的使用</h2><ol><li>   在查询之前通过PageHelper.startPage(页码，条数)设置分页信息，该方法返回Page对象(通过ThreadLocal将数据与线程绑定之后该线程查询的数据都会加上分页)</li></ol><pre><code>    @Test    public void testPageHelper()  throws Exception&#123;        SqlSessionFactory ssf = getSqlSessionFactory();        SqlSession session = ssf.openSession();        try &#123;            EmployeeMapper mapper =                       session.getMapper(EmployeeMapper.class);            //设置分页信息            Page&lt;Object&gt; page = PageHelper.startPage(9, 1);            List&lt;Employee&gt; emps = mapper.getAllEmps();            for (Employee employee : emps) &#123;                System.out.println(employee);            &#125;            System.out.println(&quot;=============获取分页相关的信息=================&quot;);            System.out.println(&quot;当前页: &quot; + page.getPageNum());            System.out.println(&quot;总页码: &quot; + page.getPages());            System.out.println(&quot;总条数: &quot; + page.getTotal());            System.out.println(&quot;每页显示的条数: &quot; + page.getPageSize());        &#125; finally &#123;            session.close();        &#125;    &#125;</code></pre><h2 id="PageInfo对象的使用"><a href="#PageInfo对象的使用" class="headerlink" title="PageInfo对象的使用"></a>PageInfo对象的使用</h2><ol><li>   在查询完数据后，使用PageInfo对象封装查询结果，可以获取更详细的分页信息以及</li></ol><p>可以完成分页逻辑</p><pre><code>    @Test    public void testPageHelper1()  throws Exception&#123;        SqlSessionFactory ssf = getSqlSessionFactory();        SqlSession session = ssf.openSession();        try &#123;            EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);            //设置分页信息            Page&lt;Object&gt; page = PageHelper.startPage(9, 1);            List&lt;Employee&gt; emps = mapper.getAllEmps();            //             PageInfo&lt;Employee&gt; info  = new PageInfo&lt;&gt;(emps,5);            for (Employee employee : emps) &#123;                System.out.println(employee);            &#125;            System.out.println(&quot;=============获取详细分页相关的信息=================&quot;);            System.out.println(&quot;当前页: &quot; + info.getPageNum());            System.out.println(&quot;总页码: &quot; + info.getPages());            System.out.println(&quot;总条数: &quot; + info.getTotal());            System.out.println(&quot;每页显示的条数: &quot; + info.getPageSize());            System.out.println(&quot;是否是第一页: &quot; + info.isIsFirstPage());            System.out.println(&quot;是否是最后一页: &quot; + info.isIsLastPage());            System.out.println(&quot;是否有上一页: &quot; + info.isHasPreviousPage());            System.out.println(&quot;是否有下一页: &quot; + info.isHasNextPage());            System.out.println(&quot;============分页逻辑===============&quot;);            int [] nums = info.getNavigatepageNums();            for (int i : nums) &#123;                System.out.print(i +&quot; &quot; );            &#125;        &#125; finally &#123;            session.close();        &#125;    &#125;</code></pre><h1 id="SSM框架整合"><a href="#SSM框架整合" class="headerlink" title="SSM框架整合"></a>SSM框架整合</h1><p>见复习资料</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springmvc复习</title>
      <link href="2020/11/20/springmvc-fu-xi/"/>
      <url>2020/11/20/springmvc-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="springmvc常用组件"><a href="#springmvc常用组件" class="headerlink" title="springmvc常用组件"></a>springmvc常用组件</h1><ol><li><strong>DispatcherServlet</strong>：前端控制器</li><li> <strong>Controller</strong>：处理器/页面控制器，做的是MVC中的C的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理</li><li>  <strong>HandlerMapping</strong> ：请求映射到处理器，找谁来处理，如果映射成功返回一个HandlerExecutionChain对象（包含一个Handler处理器(页面控制器)对象、多个<strong>HandlerInterceptor</strong>拦截器对象）</li><li><strong>View Resolver</strong> : 视图解析器，找谁来处理返回的页面。把逻辑视图解析为具体的View,进行这种策略模式，很容易更换其他视图技术；<ul><li>n 如InternalResourceViewResolver将逻辑视图名映射为JSP视图</li></ul></li><li>  <strong>LocalResolver</strong>：本地化、国际化</li><li> <strong>MultipartResolver</strong>：文件上传解析器</li><li> <strong>HandlerExceptionResolver</strong>：异常处理器</li></ol><p>新建Web工程，加入 jar 包</p><pre><code>spring-aop-4.0.0.RELEASE.jarspring-beans-4.0.0.RELEASE.jarspring-context-4.0.0.RELEASE.jarspring-core-4.0.0.RELEASE.jarspring-expression-4.0.0.RELEASE.jarcommons-logging-1.1.3.jarspring-web-4.0.0.RELEASE.jarspring-webmvc-4.0.0.RELEASE.jar</code></pre><p>在 web.xml 中配置 DispatcherServlet</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置SpringMVC核心控制器： --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springDispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 配置DispatcherServlet的初始化參數：设置文件的路径和文件名称 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:springmvc.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springDispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span></code></pre><p>①  解释配置文件的名称定义规则:</p><p>实际上也可以不通过 contextConfigLocation 来配置 SpringMVC 的配置文件, 而使用默认的.</p><p>默认的配置文件为: <code>/WEB-INF/&lt;servlet-name&gt;-servlet.xml</code></p><p>xml配置</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 设置扫描组件的包： --></span>`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.springmvc<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 配置映射解析器：如何将控制器返回的结果字符串，转换为一个物理的视图文件--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>internalResourceViewResolver<span class="token punctuation">"</span></span>   <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/WEB-INF/views/<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.jsp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h1 id="映射请求参数、请求方法或请求头"><a href="#映射请求参数、请求方法或请求头" class="headerlink" title="映射请求参数、请求方法或请求头"></a>映射请求参数、请求方法或请求头</h1><p>1）@RequestMapping 除了可以使用请求 URL 映射请求外，还可以使用请求方法、请求参数及请求头映射请求</p><p>2）@RequestMapping 的 value【重点】、method【重点】、params【了解】 及 heads【了解】 分别表示请求 URL、请求方法、请    求参数及请求头的映射条件，**<em>他们之间是与的关系，联合使用多个条件可让请求映射更加精确化。**</em></p><p>3）params 和 headers支持简单的表达式：</p><p>​    param1: 表示请求必须包含名为 param1 的请求参数</p><p>​    !param1: 表示请求不能包含名为 param1 的请求参数</p><p>​    param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1</p><p>​    {“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2 的两个请求参数，且 param1 参数的值必须为 value1</p><p><code>@RequestMapping(value=&quot;/testParamsAndHeaders&quot;,params= &#123;&quot;username&quot;,&quot;age!=10&quot;&#125;,headers = &#123; &quot;Accept-Language=en-US,zh;q=0.8&quot; &#125;)</code></p><h1 id="RequestMapping支持Ant-路径风格"><a href="#RequestMapping支持Ant-路径风格" class="headerlink" title="RequestMapping支持Ant 路径风格"></a>RequestMapping支持Ant 路径风格</h1><p><strong>1）</strong>  <strong>Ant</strong> <strong>风格资源地址支持</strong> <strong>3</strong> <strong>种匹配符</strong>：【了解】</p><p>​        <code>?：匹配文件名中的一个字符</code></p><p>​        <code>*：匹配文件名中的任意字符</code></p><p>​        <code>**： **匹配多层路径</code></p><p>2）  @RequestMapping 还<strong>支持</strong> <strong>Ant</strong> <strong>风格的</strong> <strong>URL</strong>：</p><pre><code>/user/*/createUser匹配 /user/aaa/createUser、/user/bbb/createUser 等 URL/user/**/createUser匹配 /user/createUser、/user/aaa/bbb/createUser 等 URL/user/createUser??匹配 /user/createUseraa、/user/createUserbb 等 URL</code></pre><h1 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a>HiddenHttpMethodFilter</h1><p>​        浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将这些请求转换为标准的 http 方法，使得支持 GET、POST、PUT 与 DELETE 请求。</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 支持REST风格的过滤器：可以将POST请求转换为PUT或DELETE请求 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>HiddenHttpMethodFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>HiddenHttpMethodFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span></code></pre><p>​        如何发送PUT请求或DELETE请求?</p><p>​        ①.配置HiddenHttpMethodFilter</p><p>​        ②.需要发送POST请求</p><p>​        ③.需要在发送POST请求时携带一个 name=”_method”的隐含域，值为PUT或DELETE</p><p> GET查询,POST新增,PUT修改,DELETE删除</p><h1 id="请求处理方法签名"><a href="#请求处理方法签名" class="headerlink" title="请求处理方法签名"></a>请求处理方法签名</h1><p>1） Spring MVC 通过分析处理方法的签名(方法名+ 参数列表)，HTTP请 求信息绑定到处理方法的相应形参中。</p><p>2） Spring MVC 对控制器处理方法签名的限制是很宽松的，几乎可以按喜欢的任何方式对方法进行签名。 </p><p>3） 必要时可以对方法及方法入参标注相应的注解（ @PathVariable 、@RequestParam、@RequestHeader 等）、</p><p>4）  Spring MVC 框架会将 HTTP 请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理。</p><h2 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="@RequestParam注解"></a>@RequestParam注解</h2><p>1）在处理方法入参处使用 @RequestParam 可以把请求参数传递给请求方法</p><p>2）value：参数名</p><p>3）required：是否必须。默认为 true, 表示请求参数中必须包含对应的参数，若不存在，将抛出异常</p><p>4）defaultValue: 默认值，当没有传递参数时使用该值</p><pre><code>/** * @RequestParam 注解用于映射请求参数 *         value 用于映射请求参数名称 *         required 用于设置请求参数是否必须的 *         defaultValue 设置默认值，当没有传递参数时使用该值 */@RequestMapping(value=&quot;/testRequestParam&quot;)public String testRequestParam(@RequestParam(value=&quot;username&quot;) String username,                               @RequestParam(value=&quot;age&quot;,required=false,defaultValue=&quot;0&quot;) int age)&#123;    System.out.println(&quot;testRequestParam - username=&quot;+username +&quot;,age=&quot;+age);    return &quot;success&quot;;&#125;</code></pre><h2 id="RequestHeader-注解"><a href="#RequestHeader-注解" class="headerlink" title="@RequestHeader 注解"></a>@RequestHeader 注解</h2><p>1）  使用 @RequestHeader 绑定请求报头的属性值</p><p>2）  请求头包含了若干个属性，服务器可据此获知客户端的信息，<strong>通过 @RequestHeader即可将请求头中的属性值绑定到处理方法的入参中</strong> </p><pre><code>//了解: 映射请求头信息 用法同 @RequestParam@RequestMapping(value=&quot;/testRequestHeader&quot;)public String testRequestHeader(@RequestHeader(value=&quot;Accept-Language&quot;) String al)&#123;    System.out.println(&quot;testRequestHeader - Accept-Language：&quot;+al);    return &quot;success&quot;;&#125;&lt;!-- 测试 请求头@RequestHeader 注解使用 --&gt;&lt;a href=&quot;springmvc/testRequestHeader&quot;&gt;testRequestHeader&lt;/a&gt;</code></pre><h2 id="CookieValue-注解"><a href="#CookieValue-注解" class="headerlink" title="@CookieValue 注解"></a>@CookieValue 注解</h2><p>1）  使用 @CookieValue 绑定请求中的 Cookie 值</p><p>2）  <strong>@CookieValue</strong> 可让处理方法入参绑定某个 Cookie 值</p><pre><code>//了解:@CookieValue: 映射一个 Cookie 值. 属性同 @RequestParam@RequestMapping(&quot;/testCookieValue&quot;)public String testCookieValue(@CookieValue(&quot;JSESSIONID&quot;) String sessionId) &#123;    System.out.println(&quot;testCookieValue: sessionId: &quot; + sessionId);    return &quot;success&quot;;&#125;</code></pre><h2 id="使用POJO作为参数"><a href="#使用POJO作为参数" class="headerlink" title="使用POJO作为参数"></a>使用POJO作为参数</h2><p>1）  使用 POJO 对象绑定请求参数值</p><p>2）  Spring MVC <strong>会按请求参数名和 POJO</strong> <strong>属性名进行自动匹配，自动为该对象填充属性值</strong>。<strong>支持级联属性</strong>。如：dept.deptId、dept.address.tel 等</p><pre><code>/** * Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配， 自动为该对象填充属性值。 * 支持级联属性 *                 如：dept.deptId、dept.address.tel 等 */@RequestMapping(&quot;/testPOJO&quot;)public String testPojo(User user) &#123;    System.out.println(&quot;testPojo: &quot; + user);    return &quot;success&quot;;&#125;</code></pre><h2 id="Serlvet-原生的-API-作为目标方法的参数"><a href="#Serlvet-原生的-API-作为目标方法的参数" class="headerlink" title="Serlvet 原生的 API 作为目标方法的参数"></a>Serlvet 原生的 API 作为目标方法的参数</h2><p>可以使用 Serlvet 原生的 API 作为目标方法的参数 具体支持以下类型</p><ol><li>HttpServletRequest <ul><li>HttpServletResponse </li><li>HttpSession</li><li>java.security.Principal </li><li>Locale InputStream </li><li>OutputStream </li><li>Reader </li><li>Writer</li></ul></li></ol><pre><code>@RequestMapping(&quot;/testServletAPI&quot;)public void testServletAPI(HttpServletRequest request,HttpServletResponse response, Writer out) throws IOException &#123;    System.out.println(&quot;testServletAPI, &quot; + request + &quot;, &quot; + response);    out.write(&quot;hello springmvc&quot;);    //return &quot;success&quot;;&#125;</code></pre><h2 id="SpringMVC-输出模型数据概述"><a href="#SpringMVC-输出模型数据概述" class="headerlink" title="SpringMVC 输出模型数据概述"></a>SpringMVC 输出模型数据概述</h2><p>1）  <strong>ModelAndView</strong>: 处理方法返回值类型为 ModelAndView 时, 方法体即可通过该对象添加模型数据 </p><p>2）  <strong>Map</strong> <strong>或 Model</strong>: 入参为 org.springframework.ui.Model、org.springframework.ui.ModelMap 或 java.util.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中。</p><h2 id="处理模型数据之-ModelAndView"><a href="#处理模型数据之-ModelAndView" class="headerlink" title="处理模型数据之 ModelAndView"></a>处理模型数据之 ModelAndView</h2><p>​    控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息。</p><p>1） 两个重要的成员变量:</p><p>private Object view;   视图信息</p><p>private ModelMap model; 模型数据</p><p>3）添加模型数据:</p><p>MoelAndView addObject(String attributeName, Object attributeValue)  设置模型数据ModelAndView addAllObject(Map&lt;String, ?&gt; modelMap)</p><p>4）设置视图:</p><p>void setView(View view)         设置视图对象</p><p>void setViewName(String viewName)   设置视图名字</p><p>5）获取模型数据</p><p>   protected Map&lt;String, Object&gt; getModelInternal()  获取模型数据</p><p>   public ModelMap getModelMap()</p><p>   public Map&lt;String, Object&gt; getModel()</p><h2 id="视图解析"><a href="#视图解析" class="headerlink" title="视图解析"></a>视图解析</h2><p>不论控制器返回一个String,ModelAndView,View都会转换为ModelAndView对象，由视图解析器解析视图，然后，进行页面的跳转。  </p><p>1）  请求处理方法执行完成后，最终返回一个 ModelAndView 对象。对于那些返回 String，View 或 ModeMap 等类型的处理方法，<strong>Spring MVC</strong> <strong>也会在内部将它们装配成一个 ModelAndView</strong> <strong>对象</strong>，它包含了逻辑名和模型对象的视图</p><p>2）  Spring MVC 借助<strong>视图解析器</strong>（<strong>ViewResolver</strong>）得到最终的视图对象（View），最终的视图可以是 JSP ，也可能是 Excel、JFreeChart等各种表现形式的视图</p><p>3）  对于最终究竟采取何种视图对象对模型数据进行渲染，处理器并不关心，处理器工作重点聚焦在生产模型数据的工作上，从而实现 MVC 的充分解耦</p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8.png" alt="视图解析器" title="视图解析器"></p><p>1）  若项目中使用了JSTL，则SpringMVC 会自动把视图由InternalResourceView转为 <strong>JstlView</strong> <strong>（断点调试，将JSTL的jar包增加到项目中，视图解析器会自动修改为JstlView）</strong></p><p>2）  若使用 JSTL 的 fmt 标签则需要在 SpringMVC 的配置文件中<strong>配置国际化资源文件</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>messageSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.context.support.ResourceBundleMessageSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>basename<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i18n<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li> <strong><em>若希望直接响应通过 SpringMVC 渲染的页面，可以使用 mvc:view-controller 标签实现</em></strong></li></ol><p><code>&lt;mvc:view-controller path=&quot;springmvc/testJstlView&quot; view-name=&quot;success&quot;&gt;</code></p><p><code>配置&lt;mvc:view-controller&gt;会导致其他请求路径失效</code></p><p>解决:</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 在实际开发过程中都需要配置mvc:annotation-driven标签，后面讲，这里先配置上 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">/></span></span></code></pre><h1 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h1><p>如果中文有乱码，需要配置字符编码过滤器，且配置其他过滤器之前，如（HiddenHttpMethodFilter），否则不起作用。（思考method=”get”请求的乱码问题怎么解决的）</p><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!-- 配置字符集 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>encodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>org.springframework.web.filter.CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>forceEncoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>encodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span></code></pre><h1 id="加入jQuery库文件"><a href="#加入jQuery库文件" class="headerlink" title="加入jQuery库文件"></a>加入jQuery库文件</h1><ol><li><p> /scripts/jquery-1.9.1.min.js</p></li><li><p> jQuery库文件不起作用</p></li></ol><p>3）  解决办法，SpringMVC 处理静态资源</p><p>​    ① 为什么会有这样的问题:</p><p>​    优雅的 REST 风格的资源URL 不希望带 .html 或 .do 等后缀，若将 DispatcherServlet 请求映射配置为 /, 则 Spring MVC 将捕获 WEB 容器的所有请求, 包括静态资源的请求, SpringMVC 会将他们当成一个普通请求处理, 因找不到对应处理器将导致错误。</p><p>​    ②解决: 在 SpringMVC 的配置文件中配置 <code>&lt;mvc:default-servlet-handler/&gt;</code></p><p>4）  配置后，原来的请求又不好使了</p><p>​         需要配置<code>&lt;mvc:annotation-driven /&gt;</code></p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- &lt;mvc:default-servlet-handler/> 将在 SpringMVC 上下文中定义一个 DefaultServletHttpRequestHandler，它会对进入 DispatcherServlet 的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由 WEB 应用服务器默认的 Servlet 处理，如果不是静态资源的请求，才由 DispatcherServlet 继续处理一般 WEB 应用服务器默认的 Servlet 的名称都是 default。若所使用的 WEB 服务器的默认 Servlet 名称不是 default，则需要通过 default-servlet-name 属性显式指定        参考：CATALINA_HOME/config/web.xml    &lt;servlet>        &lt;servlet-name>default&lt;/servlet-name>        &lt;servlet-class>org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class>        &lt;init-param>            &lt;param-name>debug&lt;/param-name>            &lt;param-value>0&lt;/param-value>        &lt;/init-param>        &lt;init-param>            &lt;param-name>listings&lt;/param-name>            &lt;param-value>false&lt;/param-value>        &lt;/init-param>        &lt;load-on-startup>1&lt;/load-on-startup>    &lt;/servlet>该标签属性default-servlet-name默认值是"default",可以省略。        &lt;mvc:default-servlet-handler/>         --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>default-servlet-handler</span> <span class="token attr-name">default-servlet-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>default<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>springmvc默认需要jackson来自动将数据转换为string和解析为json（需要导入jar包）</p><pre><code>jackson-annotations-2.1.5.jarjackson-core-2.1.5.jarjackson-databind-2.1.5.jar</code></pre><p>其他json的jar包还有Gson,fastJson,Jsonlib</p><h1 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h1><p>1）  <strong>使用</strong> <strong>HttpMessageConverter<T></strong> <strong>将请求信息转化并绑定到处理方法的入参中或将响应结果转为对应类型的响应信息，</strong>Spring <strong>提供了两种途径</strong>：</p><ul><li><p>使用 <strong>@RequestBody / @ResponseBody</strong> 对处理方法进行标注</p></li><li><p>使用 <strong>HttpEntity<T> / ResponseEntity<T></strong> 作为处理方法的入参或返回值</p></li></ul><p>2）  当控制器处理方法使用到 @RequestBody/@ResponseBody 或</p><p> HttpEntity<T>/ResponseEntity<T> 时, Spring <strong>首先根据请求头或响应头的</strong> <strong>Accept</strong> <strong>属性选择匹配的</strong> <strong>HttpMessageConverter</strong>, <strong>进而根据参数类型或泛型类型的过滤得到匹配的</strong> <strong>HttpMessageConverter</strong>, 若找不到可用的 HttpMessageConverter 将报错</p><p>3）  <strong>@RequestBody</strong> <strong>和</strong> <strong>@ResponseBody</strong> <strong>不需要成对出现</strong></p><p>4）  Content-Disposition：attachment; filename=abc.pdf</p><p><strong><em>注意</em></strong>:当请求参数格式为key=value&amp;key=value时可以不用加@RequestBody注解注解写类就会注入参数,但是要是请求参数是json格式的就要写上@RequestBody注解不然参数注入失败.</p><ol><li>ResponseEntity的优先级高于@ResponseBody。在不是ResponseEntity的情况下才去检查有没有@ResponseBody注解。如果响应类型是ResponseEntity可以不写@ResponseBody注解，写了也没有关系。 </li><li>ResponseEntity 是在 org.springframework.http.HttpEntity 的基础上添加了http status code(http状态码)，用于RestTemplate以及@Controller的HandlerMethod。它在Controoler中或者用于服务端响应时，作用是和@ResponseStatus与@ResponseBody结合起来的功能一样的。用于RestTemplate时，它是接收服务端返回的http status code 和 reason的。 </li><li>总结： 简单粗暴的讲 @ResponseBody可以直接返回Json结果， <strong><em>@ResponseEntity不仅可以返回json结果，还可以定义返回的HttpHeaders和HttpStatus</em></strong></li></ol><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="自定义拦截器概述"><a href="#自定义拦截器概述" class="headerlink" title="自定义拦截器概述"></a>自定义拦截器概述</h2><p>Spring MVC也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，<strong>自定义的拦截器可以实现HandlerInterceptor接口，也可以继承HandlerInterceptorAdapter适配器类</strong></p><ol><li><p><strong>preHandle</strong>()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求 request 进行处理。<strong>如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true；如果程序员决定不需要再调用其他的组件去处理请求，则返回false。</strong></p></li><li><p> <strong>postHandle</strong>()：<strong>这个方法在业务处理器处理完请求后，但是DispatcherServlet向客户端返回响应前被调用</strong>，在该方法中对用户请求request进行处理。</p></li><li><p><strong>afterCompletion</strong>()：这个方法<strong>在</strong> <strong>DispatcherServlet</strong> <strong>完全处理完请求后被调用</strong>，可以在该方法中进行一些资源清理的操作。</p></li></ol><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--        第一种 默认拦截所有请求--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.interceptor.FirstInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xu.interceptor.SecondInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--        第二种 @Component配置--></span><span class="token comment" spellcheck="true">&lt;!--        &lt;ref bean="firstInterceptor">&lt;/ref>--></span><span class="token comment" spellcheck="true">&lt;!--        自定义拦截请求--></span><span class="token comment" spellcheck="true">&lt;!--        &lt;mvc:interceptor>--></span><span class="token comment" spellcheck="true">&lt;!--            &lt;bean  class="com.xu.interceptor.FirstInterceptor">&lt;/bean>--></span><span class="token comment" spellcheck="true">&lt;!--            &lt;mvc:mapping path="com.xu.controller"/>--></span><span class="token comment" spellcheck="true">&lt;!--            &lt;mvc:exclude-mapping path="com.xu.pojo"/>--></span><span class="token comment" spellcheck="true">&lt;!--        &lt;/mvc:interceptor>--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">></span></span></code></pre><p>代码示例:</p><pre><code>/** * * 多个拦截器执行顺序 * First:preHandle * Second:preHandle * * Second:postHandle * First:postHandle * * Second:afterCompletion * First:afterCompletion * * * 两个拦截器都是false * 执行 First:preHandle * * 第一个拦截器true 第二个拦截器 false * 执行顺序 * First:preHandle * Second:preHandle *  * First:afterCompletion * * @author xulingyun * @create 2020-06-02-20:08 */@Componentpublic class FirstInterceptor implements HandlerInterceptor &#123;//    在DispatchServlet之后执行，请求方法获取ModelAndView之前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;First:preHandle&quot;);//        返回false就拦截请求不执行之后的操作        return true;    &#125;//请求方法获取ModelAndView之后执行，还没跳转页面之前    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;First:postHandle&quot;);    &#125;//相当于finally中 跳转页面后执行    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;First:afterCompletion&quot;);    &#125;&#125;</code></pre><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>1）  Spring MVC 通过 HandlerExceptionResolver 处理程序的异常，包括 Handler 映射、数据绑定以及目标方法执行时发生的异常。 </p><p>2）  SpringMVC 提供的 HandlerExceptionResolver 的实现类 </p><h2 id="异常处理-SimpleMappingExceptionResolver"><a href="#异常处理-SimpleMappingExceptionResolver" class="headerlink" title="异常处理_SimpleMappingExceptionResolver"></a>异常处理_SimpleMappingExceptionResolver</h2><p>1）如果希望对<strong>所有异常进行统一处理</strong>，可以使用 SimpleMappingExceptionResolver，它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置SimpleMappingExceptionResolver异常解析器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>simpleMappingExceptionResolver<span class="token punctuation">"</span></span>     <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.handler.SimpleMappingExceptionResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- exceptionAttribute默认值(通过ModelAndView传递给页面)：exception   ->  $&amp;#123;requestScope.exception&amp;#125;public static final String DEFAULT_EXCEPTION_ATTRIBUTE = "exception";--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>exceptionAttribute<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>exception<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>exceptionMappings<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>props</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.ArrayIndexOutOfBoundsException<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>error<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>props</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><pre><code>&lt;%--页面获取异常信息--%&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Error Page&lt;/h3&gt; $&#123;exception &#125;$&#123;requestScope.exception &#125; &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="springmvc流程"><a href="#springmvc流程" class="headerlink" title="springmvc流程"></a>springmvc流程</h1><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/springmvc%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程" title="springmvc流程"></p><p>1）  用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获；</p><p>2）  DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）:</p><p>​    判断请求URI对应的映射</p><p>​        ①  不存在：</p><p>​            l 再判断是否配置了mvc:default-servlet-handler：</p><p>​            l 如果没配置，则控制台报映射查找不到，客户端展示404错误</p><p>​            l 如果有配置，则执行目标资源（一般为静态资源，如：JS,CSS,HTML）</p><p>​        ②  存在：</p><p>​            l 执行下面流程</p><p>3）  根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</p><p>4）  DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p><p>5）  如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法【正向】</p><p>6）  提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p><p>​        ①  HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p><p>​        ②  数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p><p>​        ③  数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p><p>​        ④  数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p><p>7）  Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</p><p>8）  此时将开始执行拦截器的postHandle(…)方法【逆向】</p><p>9）  根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet，根据Model和View，来渲染视图</p><p>10）在返回给客户端时需要执行拦截器的AfterCompletion方法【逆向】</p><p>11） 将渲染结果返回给客户端</p><h1 id="Spring整合SpringMVC"><a href="#Spring整合SpringMVC" class="headerlink" title="Spring整合SpringMVC"></a>Spring整合SpringMVC</h1><h2 id="Spring-与SpringMVC的整合问题："><a href="#Spring-与SpringMVC的整合问题：" class="headerlink" title="Spring 与SpringMVC的整合问题："></a>Spring 与SpringMVC的整合问题：</h2><p>1）  需要进行 Spring 整合 SpringMVC 吗 ? </p><p>2）  还是否需要再加入 Spring 的 IOC 容器 ? </p><p>3）  是否需要在web.xml 文件中配置启动 Spring IOC 容器的 ContextLoaderListener </p><p>​     需要: 通常情况下, 类似于数据源, 事务, 整合其他框架都是放在 Spring 的配置文件          中(而不是放在 SpringMVC 的配置文件中). </p><p>​          实际上放入 Spring 配置文件对应的 IOC 容器中的还有 Service 和 Dao. </p><p>​     不需要: 都放在 SpringMVC 的配置文件中. 也可以分多个 Spring 的配置文件, 然后使</p><p>​           用 import 节点导入其他的配置文件 </p><h2 id="1）-监听器配置"><a href="#1）-监听器配置" class="headerlink" title="1）  监听器配置"></a>1）  监听器配置</h2><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置启动 Spring IOC 容器的 Listener --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:beans.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>org.springframework.web.context.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span></code></pre><p>问题: 若 Spring 的 IOC 容器和 SpringMVC 的 IOC 容器扫描的包有重合的部分, 就会导致有的 bean 会被创建 2 次.</p><p><strong>解决</strong></p><p>使 Spring 的 IOC 容器扫描的包和 SpringMVC 的 IOC 容器扫描的包没有重合的部分. </p><p>使用 exclude-filter 和 include-filter 子节点来规定只能扫描的注解</p><p><code>springmvc.xml</code></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.springmvc<span class="token punctuation">"</span></span> <span class="token attr-name">use-default-filters</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>include-filter</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>annotation<span class="token punctuation">"</span></span>           <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.stereotype.Controller<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>include-filter</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>annotation<span class="token punctuation">"</span></span>           <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.bind.annotation.ControllerAdvice<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span></code></pre><p><code>spring.xml</code></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.springmvc<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>exclude-filter</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>annotation<span class="token punctuation">"</span></span>        <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.stereotype.Controller<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>exclude-filter</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>annotation<span class="token punctuation">"</span></span>        <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.bind.annotation.ControllerAdvice<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 配置数据源, 整合其他框架, 事务等. --></span></code></pre><h2 id="SpringIOC-容器和-SpringMVC-IOC-容器的关系"><a href="#SpringIOC-容器和-SpringMVC-IOC-容器的关系" class="headerlink" title="SpringIOC 容器和 SpringMVC IOC 容器的关系"></a>SpringIOC 容器和 SpringMVC IOC 容器的关系</h2><p>SpringMVC 的 IOC 容器中的 bean 可以来引用 Spring IOC 容器中的 bean. </p><p>返回来呢 ? 反之则不行. Spring IOC 容器中的 bean 却不能来引用 SpringMVC IOC 容器中的 bean </p><p>1）  在 Spring MVC 配置文件中引用业务层的 Bean</p><p>2）  多个 Spring IOC 容器之间可以设置为父子关系，以实现良好的解耦。</p><p>3）  Spring MVC WEB 层容器可作为 “业务层” Spring 容器的子容器：</p><p>​        即 WEB 层容器可以引用业务层容器的 Bean，而业务层容器却访问不到 WEB 层容器的 Bean</p><h2 id="SpringMVC对比Struts2"><a href="#SpringMVC对比Struts2" class="headerlink" title="SpringMVC对比Struts2"></a>SpringMVC对比Struts2</h2><p>1） Spring MVC 的入口是 Servlet, 而 Struts2 是 FilterSpring MVC 会稍微比 Struts2 快些. </p><p>2） Spring MVC 是基于方法设计, 而 Sturts2 是基于类, 每次发一次请求都会实例一个 Action.</p><p>3）  Spring MVC 使用更加简洁, 开发效率Spring MVC确实比 struts2 高: 支持 JSR303, 处 理ajax 的请求更方便</p><p>4）  Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些. </p>]]></content>
      
      
      <categories>
          
          <category> springmvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring复习</title>
      <link href="2020/11/20/spring-fu-xi/"/>
      <url>2020/11/20/spring-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="spring创建通过IOC-Inversion-of-Control-创建对象"><a href="#spring创建通过IOC-Inversion-of-Control-创建对象" class="headerlink" title="spring创建通过IOC(Inversion of Control)创建对象"></a>spring创建通过IOC(Inversion of Control)创建对象</h1><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!-- 使用bean元素定义一个由IOC容器创建的对象 --></span>    <span class="token comment" spellcheck="true">&lt;!-- class属性指定用于创建bean的全类名 --></span>    <span class="token comment" spellcheck="true">&lt;!-- id属性指定用于引用bean实例的标识 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.helloworld.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 使用property子元素为bean的属性赋值 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>studentId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1001<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stuName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Tom2015<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>//1.创建IOC容器对象ApplicationContext iocContainer = new ClassPathXmlApplicationContext("helloworld.xml");//2.根据id值获取bean实例对象Student student = (Student) iocContainer.getBean("student");//3.打印beanSystem.out.println(student);</code></pre><pre><code>## 通过bean的构造器赋值</code></pre><ol><li>   Spring自动匹配合适的构造器</li></ol><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>book<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.spring.bean.Book<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>           &lt;constructor-arg value= "10010"/>           &lt;constructor-arg value= "Book01"/>           &lt;constructor-arg value= "Author01"/>           &lt;constructor-arg value= "20.2"/>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span> <span class="token punctuation">></span></span></code></pre><ol start="2"><li>   通过索引值指定参数位置</li></ol><pre class=" language-xml"><code class="language-xml">     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>book<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.spring.bean.Book<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>           &lt;constructor-arg value= "10010" index ="0"/>           &lt;constructor-arg value= "Book01" index ="1"/>           &lt;constructor-arg value= "Author01" index ="2"/>           &lt;constructor-arg value= "20.2" index ="3"/>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span> <span class="token punctuation">></span></span></code></pre><ol start="3"><li>   通过类型区分重载的构造器</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>book<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.spring.bean.Book<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>      &lt;constructor-arg value= "10010" index ="0" type="java.lang.Integer" />      &lt;constructor-arg value= "Book01" index ="1" type="java.lang.String" />      &lt;constructor-arg value= "Author01" index ="2" type="java.lang.String" />      &lt;constructor-arg value= "20.2" index ="3" type="java.lang.Double" /><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span> <span class="token punctuation">></span></span></code></pre><h1 id="p名称空间"><a href="#p名称空间" class="headerlink" title="p名称空间"></a>p名称空间</h1><p>​     为了简化XML文件的配置，越来越多的XML文件采用属性而非子元素配置信息。Spring     从2.5版本开始引入了一个新的p命名空间，可以通过<bean>元素属性的方式配置Bean  的属性。</p><p>​     使用p命名空间后，基于XML的配置方式将进一步简化。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span>     <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>studentSuper<span class="token punctuation">"</span></span>     <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.helloworld.bean.Student<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">p:</span>studentId</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2002<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">p:</span>stuName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Jerry2016<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">p:</span>age</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>18<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h1 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h1><p>Spring中有两种类型的bean，一种是普通bean，另一种是工厂bean，即FactoryBean。</p><p>工厂bean跟普通bean不同，其返回的对象不是指定类的一个实例，其返回的是该工厂bean的getObject方法所返回的对象。</p><p>工厂bean必须实现org.springframework.beans.factory.FactoryBean接口。</p><p>![FactoryBean](/medias/spring/factorybean.png “FactoryBean”)</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>product<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.spring.bean.ProductFactory<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>productName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Mp3<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h1 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h1><p>在Spring中，可以在<bean>元素的scope属性里设置bean的作用域，以决定这个bean是单实例的还是多实例的。</p><p>默认情况下，Spring只为每个在IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都能共享该实例：所有后续的getBean()调用和bean引用都将返回这个唯一的bean实例。该作用域被称为singleton，它是所有bean的默认作用域。</p><p><img src="/medias/spring/bean%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="bean作用域" title="bean作用域"></p><p><span style="color:red">当bean的作用域为单例时，Spring会在IOC容器对象创建时就创建bean的对象实例。</span>而当bean的作用域为prototype时，IOC容器在获取bean的实例时创建bean的实例对象。</p><h1 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h1><ol><li><p>   Spring IOC容器可以管理bean的生命周期，Spring允许在bean生命周期内特定的时间点执行指定的任务。</p></li><li><p>   Spring IOC容器对bean的生命周期进行管理的过程：</p></li></ol><p>​     ① 通过构造器或工厂方法创建bean实例</p><p>​     ② 为bean的属性设置值和对其他bean的引用</p><p>​     ③ 调用bean的初始化方法</p><p>​     ④ bean可以使用了</p><p>​     ⑤ 当容器关闭时，调用bean的销毁方法</p><ol start="3"><li><p>   在配置bean时，通过init-method和destroy-method 属性为bean指定初始化和销毁方法</p></li><li><p>   bean的后置处理器</p></li></ol><p>​     ① bean后置处理器允许在调用<strong>初始化方法前后</strong>对bean进行额外的处理</p><p>​     ② bean后置处理器对IOC容器里的所有bean实例逐一处理，而非单一实例。</p><p>​            其典型应用是：检查bean属性的正确性或根据特定的标准更改bean的属性。</p><p>​     ③ bean后置处理器需要实现接口：</p><p>​            org.springframework.beans.factory.config.BeanPostProcessor。在初始化方法被调用前后，Spring将把每个bean实例分别传递给上述接口的以下两个方法：</p><p>​            ●postProcessBeforeInitialization(Object, String)</p><p>​            ●postProcessAfterInitialization(Object, String)</p><ol start="5"><li>   <span style="color:red">添加bean后置处理器后bean的生命周期</span></li></ol><p>​     ①通过构造器或工厂方法**创建bean实例 **</p><p>​     ②为bean的<strong>属性设置值</strong>和对其他bean的引用</p><p>​     ③将bean实例传递给bean后置处理器的postProcessBeforeInitialization()方法</p><p>​     ④调用bean的<strong>初始化</strong>方法</p><p>​     ⑤将bean实例传递给bean后置处理器的postProcessAfterInitialization()方法</p><p>​     ⑥bean可以使用了</p><p>​     ⑦当容器关闭时调用bean的<strong>销毁方法</strong></p><h1 id="使用外部的属性文件"><a href="#使用外部的属性文件" class="headerlink" title="使用外部的属性文件"></a>使用外部的属性文件</h1><h4 id="1-创建properties属性文件"><a href="#1-创建properties属性文件" class="headerlink" title="1. 创建properties属性文件"></a>1. 创建properties属性文件</h4><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">prop.userName</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">prop.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">prop.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql:///test</span><span class="token attr-name">prop.driverClass</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span></code></pre><h4 id="2-引入context名称空间"><a href="#2-引入context名称空间" class="headerlink" title="2. 引入context名称空间"></a>2. 引入context名称空间</h4><h4 id="3-指定properties属性文件的位置"><a href="#3-指定properties属性文件的位置" class="headerlink" title="3.指定properties属性文件的位置"></a>3.指定properties属性文件的位置</h4><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 指定properties属性文件的位置 --></span>  <span class="token comment" spellcheck="true">&lt;!--  classpath:xxx 表示属性文件位于类路径下 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>classpath:jdbc.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  </code></pre><h4 id="4-从properties属性文件中引入属性值"><a href="#4-从properties属性文件中引入属性值" class="headerlink" title="4.从properties属性文件中引入属性值"></a>4.从properties属性文件中引入属性值</h4><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 从properties属性文件中引入属性值 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mchange.v2.c3p0.ComboPooledDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;prop.userName&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;prop.password&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;prop.url&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;prop.driverClass&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>        </code></pre><h1 id="组件装配"><a href="#组件装配" class="headerlink" title="组件装配"></a>组件装配</h1><ol><li>   需求</li></ol><p>​     Controller组件中往往需要用到Service组件的实例，Service组件中往往需要用到     Repository组件的实例。Spring可以通过注解的方式帮我们实现属性的装配。</p><ol start="2"><li>   实现依据</li></ol><p>​     <font color="red">在指定要扫描的包时，<code>&lt;context:component-scan&gt;</code> 元素会自动注册一个bean的后置处理器:</font>            AutowiredAnnotationBeanPostProcessor的实例。该后置处理器可以自动装配标记     了**@Autowired**、@Resource或@Inject注解的属性。</p><ol start="3"><li>   @Autowired注解</li></ol><p>​     ①根据类型实现自动装配。</p><p>​     ②构造器、普通字段(即使是非public)、一切具有参数的方法都可以应用@Autowired注解</p><p>​     ③默认情况下，所有使用@Autowired注解的属性都需要被设置。当Spring找不到匹配的bean装配属性时，会抛出异常。</p><p>​     ④若某一属性允许不被设置，可以设置@Autowired注解的required属性为 false</p><p>​     ⑤默认情况下，当IOC容器里存在多个类型兼容的bean时，Spring会尝试匹配bean的id值是否与变量名相同，如果相同则进行装配。如果bean的id值不相同，通过类型的自动装配将无法工作。此时可以在@Qualifier注解里提供bean的名称。**<em>Spring甚至允许在方法的形参上标注@Qualifiter注解以指定注入bean的名称。**</em></p><p>​     ⑥@Autowired注解也可以应用在数组类型的属性上，此时Spring将会把所有匹配的bean进行自动装配。</p><p>​     ⑦@Autowired注解也可以应用在集合属性上，此时Spring读取该集合的类型信息，然后自动装配所有与之兼容的bean。</p><p>​     ⑧@Autowired注解用在java.util.Map上时，若该Map的键值为String，那么 Spring将自动装配与值类型兼容的bean作为值，并以bean的id值作为键。</p><ol start="4"><li>   @Resource</li></ol><p>​     @Resource注解要求提供一个bean名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为bean的名称。</p><ol start="5"><li>   @Inject</li></ol><p>​     @Inject和@Autowired注解一样也是按类型注入匹配的bean，但没有reqired属性。</p><h1 id="面向AOP编程"><a href="#面向AOP编程" class="headerlink" title="面向AOP编程"></a>面向AOP编程</h1><h3 id="动态代理的方式"><a href="#动态代理的方式" class="headerlink" title="动态代理的方式"></a>动态代理的方式</h3><ol><li>基于接口实现动态代理： JDK动态代理</li><li>基于继承实现动态代理： Cglib、Javassist动态代理</li></ol><p>代理工厂(基于JDK动态代理):</p><pre><code>public class ProxyFactory &#123;    public static Object getProxy(Object object)&#123;        ClassLoader classLoader = object.getClass().getClassLoader();        Class[] interfaces = object.getClass().getInterfaces();        return Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler()&#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                System.out.println(&quot;调用方法名：&quot; + method.getName() + &quot;\n参数1:&quot; + args[0] + &quot;\n参数2:&quot; + args[1]);                return method.invoke(object,args);            &#125;        &#125;);    &#125;&#125;</code></pre><h3 id="保存生成的动态代理类"><a href="#保存生成的动态代理类" class="headerlink" title="保存生成的动态代理类"></a>保存生成的动态代理类</h3><pre><code> 在测试方法中加入如下代码： Properties properties = System.getProperties(); properties.put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code></pre><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><h3 id="1-横切关注点"><a href="#1-横切关注点" class="headerlink" title="1 横切关注点"></a>1 横切关注点</h3><p>从每个方法中抽取出来的同一类非核心业务。</p><h3 id="2-切面-Aspect"><a href="#2-切面-Aspect" class="headerlink" title="2 切面(Aspect)"></a>2 切面(Aspect)</h3><p>封装横切关注点信息的类，每个关注点体现为一个通知方法。</p><h3 id="3-通知-Advice"><a href="#3-通知-Advice" class="headerlink" title="3 通知(Advice)"></a>3 通知(Advice)</h3><p>切面必须要完成的各个具体工作</p><h3 id="4-目标-Target"><a href="#4-目标-Target" class="headerlink" title="4 目标(Target)"></a>4 目标(Target)</h3><p>被通知的对象</p><h3 id="5-代理-Proxy"><a href="#5-代理-Proxy" class="headerlink" title="5 代理(Proxy)"></a>5 代理(Proxy)</h3><p>向目标对象应用通知之后创建的代理对象</p><h3 id="6-连接点-Joinpoint"><a href="#6-连接点-Joinpoint" class="headerlink" title="6 连接点(Joinpoint)"></a>6 连接点(Joinpoint)</h3><p>横切关注点在程序代码中的具体体现，对应程序执行的某个特定位置。例如：类某个方法调用前、调用后、方法捕获到异常后等。</p><h3 id="4-2-7-切入点-pointcut-："><a href="#4-2-7-切入点-pointcut-：" class="headerlink" title="4.2.7 切入点(pointcut)："></a>4.2.7 切入点(pointcut)：</h3><p>定位连接点的方式。每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物。如果把连接点看作数据库中的记录，那么切入点就是查询条件——AOP可以通过切入点定位到特定的连接点。切点通过org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1  简介"></a>1  简介</h3><p>AspectJ：<font color="red">Java社区里最完整最流行的AOP框架。</font></p><p>在Spring2.0以上版本中，可以使用基于AspectJ注解或基于XML配置的AOP。</p><p>AOP的实现</p><h3 id="2-在Spring中启用AspectJ注解支持"><a href="#2-在Spring中启用AspectJ注解支持" class="headerlink" title="2  在Spring中启用AspectJ注解支持"></a>2  在Spring中启用AspectJ注解支持</h3><ol><li>   导入JAR包(cglib动态代理)</li></ol><ul><li><p>com.springsource.net.sf.cglib-2.2.0.jar</p></li><li><p>com.springsource.org.aopalliance-1.0.0.jar</p></li><li><p>com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar </p></li><li><p>spring-aop-4.0.0.RELEASE.jar</p></li><li><p>spring-aspects-4.0.0.RELEASE.jar</p></li></ul><ol start="2"><li><p>   引入aop名称空间</p></li><li><p>配置</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspectj-autoproxy</span><span class="token punctuation">></span></span></code></pre></li></ol><p>​     当Spring IOC容器侦测到bean配置文件中的<code>&lt;aop:aspectj-autoproxy&gt;</code>元素时，会自动为与AspectJ切面匹配的bean创建代理</p><h3 id="3-用AspectJ注解声明切面"><a href="#3-用AspectJ注解声明切面" class="headerlink" title="3 用AspectJ注解声明切面"></a>3 用AspectJ注解声明切面</h3><ol><li><p>   要在Spring中声明AspectJ切面，只需要在IOC容器中将切面声明为bean实例。</p></li><li><p>   当在Spring IOC容器中初始化AspectJ切面之后，Spring IOC容器就会为那些与 AspectJ切面相匹配的bean创建代理。</p></li><li><p>   在AspectJ注解中，切面只是一个带有@Aspect注解的Java类，它往往要包含很多通知。</p></li><li><p>   通知是标注有某种注解的简单的Java方法。</p></li><li><p>   AspectJ支持5种类型的通知注解：</p></li></ol><p>​        ① @Before：前置通知，在方法执行之前执行</p><p>​        ② @After：后置通知，在方法执行之后执行(finally中)</p><p>​        ③ @AfterRunning：返回通知，在方法返回结果之后执行</p><p>​        ④ @AfterThrowing：异常通知，在方法抛出异常之后执行</p><p>​        ⑥ @Around：环绕通知，围绕着方法执行</p><p>代码示例:</p><pre><code>/**切面类 * @author xulingyun * @create 2020-05-29-9:36 */@Component//标注为组件可以被自动扫描进入bean@Aspect//标注当前类为切面@Order(2)//表示优先级当有多个切面类时，数字越小优先级越高，但是要是非负数，负数跟没写一个效果.默认值为int的最大值public class MyLoggerAspect &#123;    //定义一个公共的切入点    @Pointcut(value = &quot;execution(* com.xu.aop.*.*(..))&quot;)    public void test()&#123;&#125;//    切入表达式//    @Before(value = &quot;execution(public int com.xu.aop.MathImpl.add(int,int))&quot;)    //第一个*代表:任意的返回值和权限 第二个*代表:aop包下的任意类 第三个*代表:任意的方法名 实参的..:表示任意个参数    @Before(value = &quot;test()&quot;)    public void before(JoinPoint joinPoint)&#123;        Object[] args = joinPoint.getArgs();//获取参数        String name = joinPoint.getSignature().getName();//获取方法名        System.out.println(&quot;Method:&quot; + name + &quot;\nArgument:&quot; + Arrays.toString(args));    &#125;    //写在finally中    @After(value = &quot;test()&quot;)    public void After(JoinPoint joinPoint)&#123;//        joinPoint必须写在第一位参数不然sprig无法识别        System.out.println(&quot;方法执行之后的finally中&quot;);    &#125;    //方法执行之后的 returning 返回值 传入参数列表的同名参数中    @AfterReturning(value = &quot;test()&quot;,returning = &quot;result&quot;)    public void AfterReturn(JoinPoint joinPoint,Object result)&#123;        String name = joinPoint.getSignature().getName();        System.out.println(&quot;Method:&quot; + name + &quot;\nResult:&quot; + result);    &#125;    @AfterThrowing(value = &quot;test()&quot;, throwing = &quot;exception&quot;)    public void AfterReturn(JoinPoint joinPoint,Exception exception)&#123;        System.out.println(&quot;Exception:&quot; + exception);    &#125;    /*@Around(value = &quot;test()&quot;)    public Object AfterReturn(ProceedingJoinPoint proceedingJoinPoint)&#123;        Object object = null;        try &#123;            System.out.println(&quot;前置方法&quot;);            object = proceedingJoinPoint.proceed();//相当于动态代理的invoke方法            System.out.println(&quot;返回方法&quot;);            return object;        &#125; catch (Throwable throwable) &#123;            System.out.println(&quot;异常方法&quot;);            throwable.printStackTrace();            return -1;        &#125;finally &#123;            System.out.println(&quot;后置方法&quot;);        &#125;    &#125;*/&#125;</code></pre><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>通过<strong>表达式的方式</strong>定位<strong>一个或多个</strong>具体的连接点。</p><h4 id="语法细节"><a href="#语法细节" class="headerlink" title="语法细节"></a>语法细节</h4><ol><li><p>切入点表达式的语法格式</p><p><code>execution([权限修饰符] [返回值类型] [简单类名/全类名] [方法名]([参数列表])) </code></p></li><li><p>举例说明</p><table><thead><tr><th>表达式</th><th align="left">execution(<strong><strong>* com.atguigu.spring.ArithmeticCalculator.*</strong></strong>(<strong>..</strong>))</th></tr></thead><tbody><tr><td>含义</td><td align="left">ArithmeticCalculator接口中声明的所有方法。第一个“<em>”代表任意修饰符及任意返回值。第二个“</em>”代表任意方法。“..”匹配任意数量、任意类型的参数。若目标类、接口与该切面类在同一个包中可以省略包名。</td></tr><tr><td>表达式</td><td align="left">execution(<strong>public</strong> * ArithmeticCalculator.*(..))</td></tr><tr><td>含义</td><td align="left">ArithmeticCalculator接口的所有公有方法</td></tr><tr><td>表达式</td><td align="left">execution(public <strong>double</strong>  ArithmeticCalculator.*(..))</td></tr><tr><td>含义</td><td align="left">ArithmeticCalculator接口中返回double类型数值的方法</td></tr><tr><td>表达式</td><td align="left">execution(public double ArithmeticCalculator.*(<strong>double</strong>,  ..))</td></tr><tr><td>含义</td><td align="left">第一个参数为double类型的方法。  “..” 匹配任意数量、任意类型的参数。</td></tr><tr><td>表达式</td><td align="left">execution(public double ArithmeticCalculator.*(<strong>double</strong>,  <strong>double</strong>))</td></tr><tr><td>含义</td><td align="left">参数类型为double，double类型的方法</td></tr></tbody></table></li><li><p>在AspectJ中，切入点表达式可以通过 “&amp;&amp;”、“||”、“!”等操作符结合起来。</p></li></ol><p>| 表达式 | <code>execution (* *.add(int,..)) ||execution(* *.sub(int,..))</code> |<br>| —– | :———————————————————- |<br>|  含义  | 任意类中第一个参数为int类型的add方法或sub方法              |<br>| 表达式 | !execution (* *.add(int,..))                         |<br>|  含义  | 匹配不是任意类中第一个参数为int类型的add方法               |</p><h2 id="当前连接点细节"><a href="#当前连接点细节" class="headerlink" title="当前连接点细节"></a>当前连接点细节</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>   ​    切入点表达式通常都会是从宏观上定位一组方法，和具体某个通知的注解结合起来就能够确定对应的连接点。那么就一个具体的连接点而言，我们可能会关心这个连接点的一些具体信息，例如：当前连接点所在方法的方法名、当前传入的参数值等等。这些信息都封装在<code>JoinPoint</code>接口的实例对象中。</p><h4 id="JoinPoint"><a href="#JoinPoint" class="headerlink" title="JoinPoint"></a>JoinPoint</h4><ol><li>getArgs():获取实际的参数数组</li><li>getSignature():封装签名信息的对象,可以进一步获取方法名</li></ol><h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><ol><li>   使用原生的JDBC API进行事务管理</li></ol><p>​     ①获取数据库连接Connection对象</p><p>​     ②取消事务的自动提交</p><p>​     ③执行操作</p><p>​     ④正常完成操作时手动提交事务</p><p>​     ⑤执行失败时回滚事务</p><p>​     ⑥关闭相关资源</p><ol start="2"><li>   评价</li></ol><p>​         使用原生的<strong>JDBC API</strong>实现事务管理是所有事务管理方式的基石，同时也是最典型     的编程式事务管理。编程式事务管理需要将事务管理代码<strong>嵌入到业务方法中</strong>来控制事务     的提交和回滚。在使用编程的方式管理事务时，必须在每个事务操作中包含额外的事务     管理代码。相对于<strong>核心业务</strong>而言，事务管理的代码显然属于<strong>非核心业务</strong>，如果多个模块     都使用同样模式的代码进行事务管理，显然会造成较大程度的<strong>代码冗余</strong>。</p><h3 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h3><p>​     大多数情况下声明式事务比编程式事务管理更好：它将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</p><p>​     事务管理代码的固定模式作为一种横切关注点，可以通过AOP方法模块化，进而借助Spring AOP框架实现声明式事务管理。</p><p>​     Spring在不同的事务管理API之上定义了一个<strong>抽象层</strong>，通过<strong>配置</strong>的方式使其生效，从而让应用程序开发人员<strong>不必了解事务管API的底层实现细节</strong>，就可以使用Spring的事务管理机制。</p><p>​     Spring既支持编程式事务管理，也支持声明式的事务管理。</p><h3 id="Spring提供的事务管理器"><a href="#Spring提供的事务管理器" class="headerlink" title="Spring提供的事务管理器"></a>Spring提供的事务管理器</h3><p>​     Spring从不同的事务管理API中抽象出了一整套事务管理机制，让事务管理代码从特定的事务技术中独立出来。开发人员通过配置的方式进行事务管理，而不必了解其底层是如何实现的。</p><p>​     Spring的核心事务管理抽象是它为事务管理封装了一组独立于技术的方法。无论使用Spring的哪种事务管理策略(编程式或声明式)，事务管理器都是必须的。</p><p>​     事务管理器可以以普通的bean的形式声明在Spring IOC容器中。</p><h4 id="事务管理器的主要实现"><a href="#事务管理器的主要实现" class="headerlink" title="事务管理器的主要实现"></a>事务管理器的主要实现</h4><ol><li><p>   DataSourceTransactionManager：在应用程序中只需要处理一个数据源，而且通过JDBC存取。</p></li><li><p>   JtaTransactionManager：在JavaEE应用服务器上用JTA(Java Transaction API)进行事务管理</p></li><li><p>   HibernateTransactionManager：用Hibernate框架存取数据库</p></li></ol><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置事务管理器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span>     <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 启用事务注解 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>annotation-driven</span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p>在需要进行事务控制的方法上加注解 @Transactional</p><h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​        当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。事务的传播行为可以由传播属性指定。Spring定义了7种类传播行为。</p><p><img src="/medias/spring/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA.png" alt="事务传播行为" title="事务传播行为"></p><ul><li><strong>1.PROPAGATION_REQUIRED</strong> – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li><li><strong>2.PROPAGATION_SUPPORTS</strong> – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li><strong>3.PROPAGATION_MANDATORY</strong> – 支持当前事务，如果当前没有事务，就抛出异常。</li><li><strong>4.PROPAGATION_REQUIRES_NEW</strong> – 新建事务，如果当前存在事务，把当前事务挂起。</li><li><strong>5.PROPAGATION_NOT_SUPPORTED</strong> – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><strong>6.PROPAGATION_NEVER</strong> – 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><strong>7.PROPAGATION_NESTED</strong> – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li></ul><p>备注：常用的两个事务传播属性是1和4，即PROPAGATION_REQUIRED，PROPAGATION_REQUIRES_NEW</p><p>当前事务指当前调用的方法的事务,新建事务指当前调用方法内部调用方法的事务被新建</p><pre><code>@Servicepublic class BookServiceImpl implements BookService &#123;    @Autowired    private BookDao dao;    /**     * propagation : 事务传播  A方法调用B方法 A方法的事务会传播到B方法     * Propagation.REQUIRES_NEW : 会使用重新new一个事务而把传播的事务挂起     * Propagation.REQUIRED : 会使用传播过来的事务     *     * timeout: 超时强制回滚     *     * readOnly:只是通知mysql事务都是读操作不会修改数据 不需要加锁 并不会影响写操作     *     * rollbackFor: 会因为什么异常而回滚，要是没有设置就是出现异常就回滚，&#123;中写异常的Class类对象数组&#125;。     *                捕获到RuntimeException或Error时回滚，而捕获到编译时异常不回滚。     * noRollbackFor: 不会因为什么异常而回滚     * rollbackForClassName|noRollbackForClassName ：和rollbackFor的区别就是写的是全类名     * @param bid     * @param uid     */    /**     * 事务注解     * @param bid     * @param uid     */    @Override    @Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.DEFAULT,timeout = 3,rollbackFor = &#123;NullPointerException.class,RuntimeException.class&#125;)    public void buyBook(Integer bid,Integer uid)&#123;//        try &#123;//            Thread.sleep(5000);//        &#125; catch (InterruptedException e) &#123;//            e.printStackTrace();//        &#125;        Integer price = dao.selectBookPrice(bid);        dao.updateStock(bid);        dao.updateBalance(uid,price);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat连接</title>
      <link href="2020/11/19/tomcat-lian-jie/"/>
      <url>2020/11/19/tomcat-lian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="tomcat连接"><a href="#tomcat连接" class="headerlink" title="tomcat连接"></a>tomcat连接</h1><p>tomcat接收到一个请求就会为其创建一个线程,池对象(数据库连接池)不会重复创建因为池对象一般都是static的,static修饰的对象不会重复创建.</p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="2020/11/19/threadlocal/"/>
      <url>2020/11/19/threadlocal/</url>
      
        <content type="html"><![CDATA[ <h1 style="color:red">ThreadLocal</h1><p><code>ThreadLocal</code> 的作用，它可以解决多线程的数据安全问题。</p><p><code>ThreadLocal</code> 它可以给当前线程关联一个数据（可以是普通变量，可以是对象，也可以是数组，集合）</p><p><code>ThreadLocal</code> 的特点： </p><ol><li><code>ThreadLocal</code> <strong><em>可以为当前线程关联一个数据</em></strong>。（它可以像 Map 一样存取数据，key 为当前线程） </li><li>每<strong>一个</strong> <code>ThreadLocal </code>对象，只能为当前线程关联<strong>一个</strong>数据，如果要为当前线程关联多个数据，就需要使用多个<code> ThreadLocal</code> 对象实例。 </li><li>每个<code>ThreadLocal</code>对象可以为多个线程绑定一个对象(有点像map),<code>ThreadLocal</code>底层就是使用线程作为key的hash表</li><li>当使用线程池时<code>ThreadLocal</code>对象需要调用<code>remove()</code>清除<code>ThreadLocal</code>为当前线程绑定的对象不然待该线程池中的这个线程再次被使用时就已经有了绑定好的对象(就是那个没有清理的对象),本应该为null.</li><li>每个 <code>ThreadLocal</code> 对象实例定义的时候，一般都是 static 类型 </li><li><code>ThreadLocal</code> 中保存数据，在线程销毁后。会由 <code>JVM</code> 虚拟自动释放。</li></ol><pre><code>public class OrderService &#123;    public void createOrder()&#123;        String name = Thread.currentThread().getName();        System.out.println(&quot;OrderService 当前线程[&quot; + name + &quot;]中保存的数据是：&quot; +        ThreadLocalTest.threadLocal.get());        new OrderDao().saveOrder();    &#125;&#125;public class OrderDao &#123;    public void saveOrder()&#123;        String name = Thread.currentThread().getName();        System.out.println(&quot;OrderDao 当前线程[&quot; + name + &quot;]中保存的数据是：&quot; +        ThreadLocalTest.threadLocal.get());    &#125;&#125;public class ThreadLocalTest &#123;    // public static Map&lt;String,Object&gt; data = new Hashtable&lt;String,Object&gt;();    public static ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;Object&gt;();    private static Random random = new Random();    public static class Task implements Runnable &#123;        @Override        public void run() &#123;            // 在 Run 方法中，随机生成一个变量（线程要关联的数据），然后以当前线程名为 key 保存到 map 中            Integer i = random.nextInt(1000);            // 获取当前线程名            String name = Thread.currentThread().getName();            System.out.println(&quot;线程[&quot;+name+&quot;]生成的随机数是：&quot; + i);            // data.put(name,i);            threadLocal.set(i);        try &#123;            Thread.sleep(3000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;            new OrderService().createOrder();            // 在 Run 方法结束之前，以当前线程名获取出数据并打印。查看是否可以取出操作            // Object o = data.get(name);            Object o = threadLocal.get();            System.out.println(&quot;在线程[&quot;+name+&quot;]快结束时取出关联的数据是：&quot; + o);        &#125;    &#125;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 3; i++)&#123;            new Thread(new Task()).start();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ThreadLocal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传和下载</title>
      <link href="2020/11/19/wen-jian-shang-chuan-he-xia-zai/"/>
      <url>2020/11/19/wen-jian-shang-chuan-he-xia-zai/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><ol><li>要有一个 form 标签，method=post 请求 </li><li>form 标签的 <code>encType</code> 属性值必须为 <code>multipart/form-data</code> 值 </li><li>在 form 标签中使用 input type=file 添加上传的文件 </li><li>编写服务器代码（<code>Servlet</code> 程序）接收，处理上传的数据。</li></ol><p><code>encType=multipart/form-data</code> 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼 接，然后以二进制流的形式发送给服务器</p><h2 id="commons-fileupload-jar-常用-API-介绍说明"><a href="#commons-fileupload-jar-常用-API-介绍说明" class="headerlink" title="commons-fileupload.jar 常用 API 介绍说明"></a>commons-fileupload.jar 常用 API 介绍说明</h2><p><code>commons-fileupload.jar</code> 需要依赖 <code>commons-io.jar</code> 这个包，所以两个包我们都要引入。 </p><ol><li>第一步，就是需要导入两个 jar 包：<code> commons-fileupload-1.2.1.jar</code> <code>commons-io-1.4.jar</code></li><li><code>commons-fileupload.jar</code> 和 <code>commons-io.jar</code> 包中，我们常用的类有哪些？ <ol><li><code>ServletFileUpload</code> 类，用于解析上传的数据。</li><li> <code>FileItem</code> 类，表示每一个表单项。 </li><li><code>boolean ServletFileUpload.isMultipartContent(HttpServletRequest request)</code>; 判断当前上传的数据格式是否是多段的格式。 </li><li><code>public List parseRequest(HttpServletRequest request)</code> 解析上传的数据 </li><li><code>boolean FileItem.isFormField() </code>判断当前这个表单项，是否是普通的表单项。还是上传的文件类型。 true 表示普通类型的表单项 false 表示上传的文件类型 </li><li><code>String FileItem.getFieldName() </code>获取表单项的 name 属性值 </li><li><code>String FileItem.getString()</code> 获取当前表单项的值。</li><li> <code>String FileItem.getName();</code> 获取上传的文件名 </li><li><code>void FileItem.write( file );</code> 将上传的文件写到 参数 file 所指向抽硬盘位置 。</li></ol></li></ol><p>上传文件的表单：</p><pre><code>&lt;form action=&quot;http://192.168.31.74:8080/09_EL_JSTL/uploadServlet&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br&gt;头像：&lt;input type=&quot;file&quot; name=&quot;photo&quot; &gt; &lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;</code></pre><p>解析上传的数据的代码：</p><pre><code>/*** 用来处理上传的数据* @param req* @param resp* @throws ServletException* @throws IOException*/@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException,IOException &#123;    //1 先判断上传的数据是否多段数据（只有是多段的数据，才是文件上传的）    if (ServletFileUpload.isMultipartContent(req)) &#123;        // 创建 FileItemFactory 工厂实现类        FileItemFactory fileItemFactory = new DiskFileItemFactory();        // 创建用于解析上传数据的工具类 ServletFileUpload 类        ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);        try &#123;            // 解析上传的数据，得到每一个表单项 FileItem            List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req);            // 循环判断，每一个表单项，是普通类型，还是上传的文件            for (FileItem fileItem : list) &#123;                if (fileItem.isFormField()) &#123;                    // 普通表单项                    System.out.println(&quot;表单项的 name 属性值：&quot; + fileItem.getFieldName());                    // 参数 UTF-8.解决乱码问题                    System.out.println(&quot;表单项的 value 属性值：&quot; + fileItem.getString(&quot;UTF-8&quot;));                    &#125; else &#123;                    // 上传的文件                    System.out.println(&quot;表单项的 name 属性值：&quot; + fileItem.getFieldName());                    System.out.println(&quot;上传的文件名：&quot; + fileItem.getName());                    fileItem.write(new File(&quot;e:\\&quot; + fileItem.getName()));                &#125;            &#125;        &#125; catch (Exception e) &#123;                e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><p><strong>下载的常用 API 说明：</strong></p><p><code>response.getOutputStream(); </code></p><p><code>servletContext.getResourceAsStream();</code></p><p> <code>servletContext.getMimeType(); </code></p><p><code>response.setContentType();</code></p><p><code>response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; fileName=1.jpg&quot;);</code> </p><p>这个响应头告诉浏览器。这是需要下载的。而 attachment 表示附件，也就是下载的一个文件。<code>fileName=</code>后面， 表示下载的文件名。 完成上面的两个步骤，下载文件是没问题了。但是如果我们要下载的文件是中文名的话。你会发现，下载无法正确 显示出正确的中文名。 原因是在响应头中，不能包含有中文字符，只能包含 ASCII 码。</p><h1 id="附件中文名乱码问题解决方案："><a href="#附件中文名乱码问题解决方案：" class="headerlink" title="附件中文名乱码问题解决方案："></a>附件中文名乱码问题解决方案：</h1><p>方案一：<code>URLEncoder</code> 解决 IE 和谷歌浏览器的 附件中 文名问题。</p><p>​    如果客户端浏览器是 IE 浏览器 或者 是谷歌浏览器。我们需要使用 <code>URLEncoder </code>类先对中文名进行 <code>UTF-8</code> 的编码 操作。 因为 IE 浏览器和谷歌浏览器收到含有编码后的字符串后会以 <code>UTF-8</code> 字符集进行解码显示。</p><pre><code>// 把中文名进行 UTF-8 编码操作。String str = &quot;attachment; fileName=&quot; + URLEncoder.encode(&quot;中文.jpg&quot;, &quot;UTF-8&quot;);// 然后把编码后的字符串设置到响应头中response.setHeader(&quot;Content-Disposition&quot;, str);</code></pre><p>方案二：<code>BASE64</code> 编解码 解决 火狐浏览器的附件中文名问 题</p><p>​    如果客户端浏览器是火狐浏览器。 那么我们需要对中文名进行<code>BASE64</code> 的编码操作。</p><p>​    <code>BASE64</code> 编解码操作：</p><p>​        因为火狐使用的是 <code>BASE64 </code>的编解码方式还原响应中的汉字。所以需要使用 <code>BASE64Encoder</code> 类进行编码操作。</p><pre><code>// 使用下面的格式进行 BASE64 编码后String str = &quot;attachment; fileName=&quot; + &quot;=?utf-8?B?&quot;+ new BASE64Encoder().encode(&quot;中文.jpg&quot;.getBytes(&quot;utf-8&quot;)) + &quot;?=&quot;;// 设置到响应头中response.setHeader(&quot;Content-Disposition&quot;, str);</code></pre><p>那么我们如何解决上面两种不同编解码方式呢。我们只需要通过判断请求头中 User-Agent 这个请求头携带过来的 浏览器信息即可判断出是什么浏览器。</p><pre><code>String ua = request.getHeader(&quot;User-Agent&quot;);// 判断是否是火狐浏览器if (ua.contains(&quot;Firefox&quot;)) &#123;// 使用下面的格式进行 BASE64 编码后String str = &quot;attachment; fileName=&quot; + &quot;=?utf-8?B?&quot;+ new BASE64Encoder().encode(&quot;中文.jpg&quot;.getBytes(&quot;utf-8&quot;)) + &quot;?=&quot;;// 设置到响应头中response.setHeader(&quot;Content-Disposition&quot;, str);&#125; else &#123;// 把中文名进行 UTF-8 编码操作。String str = &quot;attachment; fileName=&quot; + URLEncoder.encode(&quot;中文.jpg&quot;, &quot;UTF-8&quot;);// 然后把编码后的字符串设置到响应头中response.setHeader(&quot;Content-Disposition&quot;, str);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文件上传和下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传和下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EL表达式</title>
      <link href="2020/11/18/el-biao-da-shi/"/>
      <url>2020/11/18/el-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p>EL 表达式的全称是：Expression Language。是表达式语言。</p><h1 id="EL-表达式搜索域数据的顺序"><a href="#EL-表达式搜索域数据的顺序" class="headerlink" title="EL 表达式搜索域数据的顺序"></a>EL 表达式搜索域数据的顺序</h1><ul><li>当四个域中都有相同的 key 的数据的时候，EL 表达式会按照四个域的从小到大的顺序去进行搜索，找到就输出。</li></ul><h1 id="“-”点运算-和-中括号运算符"><a href="#“-”点运算-和-中括号运算符" class="headerlink" title="“.”点运算 和 [] 中括号运算符"></a>“.”点运算 和 [] 中括号运算符</h1><ul><li><p>.点运算，可以输出 Bean 对象中某个属性的值。 </p></li><li><p>[]中括号运算，可以输出有序集合中某个元素的值。 </p></li><li><p>并且[]中括号运算，还可以输出 map 集合中 key 里含有特殊字符的 key 的值。</p></li><li><pre><code>&lt;body&gt;    &lt;%        Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(&quot;a.a.a&quot;, &quot;aaaValue&quot;);        map.put(&quot;b+b+b&quot;, &quot;bbbValue&quot;);        map.put(&quot;c-c-c&quot;, &quot;cccValue&quot;);        request.setAttribute(&quot;map&quot;, map);    %&gt;    $&#123; map[&#39;a.a.a&#39;] &#125; &lt;br&gt;    $&#123; map[&quot;b+b+b&quot;] &#125; &lt;br&gt;    $&#123; map[&#39;c-c-c&#39;] &#125; &lt;br&gt;&lt;/body&gt;</code></pre></li></ul><p><strong><em>注意:El表达式中查找javabean中元素值不是看是否有该元素，而是看是否有该get方法，要是有get方法就算没有属性值也能找到</em></strong></p><h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><ul><li><p>JSTL 标签库 全称是指 JSP Standard Tag Library JSP 标准标签库。是一个不断完善的开放源代码的 JSP 标 签库。 </p></li><li><p>EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个 jsp 页面 变得更佳简洁。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EL表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP响应对象</title>
      <link href="2020/11/18/jsp-xiang-ying-dui-xiang/"/>
      <url>2020/11/18/jsp-xiang-ying-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="jsp-中的-out-输出和-response-getWriter-输出的区别"><a href="#jsp-中的-out-输出和-response-getWriter-输出的区别" class="headerlink" title="jsp 中的 out 输出和 response.getWriter 输出的区别"></a>jsp 中的 out 输出和 response.getWriter 输出的区别</h1><ul><li><p>response 中表示响应，我们经常用于设置返回给客户端的内容（输出） out 也是给用户做输出使用的。</p><p>![JSP](“/medias/web/JSP.png” JSP)</p></li><li><p>由于 jsp 翻译之后，底层源代码都是使用 out 来进行输出，所以一般情况下。我们在 jsp 页面中统一使用 out 来进行输出。避 免打乱页面输出内容的顺序。</p></li><li><p> out.write() 输出字符串没有问题 out.print() 输出任意数据都没有问题（<strong>都转换成为字符串后调用的 write 输出</strong>）</p></li><li><p><strong><em>深入源码，浅出结论：在 jsp 页面中，可以统一使用 out.print()来进行输出</em></strong></p></li></ul><h1 id="jsp-静态包含"><a href="#jsp-静态包含" class="headerlink" title="jsp 静态包含"></a>jsp 静态包含</h1><ul><li><p>示例说明</p></li><li><pre><code>&lt;%--&lt;%@ include file=&quot;&quot;%&gt; 就是静态包含file 属性指定你要包含的 jsp 页面的路径地址中第一个斜杠 / 表示为 http://ip:port/工程路径/ 映射到代码的 web 目录静态包含的特点：1、静态包含不会翻译被包含的 jsp 页面。2、静态包含其实是把被包含的 jsp 页面的代码拷贝到包含的位置执行输出。--%&gt;&lt;%@ include file=&quot;/include/footer.jsp&quot;%&gt;</code></pre></li></ul><h1 id="jsp-动态包含"><a href="#jsp-动态包含" class="headerlink" title="jsp 动态包含"></a>jsp 动态包含</h1><ul><li><p>示例说明</p></li><li><pre><code>&lt;%--&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt; 这是动态包含page 属性是指定你要包含的 jsp 页面的路径动态包含也可以像静态包含一样。把被包含的内容执行输出到包含位置动态包含的特点：1、动态包含会把包含的 jsp 页面也翻译成为 java 代码2、动态包含底层代码使用如下代码去调用被包含的 jsp 页面执行输出。JspRuntimeLibrary.include(request, response, &quot;/include/footer.jsp&quot;, out, false);3、动态包含，还可以传递参数--%&gt;&lt;jsp:include page=&quot;/include/footer.jsp&quot;&gt;&lt;jsp:param name=&quot;username&quot; value=&quot;bbj&quot;/&gt;&lt;jsp:param name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/jsp:include&gt;</code></pre></li></ul><h1 id="jsp-标签-转发"><a href="#jsp-标签-转发" class="headerlink" title="jsp 标签-转发"></a>jsp 标签-转发</h1><ul><li><p>示例说明</p></li><li><pre><code>&lt;%--&lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt; 是请求转发标签，它的功能就是请求转发page 属性设置请求转发的路径--%&gt;&lt;jsp:forward page=&quot;/scope2.jsp&quot;&gt;&lt;/jsp:forward&gt;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> JSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>servlet生命周期</title>
      <link href="2020/11/17/servlet-sheng-ming-zhou-qi/"/>
      <url>2020/11/17/servlet-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="servlet生命周期"><a href="#servlet生命周期" class="headerlink" title="servlet生命周期"></a>servlet生命周期</h1><ol><li><p>Servlet 构造器方法 </p></li><li><p>执行 init 初始化方法 </p><p>第一、二步，是在第一次访问的时候创建 Servlet 程序会调用。  </p></li><li><p>执行 service 方法 </p><p>第三步，每次访问都会调用。 </p></li><li><p>执行 destroy 销毁方法 </p><p>第四步，在 web 工程停止的时候调用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> servlet </category>
          
          <category> 生命周期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="2020/11/17/linux-zhao-hui-mi-ma/"/>
      <url>2020/11/17/linux-zhao-hui-mi-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="linux找回密码"><a href="#linux找回密码" class="headerlink" title="linux找回密码"></a>linux找回密码</h1><p>运行级别说明: </p><ol start="0"><li>关机</li><li>单用户【找回丢失密码】</li><li>多用户状态没有网络服务</li><li>多用户状态有网络服务</li><li>系统未使用保留给用户</li><li>图形界面</li><li>系统重启</li></ol><p>如何找回root密码，如果我们不小心，忘记root密码，怎么找回。<br>思路:进入到单用户模式，然后修改root密码。因为进入单用户模式，root不需要密码就可以登录。<br>总结<br>开机-&gt;在引导时输入回车键-&gt;看到一个界面输入e →&gt;看到一个新的界面，选中第二行（编辑内核）在输入e&gt;在这行最后输入 1 ,再输入回车键&gt;再次输入 b ,这时就会进入到单用户模式。<br>这时，我们就进入到单用户模式，使用<code>passwd</code>指令来修改root密码。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux找回密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="2020/11/17/linux-guan-ji-ming-ling/"/>
      <url>2020/11/17/linux-guan-ji-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h1><ol><li>shutdown<ul><li>shutdown -h now:表示立即关机</li><li>shutdown -h 1:表示1分钟后关机</li><li>shutdown -r now:立即重启</li></ul></li><li>halt 就是直接使用，效果等价于关机</li><li>reboot 就是重启系统。</li><li>syn :把内存的数据同步到磁盘</li><li>注意细节<br>当我们关机或者重启时，都应该先执行以下 sync指令，把内存的数据写入磁盘，防止数据丢失。</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关机命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim操作</title>
      <link href="2020/11/17/vim-cao-zuo/"/>
      <url>2020/11/17/vim-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="vim基本操作"><a href="#vim基本操作" class="headerlink" title="vim基本操作"></a>vim基本操作</h1><ol><li>拷贝当前行yy,拷贝当前行向下的5行5yy, 并粘贴(p) 。</li><li>删除当前行dd, 删除当前行向下的5行5dd</li><li>在文件中查找某个单词[命令行下/关键字，回车查找，输入n就是查找下一个],查询hello.</li><li>设置文件的行号，取消文件的行号.[命令行下:setnu 和:set nonu |</li><li>编辑/etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg],注意这些都是在正常模式下执行的。</li><li>在一个文件中输入”hello” 然后又撤销这个动作，再正常模式下输入u</li><li>编辑/etc/profile 文件，并将光标移动到 第20行<br>shift+g<br>第一步:显示行号:setnu<br>第二步:输入20这个数<br>第三步:输入shift+g</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javase(下)</title>
      <link href="2020/11/14/javase-xia/"/>
      <url>2020/11/14/javase-xia/</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ol><li>每个线程，拥有自己独立的：<strong>栈、程序计数器</strong></li><li>多个线程，共享同一个进程中的结构：<strong>方法区、堆</strong>。</li><li>一个Java应用程序<code>java.exe</code>，其实至少三个线程：<code>main()主线程</code>，<code>gc()垃圾回收线程</code>，<code>异常处理线程</code>。当然如果发生异常，会影响主线程。</li></ol><h1 id="Thread类中的常用的方法"><a href="#Thread类中的常用的方法" class="headerlink" title="Thread类中的常用的方法:"></a>Thread类中的常用的方法:</h1><ul><li><ol><li><code>start()</code>:启动当前线程；调用当前线程的<code>run()</code></li></ol></li><li><ol start="2"><li><code>run()</code>: 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li></ol></li><li><ol start="3"><li><code>currentThread()</code>:静态方法，返回执行当前代码的线程</li></ol></li><li><ol start="4"><li><code>getName()</code>:获取当前线程的名字</li></ol></li><li><ol start="5"><li><code>setName()</code>:设置当前线程的名字</li></ol></li><li><ol start="6"><li><code>yield()</code>:释放当前<code>cpu</code>的执行权</li></ol></li><li><ol start="7"><li><code>join()</code>:在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</li></ol></li><li><ol start="8"><li><code>stop()</code>:已过时。当执行此方法时，强制结束当前线程。</li></ol></li><li><ol start="9"><li><code>sleep(long millitime)</code>:让当前线程“睡眠”指定的<code>millitime</code>毫秒。在指定的<code>millitime</code>毫秒时间内，当前线程是阻塞状态。</li></ol></li><li><ol start="10"><li><code>isAlive()</code>:判断当前线程是否存活</li></ol></li></ul><h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><ul><li><p><code>MAX_PRIORITY：10</code></p></li><li><p><code>MIN _PRIORITY：1</code></p></li><li><p><code>NORM_PRIORITY：5 </code> –&gt;默认优先级</p></li></ul><ol><li><p>如何获取和设置当前线程的优先级：</p><ul><li>  <code>getPriority()</code>:获取线程的优先级</li><li>  <code>setPriority(int p)</code>:设置线程的优先级</li></ul></li><li><p>说明：高优先级的线程要抢占低优先级线程<code>cpu</code>的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p></li></ol><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><pre><code>public class ThreadPool &#123;    public static void main(String[] args) &#123;        //1. 提供指定线程数量的线程池        ExecutorService service = Executors.newFixedThreadPool(10);        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;        //设置线程池的属性//        System.out.println(service.getClass());//        service1.setCorePoolSize(15);//        service1.setKeepAliveTime();        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象        service.execute(new NumberThread());//适合适用于Runnable        service.execute(new NumberThread1());//适合适用于Runnable//        service.submit(Callable callable);//适合使用于Callable        //3.关闭连接池        service.shutdown();    &#125;&#125;</code></pre><h1 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h1><ol><li>当对字符串重新赋值时，需要重写指定内存区域赋值，<strong>不能使用原有的value进行赋值</strong>。</li><li>当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，<strong>不能使用原有的value进行赋值</strong>。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，<strong>不能使用原有的value进行赋值</strong>。</li></ol><h1 id="字符串拼接方式赋值的对比"><a href="#字符串拼接方式赋值的对比" class="headerlink" title="字符串拼接方式赋值的对比"></a>字符串拼接方式赋值的对比</h1><ol><li>常量与常量的拼接结果在<strong>常量池</strong>。且常量池中不会存在相同内容的常量。</li><li>只要其中一个是变量，结果就在<strong>堆</strong>中。</li><li>如果拼接的结果调用<code>intern()</code>方法，返回值就在<strong>常量池</strong>中</li></ol><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><pre><code> @Test    public void test3()&#123;        HashSet set = new HashSet();        Person p1 = new Person(1001,&quot;AA&quot;);        Person p2 = new Person(1002,&quot;BB&quot;);        set.add(p1);        set.add(p2);        System.out.println(set);        p1.name = &quot;CC&quot;;        set.remove(p1);//因为p1.name的值变为CC然后哈希值也就不一样了在对应哈希值位置没有元素所以删除失败        System.out.println(set);//输出p1、p2        set.add(new Person(1001,&quot;CC&quot;));//对应哈希值位置没有元素添加成功        System.out.println(set);        set.add(new Person(1001,&quot;AA&quot;));        System.out.println(set);//对应哈希值位置上的值的哈希值与其不匹配所以添加成功    &#125;&#125;</code></pre><p>总结要修改<code>hashSet</code>集合的值需要把该值先<strong>删除</strong>在修改然后<strong>重新添加</strong>不然会出问题</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ol><li><p><strong>静态方法中不能使用类的泛型。</strong></p><pre><code>    public static void show(T orderT)&#123;        System.out.println(orderT);    &#125;//错误</code></pre></li><li><p><strong>泛型方法</strong></p><p>在方法中出现了泛型的结构，<strong>泛型参数与类的泛型参数没任何关系</strong>。<br>换句话说，泛型方法所属的类是不是泛型类都没关系。<br>泛型方法，可以声明为静态的。原因：<strong>泛型参数是在调用方法时确定的。并非在实例化类时确定</strong>。</p><pre><code>public static &lt;E&gt;  List&lt;E&gt; copyFromArrayToList(E[] arr)&#123;    ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();    for(E e : arr)&#123;    list.add(e);    &#125;    return list;&#125;</code></pre></li><li><p><strong>泛型不同的引用不能相互赋值</strong></p><pre><code>@Testpublic void test3()&#123;    ArrayList&lt;String&gt; list1 = null;    ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();    //泛型不同的引用不能相互赋值。    //        list1 = list2;    Person p1 = null;    Person p2 = null;    p1 = p2;&#125;</code></pre></li><li><p>泛型在继承方面的体现<br>  虽然类A是类B的父类，但是<code>G&lt;A&gt;</code> 和<code>G&lt;B&gt;</code>二者不具备子父类关系，二者是并列关系。<br>  补充：类A是类B的父类，<code>A&lt;G&gt;</code> 是 <code>B&lt;G&gt; </code>的父类</p></li><li><p>通配符：?</p><p><strong>类A是类B的父类，<code>G&lt;A&gt;</code>和<code>G&lt;B&gt;</code>是没关系的，二者共同的父类是：<code>G&lt;?&gt;</code></strong></p><pre><code> @Test    public void test3()&#123;        List&lt;Object&gt; list1 = null;        List&lt;String&gt; list2 = null;        List&lt;?&gt; list = null;        list = list1;        list = list2;        //编译通过//        print(list1);//        print(list2);        List&lt;String&gt; list3 = new ArrayList&lt;&gt;();        list3.add(&quot;AA&quot;);        list3.add(&quot;BB&quot;);        list3.add(&quot;CC&quot;);        list = list3;        //添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。        //除了添加null之外。//        list.add(&quot;DD&quot;);//        list.add(&#39;?&#39;);        list.add(null);        //获取(读取)：允许读取数据，读取的数据类型为Object。        Object o = list.get(0);        System.out.println(o);</code></pre></li></ol><pre><code>   &#125;</code></pre><pre><code>6. 有限制条件的通配符的使用* ? extends A:                  ***G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类**** ? super A:                  ***G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类***例子：</code></pre><pre><code>   @Test   public void test4()&#123;       List&lt;? extends Person&gt; list1 = null;       List&lt;? super Person&gt; list2 = null;       List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;();       List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;();       List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;();       list1 = list3;       list1 = list4;</code></pre><p>   //        list1 = list5;</p><p>   //           list2 = list3;<br>           list2 = list4;<br>           list2 = list5;</p><pre><code>       //读取数据：       list1 = list3;       Person p = list1.get(0);       //编译不通过       //Student s = list1.get(0);       list2 = list4;       Object obj = list2.get(0);       ////编译不通过</code></pre><p>   //        Person obj = list2.get(0);</p><pre><code>       //写入数据：       //编译不通过</code></pre><p>   //        list1.add(new Student());              </p><pre><code>       //编译通过       list2.add(new Person());       list2.add(new Student());   &#125;    </code></pre><pre><code># BufferedReader和BufferedWriter</code></pre><p>@Test<br>    public void testBufferedReaderBufferedWriter(){<br>        BufferedReader br = null;<br>        BufferedWriter bw = null;<br>        try {<br>            //创建文件和相应的流<br>            br = new BufferedReader(new FileReader(new File(“dbcp.txt”)));<br>            bw = new BufferedWriter(new FileWriter(new File(“dbcp1.txt”)));</p><pre><code>        //读写操作        //方式一：使用char[]数组</code></pre><p>//            char[] cbuf = new char[1024];<br>//            int len;<br>//            while((len = br.read(cbuf)) != -1){<br>//                bw.write(cbuf,0,len);<br>//    //            bw.flush();<br>//            }</p><pre><code>        //方式二：使用String        String data;        while((data = br.readLine()) != null)&#123;            //方法一：</code></pre><p>//                bw.write(data + “\n”);//data中不包含换行符<br>                //方法二：<br>                bw.write(data);//data中不包含换行符<br>                bw.newLine();//提供换行的操作</p><pre><code>        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        //关闭资源        if(bw != null)&#123;            try &#123;                bw.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if(br != null)&#123;            try &#123;                br.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><pre><code># 修改默认的输入和输出行为System类的`setIn(InputStream is)` / `setOut(PrintStream ps)`方式重新指定输入和输出的流。# 获取运行时类的带泛型的父类的泛型</code></pre><pre><code>@Testpublic void test4()&#123;    Class clazz = Person.class;    Type genericSuperclass = clazz.getGenericSuperclass();    ParameterizedType paramType = (ParameterizedType) genericSuperclass;    //获取泛型类型    Type[] actualTypeArguments = paramType.getActualTypeArguments();</code></pre><p>//        System.out.println(actualTypeArguments[0].getTypeName());<br>        System.out.println(((Class)actualTypeArguments[0]).getName());<br>    }<br>```</p>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE小知识</title>
      <link href="2020/11/13/javase-xiao-zhi-shi/"/>
      <url>2020/11/13/javase-xiao-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ol><li><p>？+= ？ 和？ = ？+ ？区别？</p><ul><li><pre><code>short s1 = 10;//s1 = s1 + 2;//编译失败,2是int型,需要short型s1 += 2;//结论：不会改变变量本身的数据类型</code></pre></li></ul></li></ol><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><ol><li><pre><code>//区分&amp; 与 &amp;&amp;    //相同点1：&amp; 与  &amp;&amp; 的运算结果相同    //相同点2：当符号左边是true时，二者都会执行符号右边的运算    //不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。    //开发中，推荐使用&amp;&amp;</code></pre></li><li><pre><code>// 区分：| 与 ||     //相同点1：| 与  || 的运算结果相同    //相同点2：当符号左边是false时，二者都会执行符号右边的运算    //不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算    //开发中，推荐使用||</code></pre></li></ol><h1 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h1><ol><li><p>你能否写出最高效的2 * 8的实现方式？<br>答案：2 &lt;&lt; 3  或  8 &lt;&lt; 1相当于(2*2^3)</p></li><li><pre><code>1. 位运算符操作的都是整型的数据2. &lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2   &gt;&gt; :在一定范围内，每向右移1位，相当于 / 2</code></pre></li></ol><h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><ol><li><pre><code>① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。  当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构  末尾结束为止。② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构③ switch结构中的表达式，只能是如下的6种数据类型之一：   byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)④ case 之后只能声明常量。不能声明范围。⑤ break关键字是可选的。⑥ default:相当于if-else结构中的else.    default结构是可选的，而且位置是灵活的。3.如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。4.break在switch-case中是可选的</code></pre></li></ol><h1 id="跳出多重循环"><a href="#跳出多重循环" class="headerlink" title="跳出多重循环"></a>跳出多重循环</h1><ol><li><pre><code>label:for（i=0;i&lt;10;i++）   for(j=0;j&lt;4;j++)    if(j%4==0)         break label;跳出多重循环；label:for（i=0;i&lt;10;i++）   for(j=0;j&lt;4;j++)    if(j%4==0)         continue label;</code></pre></li></ol><h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><ol><li><pre><code>import java.util.Scanner;class ScannerTest&#123;    public static void main(String[] args)&#123;        //2.Scanner的实例化        Scanner scan = new Scanner(System.in);        //3.调用Scanner类的相关方法        System.out.println(&quot;请输入你的姓名：&quot;);        String name = scan.next();        System.out.println(name);        System.out.println(&quot;请输入你的芳龄：&quot;);        int age = scan.nextInt();        System.out.println(age);        System.out.println(&quot;请输入你的体重：&quot;);        double weight = scan.nextDouble();        System.out.println(weight);        System.out.println(&quot;你是否相中我了呢？(true/false)&quot;);        boolean isLove = scan.nextBoolean();        System.out.println(isLove);        //对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串        System.out.println(&quot;请输入你的性别：(男/女)&quot;);        String gender = scan.next();//&quot;男&quot;        char genderChar = gender.charAt(0);//获取索引为0位置上的字符        System.out.println(genderChar);        &#125;&#125;</code></pre></li></ol><h1 id="数组默认初始化化值"><a href="#数组默认初始化化值" class="headerlink" title="数组默认初始化化值"></a>数组默认初始化化值</h1><ol><li><p>一维数组元素的默认初始化值</p><pre><code>&gt; 数组元素是整型：0&gt; 数组元素是浮点型：0.0&gt; 数组元素是char型：0或&#39;\u0000&#39;，而非&#39;0&#39;&gt; 数组元素是boolean型：false&gt; 数组元素是引用数据类型：null</code></pre></li><li><p>二维数组元素的默认初始化值</p><pre><code> *     规定：二维数组分为外层数组的元素，内层数组的元素 *         int[][] arr = new int[4][3]; *         外层元素：arr[0],arr[1]等 *         内层元素：arr[0][0],arr[1][2]等 *  *   ⑤ 数组元素的默认初始化值  *   针对于初始化方式一：比如：int[][] arr = new int[4][3]; *      外层元素的初始化值为：地址值 *      内层元素的初始化值为：与一维数组初始化情况相同 *       *   针对于初始化方式二：比如：int[][] arr = new int[4][]; *       外层元素的初始化值为：null *      内层元素的初始化值为：不能调用，否则报错NullPointException。</code></pre></li></ol><h1 id="对象默认初始值"><a href="#对象默认初始值" class="headerlink" title="对象默认初始值"></a>对象默认初始值</h1><ul><li><ol><li>默认初始化值的情况：</li></ol><p>属性：类的属性，根据其类型，都默认初始化值。</p><p>整型（byte、short、int、long：0）</p><p>浮点型（float、double：0.0）</p><p>字符型（char：0  （或’\u0000’））</p><p>布尔型（boolean：false）</p><p>引用数据类型（类、数组、接口：null）</p></li></ul><p>   局部变量：没默认初始化值。</p><p>   意味着，我们在调用局部变量之前，一定要显式赋值。</p><p>   特别地：形参在调用时，我们赋值即可。</p><ul><li><p>2.4 在内存中加载的位置：</p><p>属性：加载到堆空间中   （非static）</p><p><strong>局部变量：加载到栈空间</strong></p></li></ul><h1 id="this调用构造器"><a href="#this调用构造器" class="headerlink" title="this调用构造器"></a>this调用构造器</h1><ol><li><pre><code>① 我们在类的构造器中，可以显式的使用&quot;this(形参列表)&quot;方式，调用本类中指定的其他构造器② 构造器中不能通过&quot;this(形参列表)&quot;方式调用自己③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了&quot;this(形参列表)&quot;④ 规定：&quot;this(形参列表)&quot;必须声明在当前构造器的首行⑤ 构造器内部，最多只能声明一个&quot;this(形参列表)&quot;，用来调用其他的构造器</code></pre></li></ol><h1 id="super调用构造器"><a href="#super调用构造器" class="headerlink" title="super调用构造器"></a>super调用构造器</h1><ol><li><pre><code>1. 我们可以在子类的构造器中显式的使用&quot;super(形参列表)&quot;的方式，调用父类中声明的指定的构造器2. &quot;super(形参列表)&quot;的使用，必须声明在子类构造器的首行！3. 我们在类的构造器中，针对于&quot;this(形参列表)&quot;或&quot;super(形参列表)&quot;只能二一，不能同时出现4. 在构造器的首行，没显式的声明&quot;this(形参列表)&quot;或&quot;super(形参列表)&quot;，则默认调用的是父类中空参的构造器：super()5. 在类的多个构造器中，至少一个类的构造器中使用了&quot;super(形参列表)&quot;，调用父类中的构造器</code></pre></li></ol><h1 id="import的使用："><a href="#import的使用：" class="headerlink" title="import的使用："></a>import的使用：</h1><ol><li><pre><code>import:导入 * 1. 在源文件中显式的使用import结构导入指定包下的类、接口 * 2. 声明在包的声明和类的声明之间 * 3. 如果需要导入多个结构，则并列写出即可 * 4. 可以使用&quot;xxx.*&quot;的方式，表示可以导入xxx包下的所结构 * 5. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 * 6. 如果使用的类或接口是本包下定义的，则可以省略import结构 * 7. 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。 * 8. 使用&quot;xxx.*&quot;方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 *  * 9. import static:导入指定类或接口中的静态结构:属性或方法。 </code></pre><h1 id="重写的规则"><a href="#重写的规则" class="headerlink" title="重写的规则"></a>重写的规则</h1><ol><li><p>方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{</p><pre><code>                       //方法体       &#125;</code></pre><ul><li>约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</li><li>① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</li><li>② 子类重写的方法的权限修饰符<strong>不小于</strong>父类被重写的方法的权限修饰符</li></ul><p>​      <strong>特殊情况：子类不能重写父类中声明为private权限的方法</strong></p><ul><li>③ 返回值类型：</li></ul><p>​     父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</p><p>​     <strong>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</strong></p><p>​     父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型     (必须也是double)</p><ul><li>④ 子类重写的方法抛出的异常类型<strong>不大于</strong>父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）</li></ul><hr><ul><li>   子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写)。    </li></ul></li></ol></li></ol><h1 id="：运算符"><a href="#：运算符" class="headerlink" title="== ：运算符"></a>== ：运算符</h1><ul><li><ol><li>可以使用在基本数据类型变量和引用数据类型变量中</li></ol></li><li><ol start="2"><li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（<strong>不一定类型要相同</strong>）</p><p>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p></li></ol></li></ul><ul><li>补充： == 符号使用时，必须保证符号左右两边的变量类型一致<strong>引用类型</strong>。</li></ul><h1 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h1><ol><li><p>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：</p><ul><li><p><strong>由父及子，静态先行。</strong></p></li><li><p>result: </p><pre><code>B父类 A子类this is B’s static block!this is A’s static block!this is B’ static not block!this is B’s constructor!this is A’ static not block!this is A’s constructor</code></pre></li></ul></li></ol><h1 id="属性赋值顺序"><a href="#属性赋值顺序" class="headerlink" title="属性赋值顺序"></a>属性赋值顺序</h1><pre><code> * ①默认初始化 * ②显式初始化/⑤在代码块中赋值 * ③构造器中初始化 * ④有了对象以后，可以通过&quot;对象.属性&quot;或&quot;对象.方法&quot;的方式，进行赋值 *   * 执行的先后顺序：① - ② / ⑤ - ③ - ④</code></pre><h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><ol><li><p>可以用来修饰：类、方法</p></li><li><p>具体的：<br>抽象类,就像是向别人声明:我能赚大钱<br>实例化就是具体的行动<br>因为抽象类只是个声明,而没有计划,也不知道怎么赚钱<br>所以我们是不会投资给钱(内存)他的,就算投资他他也不能做任何事<br>为了保存大家的利益,没有具休的赚钱计划不能让他执行<br>abstract修饰类：抽象类</p><ul><li>此类不能实例化<ul><li><strong>抽象类中一定有构造器</strong>，便于子类实例化时调用（涉及：子类对象实例化的全过程,子类会调用父类的构造器）</li><li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性</li></ul></li></ul></li><li><p>abstract修饰方法：抽象方法</p><ul><li>抽象方法只方法的声明，没方法体</li><li><strong>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</strong></li><li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li><li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li></ul></li><li><p>注意点：</p><ul><li>abstract不能用来修饰：属性、构造器等结构</li><li>abstract不能用来修饰私方法、静态方法、final的方法、final的类（<strong>静态方法不能被重写</strong>）</li></ul></li></ol><h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><ol><li><p> 接口使用interface来定义</p></li><li><p>Java中，接口和类是并列的两个结构</p></li><li><p>如何定义接口：定义接口中的成员</p><ol><li><code>JDK7</code>及以前：只能定义全局常量和抽象方法</li><li>全局常量：<code>public static final</code>的.但是书写时，可以<strong>省略不写</strong></li><li>抽象方法：<code>public abstract</code>的</li><li><code> JDK8</code>：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li></ol></li><li><p><strong>接口中不能定义构造器的！</strong>意味着接口不可以实例化</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p><ul><li>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</li><li>如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</li></ul></li><li><p>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性</p><ul><li>格式：<code>class AA extends BB implements CC,DD,EE</code></li></ul></li><li><p><strong>接口与接口之间可以继承，而且可以多继承</strong>(可以多继承（extends），不能实现（implement）)</p><hr></li><li><p>接口的具体使用，体现多态性</p></li><li><p>接口，实际上可以看做是一种规范</p></li></ol><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ul><li>体会1：使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，<strong>延迟到运行时出现</strong>。</li><li>体会2：开发中，由于运行时异常比较常见，所以我们通常就<strong>不针对运行时异常编写</strong>try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github搜索</title>
      <link href="2020/11/12/github-sou-suo/"/>
      <url>2020/11/12/github-sou-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="github搜索命令"><a href="#github搜索命令" class="headerlink" title="github搜索命令"></a>github搜索命令</h1><h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p>redis in:name,description,readme</p><ul><li>搜索在名字，描述，readme中有redis的项目（可选）</li></ul><p>redis in:name</p><ul><li>搜索在名字中有redis的项目（可选）</li></ul><h2 id="starts-和-forks"><a href="#starts-和-forks" class="headerlink" title="starts 和 forks"></a>starts 和 forks</h2><p>redis stars:&gt;=1000 forks:&gt;=5000</p><ul><li>搜索点赞大于等于1000 和 fork大于等于5000的项目</li></ul><p>redis stars:100..5000 forks:100..5000</p><ul><li>搜索点赞在100到5000 和 fork 在100到5000的项目</li></ul><h2 id="awesome"><a href="#awesome" class="headerlink" title="awesome"></a>awesome</h2><p>awesome redis</p><ul><li>搜索出该关键字的精品教程</li></ul><h2 id="L"><a href="#L" class="headerlink" title="#L"></a>#L</h2><p>在网站地址后面加上#L数字-L数字，可高亮显示代码</p><p>例如：</p><p><a href="https://github.com/redis/redis/blob/unstable/deps/hiredis/async.h#L13-L30">https://github.com/redis/redis/blob/unstable/deps/hiredis/async.h#L13-L30</a></p><p>表示从13行到30行高亮显示</p><h2 id="T搜索"><a href="#T搜索" class="headerlink" title="T搜索"></a>T搜索</h2><p>在项目中按字母小T可以把文件排列出来好找</p><h2 id="查看附件活跃用户"><a href="#查看附件活跃用户" class="headerlink" title="查看附件活跃用户"></a>查看附件活跃用户</h2><p>location:zhangzhou language:java</p><p>可以查看附件活跃的用户</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux查看资源占用命令</title>
      <link href="2020/11/12/linux-cha-kan-zi-yuan-zhan-yong-ming-ling/"/>
      <url>2020/11/12/linux-cha-kan-zi-yuan-zhan-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="生产环境出现cpu占用过高-怎么定位"><a href="#生产环境出现cpu占用过高-怎么定位" class="headerlink" title="生产环境出现cpu占用过高,怎么定位"></a>生产环境出现<code>cpu</code>占用过高,怎么定位</h1><h2 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估:"></a>性能评估:</h2><ul><li>整机: <code>top</code> 或者 uptime系统性能命令的精简版</li><li><code>cpu</code>:<code>vmstat -n 2 3</code>: 输出三次每两秒一次</li><li>内存:<code>free -h</code></li><li>磁盘:<code>df -h</code>:h:human </li><li>磁盘io:<code>iostat -xdk 2 3</code> </li><li>网络io:<code>ifstat</code></li></ul><h2 id="cpu占用过高的分析思路"><a href="#cpu占用过高的分析思路" class="headerlink" title="cpu占用过高的分析思路"></a>cpu占用过高的分析思路</h2><ol><li>先用<code>top</code>命令找到cpu占比最高的</li><li><code>ps -ef</code>或者jps进一步定位,得知是怎样一个后台程序给我们惹事</li><li>定位到具体线程或者代码<code>ps -mp 进程 -o THREAD,tid,time</code>: tid线程id<ol><li>m:显示所有线程</li><li>p:pid进程使用cpu时间</li><li>o:该参数后是用户自定义格式</li></ol></li><li>将线程id转换为16进程，字母小写</li><li>jstack 进程id|grep tid（16进制字母小写） -A60</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七大垃圾收集器</title>
      <link href="2020/11/11/qi-da-la-ji-shou-ji-qi/"/>
      <url>2020/11/11/qi-da-la-ji-shou-ji-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="四大主要的垃圾收集器"><a href="#四大主要的垃圾收集器" class="headerlink" title="四大主要的垃圾收集器"></a>四大主要的垃圾收集器</h1><p><img src="/medias/GC/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="垃圾收集器" title="垃圾收集器"></p><ol><li><p>Serial:串行垃圾收集器,是单线程的垃圾收集器,会暂停所有用户线程<code>STW</code>(Stop The World),所以不适合服务器环境使用</p></li><li><p>Parallel:并行垃圾收集器(默认),是多线程的垃圾收集器,会暂停所有用户线程<code>STW</code>(Stop The World),比串行回收速度快</p></li><li><p><code>CMS</code>(Concurrent Mark Sweep):并发标记清除垃圾收集器,用户线程和垃圾收集器线程同时执行(不一定是并行,可能交替执行),不需要用户线程停顿,互联网公司多用它,适用对响应时间有要求的场景</p></li><li><p><code>G1</code>:把需要<code>GC</code>的地方分为一个一个小块</p></li></ol><h1 id="七大垃圾回收器"><a href="#七大垃圾回收器" class="headerlink" title="七大垃圾回收器"></a>七大垃圾回收器</h1><ol><li><p><code>UseSerialGC</code></p></li><li><p><code>UseSerialOldGc</code>:淘汰了</p></li><li><p><code>UseeParallelGC</code></p></li><li><p><code>UseConcMarkSweepGC</code></p></li><li><p><code>UseParNewGC</code></p></li><li><p><code>UseParallelOldGC</code></p></li><li><p><code>UseG1GC</code></p><p><code>java -XX:+PrintCommandLineFlags -version</code>:查看默认<code>GC</code></p><p><code>jps -l</code>:查看进程号</p><p><code>jinfo -flag UseSerialGC 进程号</code>:查看该进程是否使用串行垃圾回收器</p></li></ol><p><img src="/medias/GC/%E4%B8%83%E5%A4%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BD%BF%E7%94%A8%E5%9C%B0.png" alt="七大垃圾收集器使用地" title="七大垃圾收集器使用地"></p><p><img src="/medias/GC/%E4%B8%83%E5%A4%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="七大垃圾收集器" title="七大垃圾收集器"></p><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ol><li><code>DefNew</code>:Default New Generation(<code>UseSerialGC</code>)</li><li><code>Tenured</code>:Old(<code>UseSerialOldGC</code>)</li><li><code>ParNew</code>:Parallel  New Generation(<code>UseParNewGC</code>)</li><li><code>PSYoungGen</code>:Parallel Scavenge(<code>UseeParallelGC</code>)</li><li><code>ParOldGen</code>:Parallel Old Generation(<code>UseParallelOldGC</code>)</li></ol><h2 id="GC之Seriial收集器"><a href="#GC之Seriial收集器" class="headerlink" title="GC之Seriial收集器"></a>GC之Seriial收集器</h2><p>代码例子(在<code>vm option</code>上配置<code>-Xms10m -Xmx10m -XX:+UseSerialGC -XX:+PrintGCDetails</code>)：</p><pre><code>public class HelloGC &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;**********HelloGC&quot;);        byte[] bytes = new byte[30 * 1024 * 1024];    &#125;&#125;</code></pre><p>result:<code>DefNew</code>(<code>UseSerialGC</code>)<code>Tenured</code>(<code>UseSerialOldGC</code>)在新生代单线程垃圾回收,老年代单线程垃圾回收,新生代复制算法,老年代标记-整理算法</p><pre><code>**********HelloGC[GC (Allocation Failure) [DefNew: 1810K-&gt;320K(3072K), 0.0014614 secs][Tenured: 321K-&gt;640K(6848K), 0.0016918 secs] 1810K-&gt;640K(9920K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0032163 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [Tenured: 640K-&gt;622K(6848K), 0.0016333 secs] 640K-&gt;622K(9920K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0016594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation   total 3072K, used 76K [0x00000000ff600000, 0x00000000ff950000, 0x00000000ff950000)  eden space 2752K,   2% used [0x00000000ff600000, 0x00000000ff613248, 0x00000000ff8b0000)  from space 320K,   0% used [0x00000000ff900000, 0x00000000ff900000, 0x00000000ff950000)  to   space 320K,   0% used [0x00000000ff8b0000, 0x00000000ff8b0000, 0x00000000ff900000) tenured generation   total 6848K, used 622K [0x00000000ff950000, 0x0000000100000000, 0x0000000100000000)   the space 6848K,   9% used [0x00000000ff950000, 0x00000000ff9eb9f0, 0x00000000ff9eba00, 0x0000000100000000) Metaspace       used 3258K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.gc.HelloGC.main(HelloGC.java:11)</code></pre><h2 id="GC之ParNew收集器"><a href="#GC之ParNew收集器" class="headerlink" title="GC之ParNew收集器"></a>GC之ParNew收集器</h2><p>代码例子(在<code>vm option</code>上配置<code>-Xms10m -Xmx10m -XX:+UseParNewGC -XX:+PrintGCDetails</code>)：</p><p><code>ParNew</code>(<code>UseParNewGC</code>)<code>Tenured</code>(<code>UseSerialOldGC</code>)在新生代多线程垃圾回收,老年代单线程垃圾回收,新生代复制算法,老年代标记-整理算法</p><pre><code>**********HelloGC[GC (Allocation Failure) [ParNew: 1810K-&gt;320K(3072K), 0.0006521 secs][Tenured: 313K-&gt;629K(6848K), 0.0017193 secs] 1810K-&gt;629K(9920K), [Metaspace: 3211K-&gt;3211K(1056768K)], 0.0024309 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [Tenured: 629K-&gt;597K(6848K), 0.0015012 secs] 629K-&gt;597K(9920K), [Metaspace: 3211K-&gt;3211K(1056768K)], 0.0015256 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap par new generation   total 3072K, used 123K [0x00000000ff600000, 0x00000000ff950000, 0x00000000ff950000)  eden space 2752K,   4% used [0x00000000ff600000, 0x00000000ff61ef90, 0x00000000ff8b0000)  from space 320K,   0% used [0x00000000ff900000, 0x00000000ff900000, 0x00000000ff950000)  to   space 320K,   0% used [0x00000000ff8b0000, 0x00000000ff8b0000, 0x00000000ff900000) tenured generation   total 6848K, used 597K [0x00000000ff950000, 0x0000000100000000, 0x0000000100000000)   the space 6848K,   8% used [0x00000000ff950000, 0x00000000ff9e5788, 0x00000000ff9e5800, 0x0000000100000000) Metaspace       used 3258K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.gc.HelloGC.main(HelloGC.java:11)</code></pre><h2 id="GC之Parallel收集器"><a href="#GC之Parallel收集器" class="headerlink" title="GC之Parallel收集器"></a>GC之Parallel收集器</h2><p>代码示例(在<code>vm option</code>上配置<code>-Xms10m -Xmx10m -XX:+UseParallelGC -XX:+PrintGCDetails</code>)：</p><p><code>Parallel Scavenge</code>是类似与1<code>ParNew</code>也是一个新生代垃圾收集器.使用复制算法也是一个并行的多线程的垃圾收集器,俗称吞吐量优先收集器</p><p><img src="/medias/GC/Parallel.png" alt="Parallel" title="Parallel"></p><p><code>PSYoungGen</code>(<code>UseeParallelGC</code>)<code>ParOldGen</code>(<code>UseParallelOldGC</code>)在新生代多线程垃圾回收,老年代多线程垃圾回收,新生代复制算法,老年代标记-整理算法</p><pre><code>**********HelloGC[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;512K(2560K)] 2048K-&gt;716K(9728K), 0.0068775 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 512K-&gt;480K(2560K)] 716K-&gt;708K(9728K), 0.0045273 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (Allocation Failure) [PSYoungGen: 480K-&gt;0K(2560K)] [ParOldGen: 228K-&gt;682K(7168K)] 708K-&gt;682K(9728K), [Metaspace: 3058K-&gt;3058K(1056768K)], 0.0239250 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 682K-&gt;682K(9728K), 0.0113502 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 682K-&gt;666K(7168K)] 682K-&gt;666K(9728K), [Metaspace: 3058K-&gt;3058K(1056768K)], 0.0181336 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] Heap PSYoungGen      total 2560K, used 101K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)  eden space 2048K, 4% used [0x00000000ffd00000,0x00000000ffd196a8,0x00000000fff00000)  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen       total 7168K, used 666K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)  object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a6a58,0x00000000ffd00000) Metaspace       used 3091K, capacity 4556K, committed 4864K, reserved 1056768K  class space    used 327K, capacity 392K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.gc.HelloGC.main(HelloGC.java:11)</code></pre><h2 id="GC之ParallelOld收集器"><a href="#GC之ParallelOld收集器" class="headerlink" title="GC之ParallelOld收集器"></a>GC之ParallelOld收集器</h2><p>与GC的Parallel一样</p><h2 id="GC之CMS收集器"><a href="#GC之CMS收集器" class="headerlink" title="GC之CMS收集器"></a>GC之CMS收集器</h2><p>是一种以获取最短回收停顿时间为目标的收集器,适合互联网站或者B/S系统的服务器上,这类应用尤其重视服务器的响应速度,,希望系统的停顿时间最短.CMS非常适合堆内存大,<code>cpu</code>核心数多的服务器端应用,也是<code>G1</code>出现前大型应用的首选收集器</p><p><img src="/medias/GC/CMS.png" alt="CMS" title="CMS"></p><p>并发标记清除收集器的组合是 <code>ParNew</code>+<code>CMS</code>+<code>Serial Old</code></p><p>并发收集低停顿,并发指和用户线程一起执行</p><p>开启该GC收集器的参数 <code>-XX:+UseConcMarkSweepGC</code> 开启该参数后会自动将<code>-XX:+UseParNewGC</code>打开</p><p>开启该参数后,使用ParNew(Young区用) + CMS(Old区用) + Serial Old (备份),,Serial Old将作为CMS出错后的后备收集器</p><p><code> -Xms10m -Xmx10m -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails</code></p><h3 id="CMS四步过程"><a href="#CMS四步过程" class="headerlink" title="CMS四步过程"></a>CMS四步过程</h3><ul><li>初始标记(CMS initial Mark)</li><li>并发标记(CMS concurrent mark) 和用户线程一起</li><li>重新标记(CMS remark)</li><li>并发清除(CMS concurrent sweep) 和用户线程一起</li></ul><p><img src="/medias/GC/CMS%E6%A0%87%E8%AE%B0%E5%9B%9B%E6%AD%A5.png" alt="CMS标记四步" title="CMS标记四步"></p><ul><li><p>优点:并发收集低停顿</p></li><li><p>缺点:由于并发进行,CMS在收集与应用线程会同时增加堆内存的占用,<strong>也就是说,CMS必须要在老年代堆内存用尽之前完成垃圾回收,否则CMS回收失败时</strong>,将触发担保机制,串行老年代收集器将会以STW的方式进行一次GC.从而造成较大的停顿时间,</p><p>并发执行对<code>cpu</code>资源压力大,    采用标记清除算法会导致大量内存碎片</p><p>代码示例(<code>-Xms10m -Xmx10m -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails</code>):</p><pre><code>public class HelloGC &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;**********HelloGC&quot;);//        byte[] bytes = new byte[30 * 1024 * 1024];        String str = &quot;XU&quot;;        try &#123;            while (true)&#123;                str += new Random().nextInt(11111111) + new Random().nextInt(4545455);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;        &#125;    &#125;&#125;</code></pre><p>result:</p><pre><code>[GC (CMS Initial Mark) [1 CMS-initial-mark: 6153K(6848K)] 6587K(9920K), 0.0001189 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-mark-start][CMS-concurrent-mark: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-preclean-start][CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [ParNew: 2963K-&gt;293K(3072K), 0.0005385 secs] 9116K-&gt;6447K(9920K), 0.0005712 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (CMS Final Remark) [YG occupancy: 591 K (3072 K)][Rescan (parallel) , 0.0001756 secs][weak refs processing, 0.0000061 secs][class unloading, 0.0002227 secs][scrub symbol table, 0.0003613 secs][scrub string table, 0.0001051 secs][1 CMS-remark: 6154K(6848K)] 6745K(9920K), 0.0009344 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-sweep-start][CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-reset-start][CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </code></pre></li></ul><h2 id="GC之Serial-Old收集器"><a href="#GC之Serial-Old收集器" class="headerlink" title="GC之Serial Old收集器"></a>GC之Serial Old收集器</h2><p>Serial Old 是Serial 垃圾收集器的老年代版本,已经废弃</p><h1 id="垃圾回收器的选择"><a href="#垃圾回收器的选择" class="headerlink" title="垃圾回收器的选择"></a>垃圾回收器的选择</h1><ul><li><p>单<code>cpu</code>或小内存,单机程序</p><p><code>-XX:+UseSerialGC</code></p></li><li><p>多<code>cpu</code>,需要大吞吐量,如后台计算型应用</p><p><code>-XX:+UseParallelOldGC</code>或者<code>-XX:+UseParallelGC</code></p></li><li><p>多<code>cpu</code>,追求低停顿时间,需要快速响应的互联网应用</p><p><code>-XX:+UseConcMarkSweepGC</code> <code>-XX:+UseParNewGC</code></p></li></ul><p><img src="/medias/GC/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9.png" alt="垃圾收集器的选择" title="垃圾收集器的选择"></p><h2 id="GC之G1垃圾收集器"><a href="#GC之G1垃圾收集器" class="headerlink" title="GC之G1垃圾收集器"></a>GC之G1垃圾收集器</h2><p><img src="/medias/GC/G1.png" alt="G1" title="G1"></p><ul><li>主要的改变是Eden,Survivor和Tenured等内存不在连续,而是分为一个一个大小一样的region区域</li><li>每个region从1M到32M不等.一个region可能属于Eden,Survivor和Tenured内存区域</li></ul><p><img src="/medias/GC/G1%E7%89%B9%E7%82%B9.png" alt="G1特点" title="G1特点"></p><p><img src="/medias/GC/G1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png" alt="G1底层原理" title="G1底层原理"></p><p>Humongous:大对象</p><p><img src="/medias/GC/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="G1收集器运行示意图" title="G1收集器运行示意图"></p><p><img src="/medias/GC/G1%E5%92%8CCMS%E6%AF%94%E8%BE%83.png" alt="G1和CMS比较" title="G1和CMS比较"></p><p>G1使用需要的参数</p><p><code>-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=100</code>:使用G1+最大内存+设置最大停顿时间</p><p> <code>-XX:MaxGCPauseMillis=100</code>：最大GC的停顿时间单位毫秒，这个是软目标，JVM将尽可能（但不保证）停顿时间小于这个时间</p><p>比起CMS的两个优势：</p><ul><li>G1不会产生内存碎片</li><li>可以精准控制停顿时间。该垃圾收集器是把整个堆(新生代、老年代)划分为多个固定大小的区域，根据每次允许停顿的时间去收集垃圾最多的区域</li></ul><pre><code>[GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0014347 secs]   [Parallel Time: 1.2 ms, GC Workers: 4]      [GC Worker Start (ms): Min: 136.4, Avg: 136.7, Max: 136.9, Diff: 0.5]      [Ext Root Scanning (ms): Min: 0.0, Avg: 0.6, Max: 1.1, Diff: 1.1, Sum: 2.3]      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]      [Object Copy (ms): Min: 0.0, Avg: 0.3, Max: 0.6, Diff: 0.6, Sum: 1.3]      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1]         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]      [GC Worker Total (ms): Min: 0.7, Avg: 0.9, Max: 1.2, Diff: 0.5, Sum: 3.8]      [GC Worker End (ms): Min: 137.6, Avg: 137.6, Max: 137.6, Diff: 0.0]   [Code Root Fixup: 0.0 ms]   [Code Root Purge: 0.0 ms]   [Clear CT: 0.0 ms]   [Other: 0.2 ms]      [Choose CSet: 0.0 ms]      [Ref Proc: 0.1 ms]      [Ref Enq: 0.0 ms]      [Redirty Cards: 0.0 ms]      [Humongous Register: 0.0 ms]      [Humongous Reclaim: 0.0 ms]      [Free CSet: 0.0 ms]   [Eden: 2048.0K(6144.0K)-&gt;0.0B(4096.0K) Survivors: 0.0B-&gt;1024.0K Heap: 1830.3K(10.0M)-&gt;712.1K(10.0M)] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC concurrent-root-region-scan-start][GC pause (G1 Humongous Allocation) (young)[GC concurrent-root-region-scan-end, 0.0004298 secs][GC concurrent-mark-start], 0.0010375 secs]   [Root Region Scan Waiting: 0.2 ms]   [Parallel Time: 0.7 ms, GC Workers: 4]      [GC Worker Start (ms): Min: 138.5, Avg: 138.5, Max: 138.5, Diff: 0.1]      [Ext Root Scanning (ms): Min: 0.1, Avg: 0.2, Max: 0.2, Diff: 0.1, Sum: 0.7]      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]      [Object Copy (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.0, Sum: 1.8]      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]         [Termination Attempts: Min: 1, Avg: 2.8, Max: 4, Diff: 3, Sum: 11]      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]      [GC Worker Total (ms): Min: 0.6, Avg: 0.6, Max: 0.6, Diff: 0.1, Sum: 2.5]      [GC Worker End (ms): Min: 139.1, Avg: 139.1, Max: 139.1, Diff: 0.0]   [Code Root Fixup: 0.0 ms]   [Code Root Purge: 0.0 ms]   [Clear CT: 0.0 ms]   [Other: 0.2 ms]      [Choose CSet: 0.0 ms]      [Ref Proc: 0.1 ms]      [Ref Enq: 0.0 ms]      [Redirty Cards: 0.0 ms]      [Humongous Register: 0.0 ms]      [Humongous Reclaim: 0.0 ms]      [Free CSet: 0.0 ms]   [Eden: 0.0B(4096.0K)-&gt;0.0B(4096.0K) Survivors: 1024.0K-&gt;0.0B Heap: 712.1K(10.0M)-&gt;621.5K(10.0M)] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC concurrent-mark-end, 0.0010623 secs][Full GC (Allocation Failure)  621K-&gt;606K(10M), 0.0019750 secs]   [Eden: 0.0B(4096.0K)-&gt;0.0B(4096.0K) Survivors: 0.0B-&gt;0.0B Heap: 621.5K(10.0M)-&gt;606.9K(10.0M)], [Metaspace: 3195K-&gt;3195K(1056768K)] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure)  606K-&gt;588K(10M), 0.0018673 secs]   [Eden: 0.0B(4096.0K)-&gt;0.0B(4096.0K) Survivors: 0.0B-&gt;0.0B Heap: 606.9K(10.0M)-&gt;588.8K(10.0M)], [Metaspace: 3195K-&gt;3195K(1056768K)] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC remark, 0.0000079 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC concurrent-mark-abort]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.gc.HelloGC.main(HelloGC.java:13)Heap garbage-first heap   total 10240K, used 588K [0x00000000ff600000, 0x00000000ff700050, 0x0000000100000000)  region size 1024K, 1 young (1024K), 0 survivors (0K) Metaspace       used 3259K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p>只有 garbage-first heap 和Metaspace</p>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOM详解</title>
      <link href="2020/11/11/oom-xiang-jie/"/>
      <url>2020/11/11/oom-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的OOM-Out-Of-Memory"><a href="#常见的OOM-Out-Of-Memory" class="headerlink" title="常见的OOM(Out Of Memory)"></a>常见的<code>OOM</code>(Out Of Memory)</h1><ol><li><p><code>java.lang.OutOfMemoryError: Java heap space</code>: <code>java</code>堆溢出</p><p>代码示例(在<code>vm option</code>上设置<code>-Xms10m -Xmx10m</code>堆的最大内存和初始内存都为<code>10m</code>):</p><pre><code>public class JavaHeapSpaceDemo &#123;    public static void main(String[] args) &#123;        //申请30m大对象        byte[] bytes = new byte[30 * 1024 * 1024];        //Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    &#125;&#125;</code></pre><p>result:`Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</p><pre><code>at com.xu.juc.oom.JavaHeapSpaceDemo.main(JavaHeapSpaceDemo.java:9)`</code></pre></li><li><p><code>java.lang.OutOfMemoryError: unable to create new native thread</code>:单个进程创建的线程数达到最大,<code>linux</code>默认是1024</p><p>代码示例:</p><pre><code>public class UnableCreateNewNativeThreadDemo &#123;    public static void main(String[] args) &#123;        int i = 0;        while (true)&#123;            i++;            new Thread(()-&gt;&#123;                 try &#123;                    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);                 &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                 &#125;            &#125;,&quot;t1&quot;).start();            System.out.println(&quot;i=&quot;+i);            //Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread        &#125;    &#125;&#125;</code></pre><p>result:</p><pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread    at java.lang.Thread.start0(Native Method)    at java.lang.Thread.start(Thread.java:717)    at com.xu.juc.oom.UnableCreateNewNativeThreadDemo.main(UnableCreateNewNativeThreadDemo.java:20)</code></pre><p>解决方法:在<code>linux</code>下执行<code>ulimit -u</code>命令查看单进程的最大线程数root用户不限制,需要修改最大线程数</p><p><code>vim /etc/security/limits.d/20-nproc.conf</code> 在末尾加上<code>用户名 soft nproc 需要的线程数</code></p></li><li><p><code>java.lang.OutOfMemoryError: Direct buffer memory</code>:最大直接内存溢出,在<code>JVM</code>堆外的内存,元空间就是在那里,<code>NIO</code>可以在直接内存申请对象,而直接内存不归<code>GC</code>管,没有垃圾回收,所以<code>NIO</code>很容易导致这个异常</p><p>代码示例(在<code>vm option</code>上设置<code>-XX:MaxDirectMemorySize=5m</code>最大直接内存为<code>5m</code>):</p><pre><code>public class DirectBufferMemoryDemo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;配置的MaxDirectMemory： &quot; + (sun.misc.VM.maxDirectMemory()/(double)1024/1024) + &quot;MB&quot;);        try &#123;           TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;           e.printStackTrace();        &#125;        //-XX:MaxDirectMemorySize=5m 我们配置为5MB，但实际使用6MB        ByteBuffer bb = ByteBuffer.allocateDirect(6*1024*1024);        //Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory    &#125;&#125;</code></pre><p>result:</p><pre><code>配置的MaxDirectMemory： 5.0MBException in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory    at java.nio.Bits.reserveMemory(Bits.java:694)    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)    at com.xu.juc.oom.DirectBufferMemoryDemo.main(DirectBufferMemoryDemo.java:19)</code></pre></li></ol><p>4.<code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</code>:元空间内存溢出,静态对象过多</p><p>代码示例(在<code>vm option</code>上设置<code>-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</code>最大元空间内存为<code>10m</code>且需要导入两个jar包<code>asm-2.2.3.jar</code>和<code>cglib-nodep-2.2.2</code>):</p><pre><code>public class MetaspaceSizeDemo &#123;    static class OOMTest &#123;    &#125;    public static void main(String[] args) &#123;        int i = 0;        try &#123;            while (true) &#123;                i++;                Enhancer enhancer = new Enhancer();                enhancer.setSuperclass(OOMTest.class);                enhancer.setUseCache(false);                enhancer.setCallback(new MethodInterceptor() &#123;                    @Override                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;                        return methodProxy.invoke(o, args);                    &#125;                &#125;);                enhancer.create();            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;finally &#123;            System.out.println(&quot;************多少次之后发生了异常：&quot; + i);        &#125;        //Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace    &#125;&#125;</code></pre><p>result:</p><pre><code>************多少次之后发生了异常：345Exception in thread &quot;main&quot; Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;main&quot;</code></pre><ol start="5"><li><p><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>:<code>GC</code>回收时间过长抛出,过长的定义是,超过98%的时间用来<code>GC</code>并且回收了不到2%的堆内存,连续多次<code>GC</code>都只回收了不到2%的极端情况才会抛出,该错误会导致<code>GC</code>清理的一点内存很快就会被再次填满,迫使<code>GC</code>再次执行,形成恶性循环,<code>GC</code>使用率100%但是<code>GC</code>却没有成果</p><p>代码示例(在<code>vm option</code>上设置<code>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code>堆的最大内存和初始内存都为<code>10m</code>最大直接内存为<code>5m</code>):</p><pre><code>public class OverHheadLimitExceededDemo &#123;    public static void main(String[] args) &#123;        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        int  i = 0;        while (true)&#123;            list.add(String.valueOf(++i).intern());        &#125;        //Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded    &#125;&#125;</code></pre><p>result:<code>GC</code>效果不明显</p><pre><code>[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;480K(2560K)] 2048K-&gt;936K(9728K), 0.0013541 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2528K-&gt;497K(2560K)] 2984K-&gt;2637K(9728K), 0.0029600 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2545K-&gt;496K(2560K)] 4685K-&gt;4570K(9728K), 0.0026608 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2544K-&gt;504K(2560K)] 6618K-&gt;6570K(9728K), 0.0027356 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 504K-&gt;0K(2560K)] [ParOldGen: 6066K-&gt;6227K(7168K)] 6570K-&gt;6227K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0532608 secs] [Times: user=0.11 sys=0.00, real=0.05 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;821K(2560K)] [ParOldGen: 6227K-&gt;7034K(7168K)] 8275K-&gt;7856K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0433280 secs] [Times: user=0.08 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;2006K(2560K)] [ParOldGen: 7034K-&gt;7034K(7168K)] 9082K-&gt;9040K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0380094 secs] [Times: user=0.08 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;2047K(2560K)] [ParOldGen: 7034K-&gt;7034K(7168K)] 9082K-&gt;9082K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0271896 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7034K-&gt;7034K(7168K)] 9082K-&gt;9082K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0327770 secs] [Times: user=0.03 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7035K-&gt;7035K(7168K)] 9083K-&gt;9083K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0426577 secs] [Times: user=0.08 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7037K-&gt;7037K(7168K)] 9085K-&gt;9085K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0302575 secs] [Times: user=0.05 sys=0.02, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7039K-&gt;7039K(7168K)] 9087K-&gt;9087K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0286187 secs] [Times: user=0.05 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7041K-&gt;7041K(7168K)] 9089K-&gt;9089K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0273682 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7042K-&gt;7042K(7168K)] 9090K-&gt;9090K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0283171 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7044K-&gt;7044K(7168K)] 9092K-&gt;9092K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0307638 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7046K-&gt;7046K(7168K)] 9094K-&gt;9094K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0278689 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7048K-&gt;7048K(7168K)] 9096K-&gt;9096K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0330232 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7049K-&gt;7049K(7168K)] 9097K-&gt;9097K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0329980 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7051K-&gt;7051K(7168K)] 9099K-&gt;9099K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0330133 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7053K-&gt;7053K(7168K)] 9101K-&gt;9101K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0309811 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7055K-&gt;7055K(7168K)] 9103K-&gt;9103K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0313091 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7056K-&gt;7056K(7168K)] 9104K-&gt;9104K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0320053 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7058K-&gt;7058K(7168K)] 9106K-&gt;9106K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0321824 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7060K-&gt;7060K(7168K)] 9108K-&gt;9108K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0319028 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7062K-&gt;7062K(7168K)] 9110K-&gt;9110K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0301211 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7063K-&gt;7063K(7168K)] 9111K-&gt;9111K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0344197 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7065K-&gt;7065K(7168K)] 9113K-&gt;9113K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0339853 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7067K-&gt;7067K(7168K)] 9115K-&gt;9115K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0362988 secs] [Times: user=0.06 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7069K-&gt;7069K(7168K)] 9117K-&gt;9117K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0304594 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7070K-&gt;7070K(7168K)] 9118K-&gt;9118K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0320628 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7082K-&gt;7077K(7168K)] 9130K-&gt;9125K(9728K), [Metaspace: 3242K-&gt;3242K(1056768K)], 0.0312339 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7080K-&gt;7060K(7168K)] 9128K-&gt;9108K(9728K), [Metaspace: 3245K-&gt;3245K(1056768K)], 0.0404792 secs] [Times: user=0.11 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7062K-&gt;7062K(7168K)] 9110K-&gt;9110K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0328442 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7064K-&gt;7064K(7168K)] 9112K-&gt;9112K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0336342 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7065K-&gt;7065K(7168K)] 9113K-&gt;9113K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0367303 secs] [Times: user=0.11 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7067K-&gt;7067K(7168K)] 9115K-&gt;9115K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0329345 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7069K-&gt;7069K(7168K)] 9117K-&gt;9117K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0322445 secs] [Times: user=0.16 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7071K-&gt;7071K(7168K)] 9119K-&gt;9119K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0324392 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7073K-&gt;7073K(7168K)] 9121K-&gt;9121K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0318748 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7074K-&gt;7074K(7168K)] 9122K-&gt;9122K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0308626 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7076K-&gt;7076K(7168K)] 9124K-&gt;9124K(9728K), [Metaspace: 3246K-&gt;3246K(1056768K)], 0.0388157 secs] [Times: user=0.09 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7081K-&gt;7078K(7168K)] 9129K-&gt;9126K(9728K), [Metaspace: 3251K-&gt;3251K(1056768K)], 0.0312564 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7079K-&gt;7079K(7168K)] 9127K-&gt;9127K(9728K), [Metaspace: 3252K-&gt;3252K(1056768K)], 0.0332782 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7081K-&gt;7081K(7168K)] 9129K-&gt;9129K(9728K), [Metaspace: 3252K-&gt;3252K(1056768K)], 0.0313380 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7083K-&gt;7083K(7168K)] 9131K-&gt;9131K(9728K), [Metaspace: 3252K-&gt;3252K(1056768K)], 0.0302698 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7085K-&gt;7085K(7168K)] 9133K-&gt;9133K(9728K), [Metaspace: 3252K-&gt;3252K(1056768K)], 0.0311400 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7143K-&gt;647K(7168K)] 9191K-&gt;647K(9728K), [Metaspace: 3304K-&gt;3304K(1056768K)], 0.0042610 secs] [Times: user=0.05 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 2560K, used 70K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)  eden space 2048K, 4% used [0x00000000ffd00000,0x00000000ffd15368,0x00000000fff00000)  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen       total 7168K, used 647K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)  object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a1ce0,0x00000000ffd00000) Metaspace       used 3371K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 362K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded    at java.lang.Integer.toString(Integer.java:403)    at java.lang.String.valueOf(String.java:3099)    at com.xu.juc.oom.OverHheadLimitExceededDemo.main(OverHheadLimitExceededDemo.java:15)</code></pre></li><li><p><code>java.lang.StackOverflowError</code>:栈内存溢出</p><p>代码示例:</p><pre><code>public class StackOverFlowErrorDemo &#123;    public static void main(String[] args) &#123;        stackOverFlowError();    &#125;    private static void stackOverFlowError() &#123;        stackOverFlowError();        //Exception in thread &quot;main&quot; java.lang.StackOverflowError    &#125;&#125;</code></pre><p>result:`Exception in thread “main” java.lang.StackOverflowError</p><pre><code>at com.xu.juc.oom.StackOverFlowErrorDemo.stackOverFlowError(StackOverFlowErrorDemo.java:13)`</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> OOM </category>
          
          <category> Exception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCRoot</title>
      <link href="2020/11/10/gcroot/"/>
      <url>2020/11/10/gcroot/</url>
      
        <content type="html"><![CDATA[<p><img src="/medias/GC/GCRoot.png" alt="GCRoot" title="GCRoot"></p><p>软引用一半回收一半不回收，内存满回收，在垃圾回收的灰框内就是回收的引用，外面就是不回收的引用</p><ul><li><p><code>GCRoot</code>:枚举根节点做可达性分析（根搜索路径）</p></li><li><p>Java中可以作为<code>GC Roots</code> 的对象</p><ol><li>虚拟机栈(栈帧中的局部变量区,也叫局部变量)</li><li>方法区中的类静态属性引用对象</li><li>方法区中的常量引用对象</li><li>本地方法栈中的<code>JNI</code>(Native方法)引用的对象</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCRoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四大引用</title>
      <link href="2020/11/10/si-da-yin-yong/"/>
      <url>2020/11/10/si-da-yin-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h1><p>强引用就算<code>oom</code>异常也不会被回收</p><p>例子:</p><pre><code>Object o1 = new Object();Object o2 = o1;o1 = null;System.gc();System.out.println(o2);</code></pre><p>result: <code>java.lang.Object@677327b6</code></p><h1 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h1><p>软引用在内存充足的时候不会被回收,在内存不足的时候回被回收</p><p>内存充足例子:</p><pre><code> Object o1 = new Object(); SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o1); System.out.println(o1); System.out.println(softReference.get()); o1 = null; System.gc(); System.out.println(&quot;==================&quot;); System.out.println(o1); System.out.println(softReference.get());</code></pre><p>result:</p><pre><code>java.lang.Object@677327b6java.lang.Object@677327b6==================nulljava.lang.Object@677327b6</code></pre><p>内存不足例子:(在<code>VM option</code>上加上<code>-Xms10m -Xmx10m</code>设置堆内存大小为<code>10m</code>):</p><pre><code>  Object o1 = new Object();  SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o1);  System.out.println(o1);  System.out.println(softReference.get());  o1 = null;  try &#123;  //申请30m内存  byte[] bytes = new byte[10 * 1024 * 1024];  &#125; catch (Exception e) &#123;  e.printStackTrace();  &#125; finally &#123;  System.out.println(&quot;==================&quot;);  System.out.println(o1);  System.out.println(softReference.get());  &#125;</code></pre><p>result:内存不足软引用被回收</p><pre><code>java.lang.Object@677327b6java.lang.Object@677327b6==================nullnullException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.reference.ReferenceDemo.softReferenceNoMemoryNoOut(ReferenceDemo.java:75)    at com.xu.juc.reference.ReferenceDemo.main(ReferenceDemo.java:38)</code></pre><h1 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h1><p>弱引用一旦发生<code>GC</code>就被回收</p><p>例子:</p><pre><code>Object o1 = new Object();WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(o1);System.out.println(o1);System.out.println(weakReference.get());o1 = null;System.gc();System.out.println(&quot;==================&quot;);System.out.println(o1);System.out.println(weakReference.get());</code></pre><p>result:</p><pre><code>java.lang.Object@677327b6java.lang.Object@677327b6==================nullnull</code></pre><h1 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h1><p>虚引用的get方法总是返回<code>null</code>,虚引用需要和<code>ReferenceQueue</code>同时使用,在虚引用被回收前被回收的对象会被加入引用队列中,用来作为回收前的通知效果</p><p>例子:</p><pre><code>Object o1 = new Object();ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(o1,referenceQueue);System.out.println(o1);System.out.println(phantomReference.get());System.out.println(referenceQueue.poll());o1 = null;System.gc();System.out.println(&quot;==================&quot;);System.out.println(o1);System.out.println(phantomReference.get());System.out.println(referenceQueue.poll());</code></pre><p>result:队列中有被回收的对象,虚引用中的get返回<code>null</code></p><pre><code>java.lang.Object@677327b6nullnull==================nullnulljava.lang.ref.PhantomReference@14ae5a5</code></pre><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a><code>WeakHashMap</code></h1><p><code>WeakHashMap</code>在key值不可用时<code>GC</code>将该key-value回收就是回收（Node）</p><p>例子：</p><pre><code>HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();Integer key = new Integer(1);String value = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);map.put(key, value);System.out.println(map);key = null;System.gc();System.out.println(map);System.out.println(&quot;=======================&quot;);WeakHashMap&lt;Integer, String&gt; weakHashMap = new WeakHashMap&lt;&gt;();Integer key1 = new Integer(1);String value1 = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);weakHashMap.put(key1, value1);System.out.println(weakHashMap);key1 = null;System.gc();System.out.println(weakHashMap);</code></pre><p>result:<code>key</code>为<code>null</code>而map中的值不会变为<code>null</code>,map中的值时存储在<code>Node</code>节点中的</p><pre><code>&#123;1=1c4f08765c6e4417a72ed8b09bc16de8&#125;&#123;1=1c4f08765c6e4417a72ed8b09bc16de8&#125;=======================&#123;1=6d39fb7b374942d98cb186a5c81a1594&#125;&#123;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> -GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引用类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常用基础参数</title>
      <link href="2020/11/09/jvm-chang-yong-ji-chu-can-shu/"/>
      <url>2020/11/09/jvm-chang-yong-ji-chu-can-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM常用参数"><a href="#JVM常用参数" class="headerlink" title="JVM常用参数"></a>JVM常用参数</h1><ul><li><p>-Xms : 初始大小内存,默认为物理内存的 1/64     (等价于<code>-XX:InitialHeapSize</code>)</p></li><li><p>-Xmx : 最大分配内存大小,默认为物理内存的 1/4   (等价于<code>-XX:MaxHeapSize</code>)</p></li><li><p>-Xss : 单个线程的大小,一般默认为 512k~1024k   (等价于<code>-XX:ThreadStackSize</code>) 默认值与平台属性有关在windows中为0 设值 ：  <code>-Xss128k</code>或者<code>-XX:ThreadStackSize=128k</code></p></li><li><p>-Xmn : 设置年轻代大小(一般不动)</p></li><li><p>-XX:MetaspaceSize : 设置元空间的大小 （元空间和永久代类似：最大的区别元空间并不在虚拟机中，而在本地内存，因此元空间仅受限于本地内存）</p></li><li><p>-XX:+PrintGCDetails : 打印GC细节</p><p>示例：</p><pre><code>[GC (Allocation Failure) [PSYoungGen: 1761K-&gt;488K(2560K)] 1761K-&gt;672K(9728K), 0.0021268 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 488K-&gt;488K(2560K)] 672K-&gt;680K(9728K), 0.0007457 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 488K-&gt;0K(2560K)] [ParOldGen: 192K-&gt;634K(7168K)] 680K-&gt;634K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0044222 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 634K-&gt;634K(9728K), 0.0002551 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 634K-&gt;615K(7168K)] 634K-&gt;615K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0046726 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] Heap PSYoungGen      total 2560K, used 57K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0e580,0x00000000fff00000)  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen       total 7168K, used 615K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)  object space 7168K, 8% used [0x00000000ff600000,0x00000000ff699fd0,0x00000000ffd00000) Metaspace       used 3261K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 353K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space    at com.xu.juc.TestDemo.main(TestDemo.java:35)</code></pre><p><img src="/medias/GC/GC%E8%AF%A6%E8%A7%A3.png" alt="GC详解" title="GC详解"></p><p><img src="/medias/GC/FullGC%E8%AF%A6%E6%83%85.png" alt="FullGC详情" title="FullGC详情"></p></li><li><p>-XX:SurvivorRatio : 新生代 eden和S0，S1空间比例 默认为8:1:1(-XX:SurvivorRatio=8) </p><ul><li><p>假如(-XX:SurvivorRatio=4)   eden和S0，S1空间比例为4:1:1</p><p>例子：默认</p><pre><code>Heap PSYoungGen      total 78336K, used 5574K [0x000000076b380000, 0x0000000770880000, 0x00000007c0000000)  eden space 69632K, 8% used [0x000000076b380000,0x000000076b8f1a08,0x000000076f780000)  from space 8704K, 0% used [0x0000000770000000,0x0000000770000000,0x0000000770880000)  to   space 8704K, 0% used [0x000000076f780000,0x000000076f780000,0x0000000770000000) ParOldGen       total 175104K, used 0K [0x00000006c1a00000, 0x00000006cc500000, 0x000000076b380000)  object space 175104K, 0% used [0x00000006c1a00000,0x00000006c1a00000,0x00000006cc500000) Metaspace       used 3140K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 341K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p>-XX:SurvivorRatio=4</p><pre><code>Heap PSYoungGen      total 72704K, used 4676K [0x000000076b380000, 0x0000000770880000, 0x00000007c0000000)  eden space 58368K, 8% used [0x000000076b380000,0x000000076b8113a8,0x000000076ec80000)  from space 14336K, 0% used [0x000000076fa80000,0x000000076fa80000,0x0000000770880000)  to   space 14336K, 0% used [0x000000076ec80000,0x000000076ec80000,0x000000076fa80000) ParOldGen       total 175104K, used 0K [0x00000006c1a00000, 0x00000006cc500000, 0x000000076b380000)  object space 175104K, 0% used [0x00000006c1a00000,0x00000006c1a00000,0x00000006cc500000) Metaspace       used 3125K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 337K, capacity 388K, committed 512K, reserved 1048576K</code></pre></li></ul></li><li><p>-XX:NewRatio : 配置老年代和年轻代在堆结构中的比例 默认（-XX:NewRatio=2）新生代占1老年代占2 </p><ul><li><p>假如（-XX:NewRatio=4） 新生代占1 老年代占4</p><p>例子：默认</p><pre><code> PSYoungGen      total 76288K, used 5247K [0x000000076b380000, 0x0000000770880000, 0x00000007c0000000)  eden space 65536K, 8% used [0x000000076b380000,0x000000076b89ff60,0x000000076f380000)  from space 10752K, 0% used [0x000000076fe00000,0x000000076fe00000,0x0000000770880000)  to   space 10752K, 0% used [0x000000076f380000,0x000000076f380000,0x000000076fe00000) ParOldGen       total 175104K, used 0K [0x00000006c1a00000, 0x00000006cc500000, 0x000000076b380000)  object space 175104K, 0% used [0x00000006c1a00000,0x00000006c1a00000,0x00000006cc500000) Metaspace       used 3078K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 332K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p>（-XX:NewRatio=4）</p><pre><code>Heap PSYoungGen      total 46080K, used 4002K [0x000000078d200000, 0x0000000790500000, 0x00000007c0000000)  eden space 39936K, 10% used [0x000000078d200000,0x000000078d5e8828,0x000000078f900000)  from space 6144K, 0% used [0x000000078ff00000,0x000000078ff00000,0x0000000790500000)  to   space 6144K, 0% used [0x000000078f900000,0x000000078f900000,0x000000078ff00000) ParOldGen       total 209920K, used 0K [0x00000006c1a00000, 0x00000006ce700000, 0x000000078d200000)  object space 209920K, 0% used [0x00000006c1a00000,0x00000006c1a00000,0x00000006ce700000) Metaspace       used 3237K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</code></pre></li></ul></li></ul><ul><li><p>-XX:MaxTenuringThreshold : 设置垃圾最大年龄也就是几次GC后到老年代</p><ul><li><p>最大15（JDK8时）</p><pre><code>Error: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit.MaxTenuringThreshold of 18 is invalid; must be between 0 and 15</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM参数</title>
      <link href="2020/11/09/jvm-can-shu/"/>
      <url>2020/11/09/jvm-can-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的三个参数类型"><a href="#JVM的三个参数类型" class="headerlink" title="JVM的三个参数类型"></a>JVM的三个参数类型</h1><h2 id="JVM的标配参数"><a href="#JVM的标配参数" class="headerlink" title="JVM的标配参数"></a>JVM的标配参数</h2><ol><li><p>java -version</p></li><li><p>java -help</p></li><li><p>java -showversion</p><p>没有随着版本变化变化</p></li></ol><h2 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h2><ol><li>-Xint: 解释执行</li><li>-Xcomp:第一次使用就编译成本地代码</li><li>-Xmixed(默认):混合模式</li></ol><h2 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h2><h3 id="Boolean类型的XX参数"><a href="#Boolean类型的XX参数" class="headerlink" title="Boolean类型的XX参数"></a>Boolean类型的XX参数</h3><p>-XX:+或者-某个属性值(+代表开启-代表关闭)</p><ul><li>jps -l : 查看java程序的进程号</li><li>jstack 进程号 : 可以查看某个进程号的运行情况,检查死锁</li><li>jinfo -flag PrintDGDetails 进程号:查看是否开启打印GC细节 ;   jinfo -flag  UseSerialGC 3000:是否使用串行垃圾收集器</li><li>jinfo -flags 进程号: 可以查看JVM的一些基本参数值</li></ul><h3 id="KV型XX参数"><a href="#KV型XX参数" class="headerlink" title="KV型XX参数"></a>KV型XX参数</h3><p>-XX:属性key=属性值value</p><ul><li><p>jinfo -flag MetaspaceSize 进程号: 查看元空间大小            result: -XX:MetaspaceSize=536870912(修改过),在vm option上写入了</p><p>-XX:+PrintGCDetails -XX:MetaspaceSize=512m</p></li><li><p>jinfo -flag MaxTenuringThreshold 进程号：到达多少次GC可以进入养老区（默认15）</p></li><li><p>java -XX:+PrintFlagsInitial: 查看JVM参数的初始值</p></li><li><p>java -XX:+PrintFlagsFinal -version(或 .class文件名)：查看JVM最终参数 （=的是为修改的参数 :=是修改过的参数）相当于在运行时打开了打印最终参数的命令 可以写入多个XX参数 <strong>实际上就是运行java命令然后可以加上一些XX参数</strong></p></li><li><p>java -XX:+PrintCommandLineFlags -version(或 .class文件名)： 查看一些基本的JVM参数值，<strong>主要是为了查看使用的GC垃圾收集器是什么</strong></p></li></ul><p><strong>提示</strong></p><ul><li>-Xms：是-XX:InitialHeapSize的缩写</li><li>-Xmx：是-XX:MaxHeapSize的缩写</li><li>所以他们两个参数是XX型参数（这两个值一般设为一样在生产环境，防止GC次数多）在很多情况下，-Xms和-Xmx设置成一样的。这么设置，是因为当Heap不够用时，会发生内存抖动，影响程序运行稳定性</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor初体验</title>
      <link href="2020/11/07/threadpoolexecutor-chu-ti-yan/"/>
      <url>2020/11/07/threadpoolexecutor-chu-ti-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="创建线程池的五个方法"><a href="#创建线程池的五个方法" class="headerlink" title="创建线程池的五个方法"></a>创建线程池的五个方法</h1><ul><li><p><code>ExecutorService threadPool = Executors.newFixedThreadPool(2);</code>:创建固定数线程池,但是其阻塞队列是<code>new LinkedBlockingQueue&lt;Runnable&gt;()</code>有<code>(Integer.MAX_VALUE)</code>大</p><ol><li><p>主要特点如下:<br>1.1 创建一个定长线程池,可控制线程的最大并发数,超出的线程会在队列中等待.</p><p>1.2 <code>newFixedThreadPool</code>创建的线程池<code>corePoolSize</code>和<code>MaxmumPoolSize</code>是 相等的,它使用的的<code>LinkedBlockingQueue</code></p></li></ol></li></ul><p>代码示例:</p><pre><code>ExecutorService threadPool = Executors.newFixedThreadPool(2);        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //不能再循环中关闭线程池不然抛出默认拒绝策略的异常            threadPool.shutdown();        &#125;</code></pre><ul><li><code>Executors.newSingleThreadExecutor();</code>:创建单一线程,但是其阻塞队列是<code>new LinkedBlockingQueue&lt;Runnable&gt;()</code>有<code>(Integer.MAX_VALUE)</code>大<ol><li>主要特点如下:<br>1.1 创建一个单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务都按照指定顺序执行.<br>1.2 <code>newSingleThreadExecutor</code>将<code>corePoolSize</code>和<code>MaxmumPoolSize</code>都设置为1,它使用的的<code>LinkedBlockingQueue</code></li></ol></li></ul><p>代码示例:</p><pre><code>ExecutorService threadPool = Executors.newSingleThreadExecutor();        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre><ul><li><p><code>ExecutorService threadPool = Executors.newCachedThreadPool();</code>:创建可变线程数，虽然其阻塞队列是<code>SynchronousQueue</code>，但是其<code>MaxmumPoolSize</code>为<code>(Integer.MAX_VALUE)</code></p><ol><li>主要特点如下:<br>1.1 创建一个可缓存线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则创建新线程.<br>1.2 <code>newCachedThreadPool</code>将<code>corePoolSize</code>设置为0,<code>MaxmumPoolSize</code>设置为<code>Integer.MAX_VALUE</code>,它使用的是<code>SynchronousQUeue</code>,也就是说来了任务就创建线程运行,如果线程空闲超过60秒,就销毁线程</li></ol></li></ul><p>代码示例:</p><pre><code>ExecutorService threadPool = Executors.newCachedThreadPool();        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre><ul><li><p><code>Executors.newWorkStealingPool</code>:java8新增,使用目前机器上可以的处理器作为他的并发级别</p><ul><li><img src="/medias/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="线程池" title="线程池"></li></ul></li><li><p><code>手写线程池</code>:</p><ul><li><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.AbortPolicy());</code></pre><p>工作使用!</p></li></ul></li></ul><h1 id="线程池七大参数"><a href="#线程池七大参数" class="headerlink" title="线程池七大参数"></a>线程池七大参数</h1><ol><li><p><code>corePoolSize</code>:线程池常驻的核心线程数</p></li><li><p><code>maximumPoolSize</code>:线程池能够容纳同时执行的最大线程数,此值大于等于1</p></li><li><p><code>keepAliveTime</code>:多余空闲线程的存活时间,当空闲时间达到<code>keepAliveTime</code>值时,多余的线程会被销毁知道只剩下<code>corePoolSize</code>个线程为止</p></li><li><p><code>unit</code>:<code>keepAliveTime</code>的单位</p></li><li><p><code>workQueue</code>:任务队列,被提交但尚未被执行的任务</p></li><li><p><code>threadFactory</code>:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般使用默认即可</p></li><li><p><code>handler</code>:拒接策略,表示当前线程队列满了并且工作线程大于等于线程池最大线程数<code>maximumPoolSize</code>时如何来拒绝</p><ul><li><p>四大拒绝策略都实现了<code>RejectExecutionHandle</code>接口</p><ol><li><p><code>AbortPolicy(默认)</code>:直接抛出异常<code>RejectedException</code>阻止程序的正常运行</p><p>示例:</p><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.AbortPolicy());        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre><p>result:抛出异常</p><pre><code>pool-1-thread-1    服务1pool-1-thread-1    服务3pool-1-thread-1    服务4pool-1-thread-1    服务5pool-1-thread-2    服务2pool-1-thread-3    服务6pool-1-thread-4    服务7pool-1-thread-5    服务8java.util.concurrent.RejectedExecutionException: Task com.xu.juc.threadpool.TreadPoolDemo$$Lambda$1/1023892928@6d03e736 rejected from java.util.concurrent.ThreadPoolExecutor@568db2f2[Running, pool size = 5, active threads = 5, queued tasks = 3, completed tasks = 0]    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)    at com.xu.juc.threadpool.TreadPoolDemo.main(TreadPoolDemo.java:21)</code></pre></li></ol></li></ul></li></ol><ol start="2"><li><p><code>CallerRunPolicy</code>:”调用者执行”一直调用机制,该策略既不会抛弃任务,也不会抛出异常,而是让发起请求者调用</p><p>示例:</p><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.CallerRunsPolicy());        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre></li></ol><p>result:回调使main线程调用方法</p><pre><code> ``` pool-1-thread-1    服务1 main    服务9 main    服务10 pool-1-thread-1    服务3 pool-1-thread-1    服务4 pool-1-thread-1    服务5 pool-1-thread-2    服务2 pool-1-thread-3    服务6 pool-1-thread-4    服务7 pool-1-thread-5    服务8</code></pre><ol start="3"><li><p><code>DiscardOldestPolicy</code>:抛弃任务队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交</p><p>示例:</p><pre><code>ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                    5,                                                    1L,                                                    TimeUnit.SECONDS,                                                    new LinkedBlockingQueue&lt;&gt;(3),                                                    Executors.defaultThreadFactory(),                                                    new ThreadPoolExecutor.DiscardOldestPolicy());        try &#123;            for (int i = 0; i &lt; 10; i++) &#123;                final int tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                &#125;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            threadPool.shutdown();        &#125;</code></pre></li></ol><p>result:只有八个结果等待最久的两个请求被丢弃</p><pre><code> ``` pool-1-thread-1    服务1 pool-1-thread-2    服务2 pool-1-thread-2    服务5 pool-1-thread-2    服务9 pool-1-thread-2    服务10 pool-1-thread-3    服务6 pool-1-thread-5    服务8 pool-1-thread-4    服务7</code></pre><ol start="4"><li><code>DiscardPolicy</code>:直接丢弃任务,不给予任何处理也不抛出异常.如果允许任务丢失,这是最好的拒绝策略</li></ol><p>示例:</p><pre><code> ``` ExecutorService threadPool = new ThreadPoolExecutor(2 ,                                                     5,                                                     1L,                                                     TimeUnit.SECONDS,                                                     new LinkedBlockingQueue&lt;&gt;(3),                                                     Executors.defaultThreadFactory(),                                                     new ThreadPoolExecutor.DiscardPolicy());         try &#123;             for (int i = 0; i &lt; 10; i++) &#123;                 final int tempInt = i;                 threadPool.execute(() -&gt; &#123;                     System.out.println(Thread.currentThread().getName() + &quot;\t服务&quot; + (tempInt + 1));                 &#125;);             &#125;         &#125; catch (Exception e) &#123;             e.printStackTrace();         &#125; finally &#123;             threadPool.shutdown();         &#125;</code></pre><p>result:只有八个请求被服务，后面到的请求直接被抛弃,不给予处理</p><pre><code> pool-1-thread-1    服务1 pool-1-thread-1    服务3 pool-1-thread-1    服务4 pool-1-thread-1    服务5 pool-1-thread-2    服务2 pool-1-thread-4    服务7 pool-1-thread-3    服务6 pool-1-thread-5    服务8</code></pre><p>线程池底层工作原理：</p><ol><li>在创建了线程池后，线程池中的线程数为零。</li><li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<ol><li>如果正在运行的线程数量小于<code>corePoolSize</code>，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于<code>corePoolSize</code>，那么将这个任务放入队列；</li><li>如果这个时候队列满了且正在运行的线程数量还小于<code>maximumPoolSize</code>，那么还是要创建非核心线程立刻运行<strong>这个任务</strong>(不是运行在队列中等待的任务，而是新请求的任务)；</li><li>如果队列满了且正在运行的线程数量大于或等于<code>maximumPoolSize</code>，那么线程池会启动饱和拒绝策略来执行。</li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做超过一定的时间（<code>keepAliveTime</code>）时，线程会判断：<ol><li>如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉。</li><li>所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code>的大小。</li></ol></li></ol><h2 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h2><h2 id="cpu密集型"><a href="#cpu密集型" class="headerlink" title="cpu密集型:"></a><code>cpu</code>密集型:</h2><ul><li><p><code>System.out.println(Runtime.getRuntime().availableProcessors());</code>查看cpu核心数</p><p><code>cpu</code>密集的意思是该任务需要大量的运算,而没有阻塞,<code>cpu</code>一直全速运行.</p><p><code>cpu</code>密集任务只有在真正的多核<code>cpu</code>上才可能得到加速(通过多线程),而在单核<code>cpu</code>上,无论你看多少个模拟的多线程该任务都不可能得到加速,因为<code>cpu</code>总的运算能力就只有那些</p><p><code>cpu</code>密集型任务配置尽可能少的线程数量</p></li><li><p>公式:<code>cpu</code>核心数+1个线程的线程池</p></li></ul><h2 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型:"></a><code>IO</code>密集型:</h2><ol><li><ul><li><p>由于IO密集型任务线程并不是一直在执行任务,则应尽可能配置多线程数</p></li><li><p>公式:<code>cpu</code>核心数*2</p></li></ul></li><li><ul><li><img src="/medias/JUC/IO%E5%AF%86%E9%9B%86%E5%9E%8B.png" alt="IO密集型" title="IO密集型"></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者模式</title>
      <link href="2020/11/07/sheng-chan-zhe-xiao-fei-zhe-mo-shi/"/>
      <url>2020/11/07/sheng-chan-zhe-xiao-fei-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="传统生产者消费者模式"><a href="#传统生产者消费者模式" class="headerlink" title="传统生产者消费者模式"></a>传统生产者消费者模式</h1><pre><code>/** * 共享资源类 */class ShareData &#123;    private int num = 0;    private Lock lock = new ReentrantLock();    private Condition condition = lock.newCondition();    public void increment() throws Exception &#123;        lock.lock();        try &#123;            //判断 防止虚假唤醒使用while            while (num != 0) &#123;                //等待 不生产                condition.await();            &#125;            //干活            num++;            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + num);            //通知唤醒            condition.signalAll();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void deIncrement() throws Exception &#123;        lock.lock();        try &#123;            //判断            while (num == 0) &#123;                //等待 不生产                condition.await();            &#125;            //干活            num--;            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + num);            //通知唤醒            condition.signalAll();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;/** * Description * 一个初始值为0的变量 两个线程交替操作 一个加1 一个减1来5轮 * * @author veliger@163.com * @version 1.0 * @date 2019-04-13 14:01 **/public class ProdConsumerTraditionDemo &#123;    public static void main(String[] args) &#123;        ShareData shareData = new ShareData();        new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 5; i++) &#123;                try &#123;                    shareData.increment();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;AA&quot;).start();        new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 5; i++) &#123;                try &#123;                    shareData.deIncrement();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, &quot;BB&quot;).start();    &#125;&#125;</code></pre><p>加锁是可以保证原子性和可见性的：</p><ul><li>JMM（Java Memory Model）中关于<code>synchronized</code>有如下规定，线程加锁时，必须清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取；线程在解锁时，需要把工作内存中最新的共享变量的值写入到主存，以此来保证共享变量的可见性。(ps这里是个泛指，不是说只有在退出synchronized时才同步变量到主存)</li></ul><h1 id="使用阻塞队列的生产者消费者模式"><a href="#使用阻塞队列的生产者消费者模式" class="headerlink" title="使用阻塞队列的生产者消费者模式"></a>使用阻塞队列的生产者消费者模式</h1><ul><li>代码示例:</li></ul><pre><code>import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;class Cake &#123;    private volatile Boolean FLAG = true;    private AtomicInteger atomicInteger = new AtomicInteger();    private BlockingQueue&lt;String&gt; blockingQueue = null;    public Cake(BlockingQueue&lt;String&gt; blockingQueue) &#123;        this.blockingQueue = blockingQueue;    &#125;    public void productCake() throws InterruptedException &#123;        String data = &quot;&quot;;        Boolean resultValue;        while (FLAG) &#123;            //保证原子性 ,线程安全,CAS            data = atomicInteger.incrementAndGet() + &quot;&quot;;            //blockingQueue有加锁线程安全 ,最多就是存入BlockingQueue中的顺序不是按照1,2,3但是不会出错            resultValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);            if (resultValue) &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t 线程生产&quot; + data + &quot;成功&quot;);            &#125;            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(&quot;老板叫停不在生产蛋糕&quot;);    &#125;    public void consumer() throws InterruptedException &#123;        String result = &quot;&quot;;        while (FLAG) &#123;            result = blockingQueue.poll(2L, TimeUnit.SECONDS);            if (result == null || result == &quot;&quot;) &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t 蛋糕超过两秒没有生产出来消费结束&quot;);                FLAG = false;                System.out.println();                System.out.println();                return;            &#125;            System.out.println(Thread.currentThread().getName() + &quot;\t 线程消费&quot; + result + &quot;成功&quot;);            System.out.println();            System.out.println();        &#125;    &#125;    public void stop() &#123;        FLAG = false;    &#125;&#125;/** * 不使用lock和synchronized的生产者消费者模式 * * @author xulingyun * @create 2020-11-06 10:45 */public class ProductAndConsumer &#123;    public static void main(String[] args) &#123;        Cake cake = new Cake(new ArrayBlockingQueue&lt;&gt;(3));        new Thread(() -&gt; &#123;            try &#123;                cake.productCake();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, &quot;product&quot;).start();        new Thread(() -&gt; &#123;            try &#123;                cake.consumer();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, &quot;consumer&quot;).start();        try &#123;            TimeUnit.SECONDS.sleep(5);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        cake.stop();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> 生产者消费者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产者 </tag>
            
            <tag> 消费者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列的使用</title>
      <link href="2020/11/07/zu-sai-dui-lie-de-shi-yong/"/>
      <url>2020/11/07/zu-sai-dui-lie-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="阻塞队列初认识"><a href="#阻塞队列初认识" class="headerlink" title="阻塞队列初认识"></a>阻塞队列初认识</h1><ul><li>当阻塞队列是空时,从队列中获取元素的操作将会被阻塞.</li><li>当阻塞队列是满时,往队列中添加元素的操作将会被阻塞.</li><li>同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞,知道其他线程从队列中移除一个或者多个元素或者全清空队列后使队列重新变得空闲起来并后续新增.</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>在多线程领域:所谓阻塞,在某些情况下会挂起线程(即线程阻塞),一旦条件满足,被挂起的线程优惠被自动唤醒</li><li>为什么需要使用<code>BlockingQueue</code></li><li>好处是我们不需要关心什么时候需要阻塞线程,什么时候需要唤醒线程,因为<code>BlockingQueue</code>都一手给你包办好了</li><li>在concurrent包 发布以前,在多线程环境下,我们每个程序员都必须自己去控制这些细节,尤其还要兼顾效率和线程安全,而这会给我们的程序带来不小的复杂度.</li></ul><p><img src="/medias/JUC/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="阻塞队列" title="阻塞队列"></p><h2 id="阻塞队列的种类及分析"><a href="#阻塞队列的种类及分析" class="headerlink" title="阻塞队列的种类及分析"></a>阻塞队列的种类及分析</h2><pre><code> 1. **` ArrayBlockingQueue`**:由数组结构组成的有界阻塞队列 2. **`LinkedBlockingQueue`**:由链表结构组成的有界阻塞队列(但默认大小是(`Integer.MAX_VALUE`)21亿 3. `PriorityBlockingQueue`:支持优先级排列的无界阻塞队列 4. `DelayQueue`:使用优先级队列实现的延迟无界阻塞队列 5. **`SynchronousQueue`**:不存储元素的阻塞队列，也即是单个元素的阻塞队列(个人定制版) 6. `LinkedTransferQueue`:有链表结构组成的无界阻塞队列 7. `LinkedBlocking`**`Deque`**:由链表结构组成的双向阻塞队列</code></pre><ul><li><strong><code>SynchronousQueue</code></strong>:没有容量与其他<code>BlcokingQueue</code>不同,<code>SynchronousQueue</code>是一个不存储元素的<code>BlcokingQueue</code>每个<code>put</code>操作必须要等待一个<code>take</code>操作,否则不能继续添加元素,反之亦然(只能使用<code>put()</code>,<code>take()</code>和<code>offer(E e, long timeout, TimeUnit unit)</code>,<code>poll(long timeout, TimeUnit unit)</code>，使用其他两组方法是因为没有存储空间直接抛异常或者返回false)</li></ul><pre><code>import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;/** * @author xulingyun * @create 2020-11-06 9:00 */public class BlockingQueueDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        //不能存储元素，个人定制版，只能使用过时不候offer（time），和不见不散put,使用add和offer直接抛异常或者返回false        SynchronousQueue&lt;String&gt; synchronousQueue = new SynchronousQueue&lt;&gt;();        new Thread(()-&gt;&#123;            try &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t put a&quot;);                synchronousQueue.put(&quot;a&quot;);                System.out.println(Thread.currentThread().getName() + &quot;\t put b&quot;);                synchronousQueue.put(&quot;b&quot;);                System.out.println(Thread.currentThread().getName() + &quot;\t put c&quot;);                synchronousQueue.put(&quot;c&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t1&quot;).start();        new Thread(()-&gt;&#123;            try &#123;                try &#123;                   TimeUnit.SECONDS.sleep(3);                &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;\t take&quot;);                System.out.println(synchronousQueue.take());                try &#123;                   TimeUnit.SECONDS.sleep(3);                &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;\t take&quot;);                System.out.println(synchronousQueue.take());                try &#123;                   TimeUnit.SECONDS.sleep(3);                &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;\t take&quot;);                System.out.println(synchronousQueue.take());            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t2&quot;).start();    &#125;    private static void offer2() throws InterruptedException &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        System.out.println(blockingQueue.offer(&quot;a&quot;, 1, TimeUnit.SECONDS));        System.out.println(blockingQueue.offer(&quot;b&quot;, 1, TimeUnit.SECONDS));        System.out.println(blockingQueue.offer(&quot;c&quot;, 1, TimeUnit.SECONDS));        //过时不候        System.out.println(blockingQueue.offer(&quot;d&quot;, 1, TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));        System.out.println(blockingQueue.poll(1,TimeUnit.SECONDS));    &#125;    private static void offer() &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        System.out.println(blockingQueue.offer(&quot;a&quot;));        System.out.println(blockingQueue.offer(&quot;b&quot;));        System.out.println(blockingQueue.offer(&quot;c&quot;));        System.out.println(blockingQueue.offer(&quot;x&quot;));        System.out.println(blockingQueue.peek());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());    &#125;    private static void take() throws InterruptedException &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        blockingQueue.put(&quot;a&quot;);        blockingQueue.put(&quot;b&quot;);        blockingQueue.put(&quot;c&quot;);        //不见不散 一直阻塞//        blockingQueue.put(&quot;x&quot;);        System.out.println(blockingQueue.take());        System.out.println(blockingQueue.take());        System.out.println(blockingQueue.take());        System.out.println(blockingQueue.take());    &#125;    private static void exception() &#123;        ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);        System.out.println(blockingQueue.add(&quot;a&quot;));        System.out.println(blockingQueue.add(&quot;b&quot;));        System.out.println(blockingQueue.add(&quot;c&quot;));        //队列满抛异常 Queue full//        System.out.println(blockingQueue.add(&quot;x&quot;));        //检查队列头元素        System.out.println(blockingQueue.element());        System.out.println(blockingQueue.remove());        System.out.println(blockingQueue.remove());        System.out.println(blockingQueue.remove());        //队列空报异常NoSuchElementException        System.out.println(blockingQueue.remove());    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> 阻塞队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四种锁的认识</title>
      <link href="2020/11/07/si-chong-suo-de-ren-shi/"/>
      <url>2020/11/07/si-chong-suo-de-ren-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>​        <strong>公平锁：</strong></p><ul><li><p>是指多个线程按照申请锁的顺序来获取锁类似排队打饭 先来后到</p><p><strong>非公平锁：</strong></p></li><li><p>​    是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象</p><p><strong>公平锁/非公平锁</strong></p><ul><li><p>并发包<code>ReentrantLock</code>的创建可以指定构 造函数的boolean类型来得到公平锁或者非公平锁 默认是非公平锁</p></li><li><p><code>ReentrantLock</code>而言,<br>通过构造哈希数指定该锁是否是公平锁 默认是非公平锁 非公平锁的优点在于吞吐量比公平锁大.</p></li></ul></li></ul><pre><code>   对于`synchronized`而言 也是一种非公平锁.</code></pre><p><img src="/medias/JUC/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="公平锁和非公平锁" title="公平锁和非公平锁"></p><h1 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁/递归锁"></a>可重入锁/递归锁</h1><pre><code>*    可重入锁（也叫递归锁），`ReentrantLock`和`Synchronized`都是可重入锁，可重入锁的就是同一线程外层函数获得锁之后内层还有同一个锁可以直接进入而不会陷入死锁，进入内层函数时自动获得锁，**线程可以进入任何一个它已经拥有的锁所同步的代码中**</code></pre><ul><li>可重入锁(也叫做递归锁)<pre><code>* 指的是同一先生外层函数获得锁后,内层敌对函数任然能获取该锁的代码* 在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁* 也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块</code></pre><ul><li>   代码示例：</li></ul></li></ul><pre><code>import java.util.concurrent.locks.ReentrantLock;class ReentrantLockTest&#123;    ReentrantLock lock = new ReentrantLock();    public void method1()&#123;        lock.lock();        try &#123;            System.out.println(&quot;发送短信&quot;);            method2();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void method2()&#123;        lock.lock();        try &#123;            System.out.println(&quot;发送邮箱&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;/** * @author xulingyun * @create 2020-10-30 10:00 */public class LockTest &#123;    public static void main(String[] args) &#123;        ReentrantLockTest reentrantLockTest = new ReentrantLockTest();        reentrantLockTest.method1();    &#125;&#125;</code></pre><ul><li>也可以加多个<code>lock.lock()</code>只要有对应的<code>lock.unlock()</code>即可，不会陷入死锁，要是数量不对应会产生死锁</li></ul><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><pre><code>import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;/** * 手写自旋锁：好处不会阻塞，缺点cpu消耗大 * * @author xulingyun * @create 2020-10-30 10:47 */public class SpinLock &#123;    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();    public void myLock() &#123;        Thread thread = Thread.currentThread();        while (!atomicReference.compareAndSet(null, thread)) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + &quot;线程获得锁!&quot;);    &#125;    public void myUnLock() &#123;        Thread thread = Thread.currentThread();        atomicReference.compareAndSet(thread, null);        System.out.println(Thread.currentThread().getName() + &quot;线程释放锁!&quot;);    &#125;    public static void main(String[] args) &#123;        SpinLock spinLock = new SpinLock();        new Thread(() -&gt; &#123;            spinLock.myLock();            try &#123;                TimeUnit.SECONDS.sleep(5);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            spinLock.myUnLock();        &#125;, &quot;t1&quot;).start();        //主线程睡眠一秒保证t1线程先获得锁        try &#123;            TimeUnit.SECONDS.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        new Thread(() -&gt; &#123;            spinLock.myLock();            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            spinLock.myUnLock();        &#125;, &quot;t2&quot;).start();    &#125;&#125;</code></pre><ul><li>优点：尝试获得锁时不会被阻塞，而是采用循环的方式去尝试获得锁，这样的好处是减少上下文切换消耗的资源。</li><li>缺点：自旋锁虽然减少了上下文切换消耗的资源但是会增加<code>cpu</code>资源的消耗，因为要是某个线程一直在循环尝试获得锁<code>cpu</code>一直在为他消耗性能。</li></ul><h1 id="独占锁-写锁-共享锁-读锁"><a href="#独占锁-写锁-共享锁-读锁" class="headerlink" title="独占锁(写锁)/共享锁(读锁)"></a>独占锁(写锁)/共享锁(读锁)</h1><ul><li>独占锁(写锁) 指该锁一次只能被一个线程所占有,对于<code>ReentrantLock</code>和<code>Synchronized</code>来说都是独占锁</li><li>共享锁(读锁) 指该锁可以被多个线程所共有</li><li>对于<code>ReentrantReadWriteLock</code>其写锁是独占锁，读锁是共享锁</li><li>读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程都是互斥</li></ul><p>代码示例：</p><pre><code>import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantReadWriteLock;class MyCache &#123;    private volatile Map&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();    public void put(String key, Object value) &#123;        rwLock.writeLock().lock();        try &#123;            System.out.println(Thread.currentThread().getName() + &quot;正在写入:&quot; + key);            hashMap.put(key, value);            System.out.println(Thread.currentThread().getName() + &quot;写入完成!&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            rwLock.writeLock().unlock();        &#125;    &#125;    public void get(String key) &#123;        rwLock.readLock().lock();        try &#123;            System.out.println(Thread.currentThread().getName() + &quot;正在读取&quot;);            try &#123;                TimeUnit.MILLISECONDS.sleep(300);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            Object result = hashMap.get(key);            System.out.println(Thread.currentThread().getName() + &quot;读取成功：&quot; + result);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            rwLock.readLock().unlock();        &#125;    &#125;&#125;/** * 读写锁 * 读锁：共享锁 * 写锁：独占锁 * 读读：不排斥 * 读写：排斥 * 写写：排斥 * 写操作 原子+独占 整个过程必须是一个完成的统一整体 中间不允许被分割 被打断 * @author xulingyun * @create 2020-10-30 12:17 */public class ReadWriteLockDemo &#123;    public static void main(String[] args) &#123;        MyCache cache = new MyCache();        for (int i = 0; i &lt; 5; i++) &#123;            final int temp = i;            new Thread(() -&gt; &#123;                cache.put(temp + &quot;&quot;, temp + &quot;&quot;);                cache.get(temp + &quot;&quot;);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公平锁 </tag>
            
            <tag> 非公平锁 </tag>
            
            <tag> 可重入锁 </tag>
            
            <tag> 递归锁 </tag>
            
            <tag> 自旋锁 </tag>
            
            <tag> 独占锁(写锁) </tag>
            
            <tag> 共享锁(读锁) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABA问题</title>
      <link href="2020/10/29/aba-wen-ti/"/>
      <url>2020/10/29/aba-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="ABA问题的产生"><a href="#ABA问题的产生" class="headerlink" title="ABA问题的产生"></a>ABA问题的产生</h1><p><img src="/medias/JUC/ABA%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F.png" alt="ABA问题的产生" title="ABA问题的产生"></p><ul><li><p>解决</p><p>使用原子引用，增加版本（类似与乐观锁）。使用atomic包中的<code>AtomicStampedReference</code>类解决ABA问题，业务逻辑允许也可以不解决ABA</p></li><li><p>代码示例：</p><pre><code>package com.xu.juc;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.atomic.AtomicStampedReference;/** * @author xulingyun * @create 2020-10-29 18:21 */public class ABADemo &#123;    static AtomicReference&lt;Integer&gt; atomicReference = new AtomicReference&lt;&gt;(100);    static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100, 1);    public static void main(String[] args) &#123;        System.out.println(&quot;==========ABA的产生==========&quot;);        new Thread(() -&gt; &#123;            atomicReference.compareAndSet(100, 101);            atomicReference.compareAndSet(101, 100);        &#125;, &quot;t1&quot;).start();        new Thread(() -&gt; &#123;            //睡眠一秒让t1线程进行一次ABA            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            boolean flag = atomicReference.compareAndSet(100, 2020);            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + flag + &quot;修改后的值：&quot; + atomicReference);        &#125;, &quot;t2&quot;).start();        try &#123;            TimeUnit.SECONDS.sleep(2);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;==========ABA的解决==========&quot;);        new Thread(() -&gt; &#123;            int stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + &quot;第一次版本号：&quot; + stamp);            //睡眠一秒使t4获取相同的stamp            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);            System.out.println(Thread.currentThread().getName() + &quot;第二次版本号：&quot; + atomicStampedReference.getStamp());            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);            System.out.println(Thread.currentThread().getName() + &quot;第三次版本号：&quot; + atomicStampedReference.getStamp());        &#125;, &quot;t3&quot;).start();        new Thread(() -&gt; &#123;            int stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + &quot;第一次版本号：&quot; + stamp);            //睡眠三秒让t3线程执行完ABA            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            boolean flag = atomicStampedReference.compareAndSet(100, 2020, stamp, stamp + 1);            System.out.println(Thread.currentThread().getName() + &quot;当前修改是否成功：&quot; + flag + &quot;\t最终atomicStampedReference值:&quot; + atomicStampedReference.getReference());        &#125;, &quot;t4&quot;).start();    &#125;&#125;</code></pre><p><code>result</code>:</p><pre><code>==========ABA的产生==========t2    true修改后的值：2020==========ABA的解决==========t3第一次版本号：1t4第一次版本号：1t3第二次版本号：2t3第三次版本号：3t4当前修改是否成功：false    最终atomicStampedReference值:100</code></pre><p>第一次没有加版本控制产生ABA问题，第二次使用了<code>AtomicStampedReference</code>类解决了ABA问题，类似于乐观锁加上版本号解决ABA。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> ABA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> ABA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS的底层分析</title>
      <link href="2020/10/29/cas-de-di-ceng-fen-xi/"/>
      <url>2020/10/29/cas-de-di-ceng-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="CAS-Compare-And-Swap-比较交换"><a href="#CAS-Compare-And-Swap-比较交换" class="headerlink" title="CAS (Compare And Swap)比较交换"></a>CAS (Compare And Swap)比较交换</h1><h2 id="为什么atomic包下面的类可以保证原子性？"><a href="#为什么atomic包下面的类可以保证原子性？" class="headerlink" title="为什么atomic包下面的类可以保证原子性？"></a>为什么atomic包下面的类可以保证原子性？</h2><p>​    1.  atomic包中的getAndIncrement使用的是unsafe中的方法，unsafe类内是调用系统资源的方法<code>native</code>修饰有很多，其中在实现getAndIncrement时使用了<code>compareAndSwapInt</code>方法，<code>compareAndSwapInt</code>是cpu原语(下面解释)，所以在修改value时是不会出现多线程不安全的问题，保证了原子性</p><p><img src="/medias/JUC/CAS%E6%BA%90%E7%A0%81.png" alt="CAS源码" title="CAS源码"></p><ol start="2"><li><p>在getAddInt第一个变量是代表当前对象，第二个变量是代表内存偏移量(即在内存地址的值)，第三个变量代表修改的值</p></li><li><p>var5获取到内存地址的值然后在修改时与重新获取的值做比较，若是值不变就修改当前内存地址的值，且方法true取反，循环结束</p></li><li><p>若是值与之前获取的var5不一致则修改失败，返回false，取反循环继续</p></li><li><p><strong><code>compareAndSwapInt</code>方法是一个cpu原语</strong></p></li><li><p>cpu原语：计算机进程的控制通常由原语完成。所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被<strong>中断</strong>(个人理解:有点类似与锁)。</p></li></ol><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p><img src="/medias/JUC/CAS%E7%BC%BA%E7%82%B9.png" alt="CAS缺点" title="CAS缺点"></p><ol><li>cpu开销可能会大</li><li>只能保证一个共享变量的原子性</li><li>产生ABA问题（请看下一篇博客）</li></ol><h2 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h2><p>​      unsafe是CAS的核心类由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后面,基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法.<br>注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
          <category> cpu原语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> unsafe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式最终版</title>
      <link href="2020/10/29/dan-li-mo-shi-zui-zhong-ban/"/>
      <url>2020/10/29/dan-li-mo-shi-zui-zhong-ban/</url>
      
        <content type="html"><![CDATA[<pre><code># 单例模式</code></pre><p><img src="/medias/JUC/DCL%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8.png" alt="DCL线程不安全" title="DCL线程不安全"></p><p><img src="/medias/JUC/DCL%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A82.png" alt="DCL线程不安全" title="DCL线程不安全"></p><pre><code>public class SignalTonDemo &#123;    private static volatile SignalTonDemo instance = null;    private SignalTonDemo() &#123;        System.out.println(Thread.currentThread().getName() + &quot;\t实例化对象&quot;);    &#125;    /**DCL(Double Check Lock)双重检查锁     * 线程还未安全，可能发生指令重排序，会使返回的instance为null     * 实例化对象分为三个阶段     * 1.分配空间     * 2.初始化     * 3.被引用     * 在2,3阶段没有依赖关系可以被指令重排序，先被引用在初始化     * 有几率变成在分配空间后 初始化前下一个线程访问if返回false     * ，然后方法方法instance，因为还未初始化所以instance为null     *     * 使用volatile解决，volatile禁止指令重排序    */    public static SignalTonDemo getInstance() &#123;        if (instance == null) &#123;            synchronized (SignalTonDemo.class) &#123;                if (instance == null) &#123;                    instance = new SignalTonDemo();                &#125;            &#125;        &#125;        return instance;    &#125;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(() -&gt; &#123;                SignalTonDemo.getInstance();            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>加锁是可以保证原子性和可见性的：</p><ul><li>JMM（Java Memory Model）中关于<code>synchronized</code>有如下规定，线程加锁时，必须清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取；线程在解锁时，需要把工作内存中最新的共享变量的值写入到主存，以此来保证共享变量的可见性。(ps这里是个泛指，不是说只有在退出synchronized时才同步变量到主存)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC的认识</title>
      <link href="2020/10/27/jvm-de-ren-shi/"/>
      <url>2020/10/27/jvm-de-ren-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="GC的作用域"><a href="#GC的作用域" class="headerlink" title="GC的作用域"></a>GC的作用域</h1><ul><li>GC作用于方法区(Method Area)和堆(heap)</li><li>GC分为三个区 ，Young区，Old区，Perm区</li><li>次数上频繁回收Young区</li><li>次数上较少收集Old区</li><li>基本不动Perm区</li></ul><h1 id="GC算法的总体概述"><a href="#GC算法的总体概述" class="headerlink" title="GC算法的总体概述"></a>GC算法的总体概述</h1><ul><li>JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收都是指新生代</li><li>因此GC按照回收的区域有分了两种类型：一种是普通的GC<code>minor GC</code>，一种是全局GC<code>major GC</code> or <code>Full GC</code><ul><li>普通GC：只针对新生代区域</li><li>全局GC：针对年老代，偶尔伴随对新生代和永久代的GC</li></ul></li></ul><h1 id="GC的四大回收算法"><a href="#GC的四大回收算法" class="headerlink" title="GC的四大回收算法"></a>GC的四大回收算法</h1><ol><li><p>引用计数法：</p><ul><li><p>缺点：</p><ul><li>每次对象赋值时都要维护引用计数器，且计数器本身也有一定消耗；</li><li>较难处理循环引用</li></ul></li><li><p>JVM一般不采用这种方式</p></li></ul></li><li><p>复制算法<code>Copying</code>：</p><ul><li><p>年轻代采用的<code>minor GC</code>:这种GC就是复制算法</p></li><li><p><img src="/medias/GC/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法" title="复制算法"></p></li><li><p>Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old  generation中，也即一旦收集后，Eden是就变成空的了。<br>  当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。</p><p>-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数</p></li><li><p> HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p></li><li><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p></li><li><p>因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 </p><ul><li>缺点： <ol><li>它浪费了一半的内存，这太要命了。 </li><li>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</li></ol></li></ul></li></ul></li><li><p>标记清除<code>Mark-Sweep</code>：</p><ul><li>老年代一般是标记清除和标记压缩的混合实现</li><li><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="标记清除" title="标记清除"></li><li>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。<br> 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象      标记为存活的对象。<br> 清除：遍历整个堆，把未标记的对象清除。<br>用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。</li><li>缺点：<ul><li>此算法需要暂停整个应用，会产生内存碎片</li><li>首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲</li><li>其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。</li></ul></li></ul></li><li><p>标记压缩<code>Mark-Compact</code>：</p><ul><li><p><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9.png" alt="标记压缩" title="标记压缩"></p></li><li><p>  在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 </p><p> 　　标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价</p></li><li><p>缺点：</p><ul><li>标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法</li></ul></li></ul></li><li><p>标记清除压缩<code>Mark-Sweep-Compact</code>：</p><ul><li><img src="/medias/GC/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%8E%8B%E7%BC%A9.png" alt="标记清除压缩" title="标记清除压缩"></li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）</li><li>内存整齐度：复制算法=标记整理算法&gt;标记清除算法</li><li>内存利用率：标记整理算法=标记清除算法&gt;复制算法</li></ol><p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程</p><pre><code>无，没有最好的算法，只有最合适的算法。==========&gt;分代收集算法。</code></pre><ul><li>年轻代(Young Gen)  <ul><li>年轻代特点是区域相对老年代较小，对像存活率低。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul></li><li>老年代(Tenure Gen)<ul><li>老年代的特点是区域较大，对像存活率高。</li><li>这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</li></ul></li><li><strong>Mark阶段的开销与存活对像的数量成正比</strong>，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。</li><li><strong>Sweep阶段的开销与所管理区域的大小形正相关</strong>，但Sweep“就地处决”的特点，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。</li><li><strong>Compact阶段的开销与存活对像的数据成开比</strong>，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。</li><li>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>JVM内存模型以及分区，需要详细到每个分区放什么？</li><li>堆里面的分区：Eden，survival，from ，to ，老年区各自的特点？</li><li>GC的三种收集方法：标记清除，标记压缩，复制算法的原理与特点，分别用在什么地方？</li><li>Minor GC与Full GC分别发生在什么时候？</li></ol>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC的基本认识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile是什么?</title>
      <link href="2020/10/26/volatile-shi-shi-me/"/>
      <url>2020/10/26/volatile-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="valatile是什么？"><a href="#valatile是什么？" class="headerlink" title="valatile是什么？"></a>valatile是什么？</h1><ul><li><p><strong>volatile是一种java虚拟机提供轻量级的同步机制</strong></p></li><li><p><strong>volatile的三个特性</strong></p><ol><li><p>保证可见性</p><ul><li><p>JMM(Java Member Model)Java内存模型</p></li><li><p>由于JVM运行的实体是线程，而每个线程创建时JVM都会为其创建一个工作空间（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主存中，主内存是共享区域，所有线程都可以访问，<strong>但线程对变量的操作（读取赋值等）必须在工作空间中进行，首先要从主内存拷贝数据到工作空间，然后对变量进行操作，操作完成在写回主内存</strong>，不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存中的<strong>变量拷贝副本</strong>，因此不同线程间不能访问对方工作内存，线程间的传值必须通过主内存来完成，其简要访问过程如下：</p><p><img src="/medias/JUC/JMM%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4.png" alt="JMM主内存和工作空间" title="JMM主内存和工作空间"></p></li><li><h2 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h2><pre><code>class Number&#123;    Integer number = 0;    public void addTo30()&#123;        number = 30;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) &#123;        Number number = new Number();        new Thread(()-&gt;&#123;            System.out.println(&quot;Number begin&quot;);            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            number.addTo30();            System.out.println(&quot;修改number=30&quot;);        &#125;, &quot;AAA&quot;).start();        //如果number没有改变就一直死循环        //结果死循环程序未结束，因为主线程复制了number=0到工作空间，之后AAA线程修改了number主线程并不知道        while (number.number == 0)&#123;        &#125;        System.out.println(&quot;Number &quot; + number.number);    &#125;&#125;</code></pre><p><img src="/medias/JUC/%E6%9C%AA%E4%BD%BF%E7%94%A8volatitle.png" alt="未使用volatitle" title="未使用volatitle"></p></li><li><pre><code>class Number&#123;    volatile Integer number = 0;    public void addTo30()&#123;        number = 30;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) &#123;        Number number = new Number();        new Thread(()-&gt;&#123;            System.out.println(&quot;Number begin&quot;);            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            number.addTo30();            System.out.println(&quot;修改number=30&quot;);        &#125;, &quot;AAA&quot;).start();        //如果number没有改变就一直死循环        //结果循环结束，因为number使用了volatile，在线程AAA修改number写回主内存时，        // 主内存通知了main线程，main线程重新读取number值所以循环结束        while (number.number == 0)&#123;        &#125;        System.out.println(&quot;Number &quot; + number.number);    &#125;&#125;</code></pre><p><img src="/medias/JUC/%E4%BD%BF%E7%94%A8volatitle.png" alt="使用volatitle" title="使用volatile"></p></li></ul></li><li><p>不保证原子性</p><ul><li><p>使用volatile的++操作</p><pre><code>class Number&#123;    volatile Integer number = 0;    public void addPlusPlus()&#123;        /*        number++不是原子操作        第一步：取出number数据        第二步：number加一        第三步：写回数据             */        number++;    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) throws InterruptedException &#123;         //减少计数JUC辅助工具类        CountDownLatch countDownLatch = new CountDownLatch(20);        Number number = new Number();        for (int i = 1; i &lt;= 20; i++) &#123;            new Thread(()-&gt;&#123;                for (int j = 0; j &lt; 1000; j++) &#123;                    /**                     * 在工作空间volatile虽然会然主内存通知工作空间数据的修改                     * 但是在一个线程写入数据的同时主内存开始通知，其他线程还没被通知到也写入数据到主内存中                     * 产生了写覆盖，所以最后的数值没有到达20000                     */                    number.addPlusPlus();                &#125;                countDownLatch.countDown();            &#125;,&quot;BBB&quot;).start();        &#125;        countDownLatch.await();        System.out.println(&quot;number最终得分：&quot; + number.number);    &#125;&#125;</code></pre><pre><code>result:number最终得分：18167Process finished with exit code 0</code></pre><p>结果表明volatile不保证原子性，虽然使用synchronized可以解决该问题，但是未免有点杀鸡用牛刀，其他解决方法：</p></li><li><p>使用atomicInteger类型可以解决原子性问题：</p><pre><code>class Number&#123;    volatile Integer number = 0;    AtomicInteger atomicInteger = new AtomicInteger();    public void addPlusPlus()&#123;        /*        number++不是原子操作        第一步：取出number数据        第二步：number加一        第三步：写回数据         */        number++;        atomicInteger.getAndIncrement();    &#125;&#125;public class VolatileTest &#123;    public static void main(String[] args) throws InterruptedException &#123;        //减少计数JUC辅助工具类        CountDownLatch countDownLatch = new CountDownLatch(20);        Number number = new Number();        for (int i = 1; i &lt;= 20; i++) &#123;            new Thread(()-&gt;&#123;                for (int j = 0; j &lt; 1000; j++) &#123;                    number.addPlusPlus();                &#125;                countDownLatch.countDown();            &#125;,&quot;BBB&quot;).start();        &#125;        countDownLatch.await();        System.out.println(&quot;number最终得分：&quot; + number.number);        System.out.println(&quot;atomicInteger最终得分：&quot; + number.atomicInteger);    &#125;&#125;</code></pre><pre><code>result:number最终得分：18923atomicInteger最终得分：20000Process finished with exit code 0</code></pre></li></ul></li></ol></li></ul><ol start="3"><li><p>禁止指令重排</p><p><img src="/medias/JUC/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="指令重排序" title="指令重排序"></p><p>加上volatile可以使指令不重排序</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="2020/10/23/da-jian-ge-ren-bo-ke/"/>
      <url>2020/10/23/da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客需要node-js的npm和git环境"><a href="#搭建博客需要node-js的npm和git环境" class="headerlink" title="搭建博客需要node.js的npm和git环境"></a>搭建博客需要node.js的npm和git环境</h1><h2 id="首先下载npm和git"><a href="#首先下载npm和git" class="headerlink" title="首先下载npm和git"></a>首先下载<a href="http://nodejs.cn/download/">npm</a>和<a href="https://git-scm.com/download/">git</a></h2><h2 id="安装hexo运行环境"><a href="#安装hexo运行环境" class="headerlink" title="安装hexo运行环境"></a>安装hexo运行环境</h2><ol><li><p>npm和git安装完成后的检验是 npm -v 和 node -v</p></li><li><p>如图：</p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%A3%80%E9%AA%8Cnpm%E5%92%8Cnode.png" alt="install" title="node"></p><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%A3%80%E9%AA%8Cgit.png" alt="git" title="git"> </p></li></ol><h2 id="安装hexo基本框架"><a href="#安装hexo基本框架" class="headerlink" title="安装hexo基本框架"></a>安装hexo基本框架</h2><ol><li><p>新建一个文件夹给自己的博客找个小窝</p></li><li><p>然后进入新建的文件夹，右击Git Bash Here</p></li><li><pre><code>//第一条   这是安装hexo的基础框架 , npm安装到全局，熟悉的话可以安装局部npm install -g hexo//第二条   这是初始化hexo框架 这个可能会比较慢(要有耐心)hexo init//第三条 安装所需要的组件npm install//第四条 编译生成静态页面hexo g//第五条 启动本地服务hexo s</code></pre></li></ol><ol start="4"><li><p>启动后的结果<img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E8%BF%90%E8%A1%8C.png" alt="yans" title="演示结果"></p></li><li><p>然后访问 <a href="http://localhost:4000/">http://localhost:4000/</a> <img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/%E6%BC%94%E7%A4%BA.png" alt="result" title="页面"></p></li></ol><h1 id="hexo命令大全："><a href="#hexo命令大全：" class="headerlink" title="hexo命令大全："></a>hexo命令大全：</h1><pre><code>hexo n &quot;博客名字&quot; #执行成功后会在根目录下\source\_posts生成一个同名的md文件 #编写这个文件就可 然后执行 hexo clean hexo g  hexo d 部署到github上去hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g  #生成静态网页hexo s  #启动服务预览hexo d  #开始部署hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署</code></pre><h1 id="github配置个人博客免域名"><a href="#github配置个人博客免域名" class="headerlink" title="github配置个人博客免域名"></a>github配置个人博客免域名</h1><ol><li><p>注册一个github账户，用邮箱就行<img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/github%E5%88%9B%E5%BB%BArepositories.png" alt="github" title="github配置"></p></li><li><p>然后点击new </p></li><li><p><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/github.png" alt="github" title="gitthub"></p></li><li><p>我的因为创建过了所以报错</p></li><li><p>创建repository的名字一定要是 用户名.github.io,不然访问不到</p></li><li><p>之后将code哪里http的git连接复制粘贴到 安装好的hexo的 <code>_config.yml</code> 中</p><pre><code>deploy:  type: git  repo: https://github.com/xu196/xu196.github.io.git  branch: master</code></pre><p>里面 , 运行下面代码在根目录的命令行界面</p><pre><code>hexo cleanhexo ghexo d</code></pre><ul><li>如果上面repo配置的是http的路径<code>hexo d</code> 之后需要输入github的用户名和密码</li><li>要是想要无密码push就需要配置ssh的路径，这里不做过多说明，需要自行百度</li><li><code>hexo d</code> 成功页面</li><li><img src="https://my-blog1024.oss-cn-beijing.aliyuncs.com/push%E6%88%90%E5%8A%9F.png" alt="push" title="push to github"></li><li>接下来就可以访问博客了， 就是之前设置的<code>repository</code>名字，我的是<code>xly-star.github.io</code></li><li>接下来就可以尽情的开发自己的博客了</li><li>美化博客请看接下来的后续博客！</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
